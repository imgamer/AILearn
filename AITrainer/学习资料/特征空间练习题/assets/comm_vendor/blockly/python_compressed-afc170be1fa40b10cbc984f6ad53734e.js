//# sourceMappingURL=python_compressed.js.map
var _asset_pipeline_loaded_modules = _asset_pipeline_loaded_modules || {}
  , _asset_pipeline_require = function(U) {
    var h = _asset_pipeline_loaded_modules[U];
    if (void 0 != h)
        return h.exports;
    h = _asset_pipeline_modules[U];
    return void 0 != h ? (_asset_pipeline_loaded_modules[U] = h(),
    _asset_pipeline_loaded_modules[U].exports) : null
}
  , _asset_pipeline_modules = _asset_pipeline_modules || {};
_asset_pipeline_modules["comm_vendor/blockly/blockly_compressed.js"] = function() {
    var U = {
        exports: {}
    }
      , h = U.exports;
    (function(e, z) {
        "function" === typeof define && define.amd ? define([], z) : "object" === typeof h ? U.exports = z() : e.Blockly = z()
    }
    )(this, function() {
        const e = {};
        var z = z || {};
        z.scope = {};
        z.createTemplateTagFirstArg = function(a) {
            return a.raw = a
        }
        ;
        z.createTemplateTagFirstArgWithRaw = function(a, b) {
            a.raw = b;
            return a
        }
        ;
        z.arrayIteratorImpl = function(a) {
            var b = 0;
            return function() {
                return b < a.length ? {
                    done: !1,
                    value: a[b++]
                } : {
                    done: !0
                }
            }
        }
        ;
        z.arrayIterator = function(a) {
            return {
                next: z.arrayIteratorImpl(a)
            }
        }
        ;
        z.makeIterator = function(a) {
            var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
            return b ? b.call(a) : z.arrayIterator(a)
        }
        ;
        z.arrayFromIterator = function(a) {
            for (var b, c = []; !(b = a.next()).done; )
                c.push(b.value);
            return c
        }
        ;
        z.arrayFromIterable = function(a) {
            return a instanceof Array ? a : z.arrayFromIterator(z.makeIterator(a))
        }
        ;
        z.owns = function(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b)
        }
        ;
        z.ASSUME_ES5 = !1;
        z.ASSUME_NO_NATIVE_MAP = !1;
        z.ASSUME_NO_NATIVE_SET = !1;
        z.SIMPLE_FROUND_POLYFILL = !1;
        z.ISOLATE_POLYFILLS = !1;
        z.FORCE_POLYFILL_PROMISE = !1;
        z.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1;
        z.defineProperty = z.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {
            if (a == Array.prototype || a == Object.prototype)
                return a;
            a[b] = c.value;
            return a
        }
        ;
        z.getGlobal = function(a) {
            a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global];
            for (var b = 0; b < a.length; ++b) {
                var c = a[b];
                if (c && c.Math == Math)
                    return c
            }
            throw Error("Cannot find global object");
        }
        ;
        z.global = z.getGlobal(this);
        z.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
        z.TRUST_ES6_POLYFILLS = !z.ISOLATE_POLYFILLS || z.IS_SYMBOL_NATIVE;
        z.polyfills = {};
        z.propertyToPolyfillSymbol = {};
        z.POLYFILL_PREFIX = "$jscp$";
        z.polyfill = function(a, b, c, d) {
            b && (z.ISOLATE_POLYFILLS ? z.polyfillIsolated(a, b, c, d) : z.polyfillUnisolated(a, b, c, d))
        }
        ;
        z.polyfillUnisolated = function(a, b, c, d) {
            c = z.global;
            a = a.split(".");
            for (d = 0; d < a.length - 1; d++) {
                var f = a[d];
                if (!(f in c))
                    return;
                c = c[f]
            }
            a = a[a.length - 1];
            d = c[a];
            b = b(d);
            b != d && null != b && z.defineProperty(c, a, {
                configurable: !0,
                writable: !0,
                value: b
            })
        }
        ;
        z.polyfillIsolated = function(a, b, c, d) {
            var f = a.split(".");
            a = 1 === f.length;
            d = f[0];
            d = !a && d in z.polyfills ? z.polyfills : z.global;
            for (var g = 0; g < f.length - 1; g++) {
                var m = f[g];
                if (!(m in d))
                    return;
                d = d[m]
            }
            f = f[f.length - 1];
            c = z.IS_SYMBOL_NATIVE && "es6" === c ? d[f] : null;
            b = b(c);
            null != b && (a ? z.defineProperty(z.polyfills, f, {
                configurable: !0,
                writable: !0,
                value: b
            }) : b !== c && (void 0 === z.propertyToPolyfillSymbol[f] && (c = 1E9 * Math.random() >>> 0,
            z.propertyToPolyfillSymbol[f] = z.IS_SYMBOL_NATIVE ? z.global.Symbol(f) : z.POLYFILL_PREFIX + c + "$" + f),
            z.defineProperty(d, z.propertyToPolyfillSymbol[f], {
                configurable: !0,
                writable: !0,
                value: b
            })))
        }
        ;
        z.assign = z.TRUST_ES6_POLYFILLS && "function" == typeof Object.assign ? Object.assign : function(a, b) {
            for (var c = 1; c < arguments.length; c++) {
                var d = arguments[c];
                if (d)
                    for (var f in d)
                        z.owns(d, f) && (a[f] = d[f])
            }
            return a
        }
        ;
        z.objectCreate = z.ASSUME_ES5 || "function" == typeof Object.create ? Object.create : function(a) {
            var b = function() {};
            b.prototype = a;
            return new b
        }
        ;
        z.getConstructImplementation = function() {
            function a() {
                function c() {}
                new c;
                Reflect.construct(c, [], function() {});
                return new c instanceof c
            }
            if (z.TRUST_ES6_POLYFILLS && "undefined" != typeof Reflect && Reflect.construct) {
                if (a())
                    return Reflect.construct;
                var b = Reflect.construct;
                return function(c, d, f) {
                    c = b(c, d);
                    f && Reflect.setPrototypeOf(c, f.prototype);
                    return c
                }
            }
            return function(c, d, f) {
                void 0 === f && (f = c);
                f = z.objectCreate(f.prototype || Object.prototype);
                return Function.prototype.apply.call(c, f, d) || f
            }
        }
        ;
        z.construct = {
            valueOf: z.getConstructImplementation
        }.valueOf();
        z.underscoreProtoCanBeSet = function() {
            var a = {
                a: !0
            }
              , b = {};
            try {
                return b.__proto__ = a,
                b.a
            } catch (c) {}
            return !1
        }
        ;
        z.setPrototypeOf = z.TRUST_ES6_POLYFILLS && "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf : z.underscoreProtoCanBeSet() ? function(a, b) {
            a.__proto__ = b;
            if (a.__proto__ !== b)
                throw new TypeError(a + " is not extensible");
            return a
        }
        : null;
        z.inherits = function(a, b) {
            a.prototype = z.objectCreate(b.prototype);
            a.prototype.constructor = a;
            if (z.setPrototypeOf) {
                var c = z.setPrototypeOf;
                c(a, b)
            } else
                for (c in b)
                    if ("prototype" != c)
                        if (Object.defineProperties) {
                            var d = Object.getOwnPropertyDescriptor(b, c);
                            d && Object.defineProperty(a, c, d)
                        } else
                            a[c] = b[c];
            a.superClass_ = b.prototype
        }
        ;
        z.polyfill("Reflect", function(a) {
            return a ? a : {}
        }, "es6", "es3");
        z.polyfill("Reflect.construct", function(a) {
            return z.construct
        }, "es6", "es3");
        z.polyfill("Reflect.setPrototypeOf", function(a) {
            if (a)
                return a;
            if (z.setPrototypeOf) {
                var b = z.setPrototypeOf;
                return function(c, d) {
                    try {
                        return b(c, d),
                        !0
                    } catch (f) {
                        return !1
                    }
                }
            }
            return null
        }, "es6", "es5");
        z.polyfill("globalThis", function(a) {
            return a || z.global
        }, "es_2020", "es3");
        z.checkStringArgs = function(a, b, c) {
            if (null == a)
                throw new TypeError("The 'this' value for String.prototype." + c + " must not be null or undefined");
            if (b instanceof RegExp)
                throw new TypeError("First argument to String.prototype." + c + " must not be a regular expression");
            return a + ""
        }
        ;
        z.polyfill("String.prototype.startsWith", function(a) {
            return a ? a : function(b, c) {
                var d = z.checkStringArgs(this, b, "startsWith");
                b += "";
                var f = d.length
                  , g = b.length;
                c = Math.max(0, Math.min(c | 0, d.length));
                for (var m = 0; m < g && c < f; )
                    if (d[c++] != b[m++])
                        return !1;
                return m >= g
            }
        }, "es6", "es3");
        z.initSymbol = function() {}
        ;
        z.polyfill("Symbol", function(a) {
            if (a)
                return a;
            var b = function(g, m) {
                this.$jscomp$symbol$id_ = g;
                z.defineProperty(this, "description", {
                    configurable: !0,
                    writable: !0,
                    value: m
                })
            };
            b.prototype.toString = function() {
                return this.$jscomp$symbol$id_
            }
            ;
            var c = "jscomp_symbol_" + (1E9 * Math.random() >>> 0) + "_"
              , d = 0
              , f = function(g) {
                if (this instanceof f)
                    throw new TypeError("Symbol is not a constructor");
                return new b(c + (g || "") + "_" + d++,g)
            };
            return f
        }, "es6", "es3");
        z.polyfill("Symbol.iterator", function(a) {
            if (a)
                return a;
            a = Symbol("Symbol.iterator");
            for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c = 0; c < b.length; c++) {
                var d = z.global[b[c]];
                "function" === typeof d && "function" != typeof d.prototype[a] && z.defineProperty(d.prototype, a, {
                    configurable: !0,
                    writable: !0,
                    value: function() {
                        return z.iteratorPrototype(z.arrayIteratorImpl(this))
                    }
                })
            }
            return a
        }, "es6", "es3");
        z.iteratorPrototype = function(a) {
            a = {
                next: a
            };
            a[Symbol.iterator] = function() {
                return this
            }
            ;
            return a
        }
        ;
        z.iteratorFromArray = function(a, b) {
            a instanceof String && (a += "");
            var c = 0
              , d = !1
              , f = {
                next: function() {
                    if (!d && c < a.length) {
                        var g = c++;
                        return {
                            value: b(g, a[g]),
                            done: !1
                        }
                    }
                    d = !0;
                    return {
                        done: !0,
                        value: void 0
                    }
                }
            };
            f[Symbol.iterator] = function() {
                return f
            }
            ;
            return f
        }
        ;
        z.polyfill("Array.prototype.keys", function(a) {
            return a ? a : function() {
                return z.iteratorFromArray(this, function(b) {
                    return b
                })
            }
        }, "es6", "es3");
        z.polyfill("Object.setPrototypeOf", function(a) {
            return a || z.setPrototypeOf
        }, "es6", "es5");
        z.polyfill("Array.prototype.values", function(a) {
            return a ? a : function() {
                return z.iteratorFromArray(this, function(b, c) {
                    return c
                })
            }
        }, "es8", "es3");
        z.polyfill("Object.entries", function(a) {
            return a ? a : function(b) {
                var c = [], d;
                for (d in b)
                    z.owns(b, d) && c.push([d, b[d]]);
                return c
            }
        }, "es8", "es3");
        z.polyfill("Array.prototype.fill", function(a) {
            return a ? a : function(b, c, d) {
                var f = this.length || 0;
                0 > c && (c = Math.max(0, f + c));
                if (null == d || d > f)
                    d = f;
                d = Number(d);
                0 > d && (d = Math.max(0, f + d));
                for (c = Number(c || 0); c < d; c++)
                    this[c] = b;
                return this
            }
        }, "es6", "es3");
        z.typedArrayFill = function(a) {
            return a ? a : Array.prototype.fill
        }
        ;
        z.polyfill("Int8Array.prototype.fill", z.typedArrayFill, "es6", "es5");
        z.polyfill("Uint8Array.prototype.fill", z.typedArrayFill, "es6", "es5");
        z.polyfill("Uint8ClampedArray.prototype.fill", z.typedArrayFill, "es6", "es5");
        z.polyfill("Int16Array.prototype.fill", z.typedArrayFill, "es6", "es5");
        z.polyfill("Uint16Array.prototype.fill", z.typedArrayFill, "es6", "es5");
        z.polyfill("Int32Array.prototype.fill", z.typedArrayFill, "es6", "es5");
        z.polyfill("Uint32Array.prototype.fill", z.typedArrayFill, "es6", "es5");
        z.polyfill("Float32Array.prototype.fill", z.typedArrayFill, "es6", "es5");
        z.polyfill("Float64Array.prototype.fill", z.typedArrayFill, "es6", "es5");
        var l = l || {};
        l.global = globalThis || root;
        l.define = function(a, b) {
            return b
        }
        ;
        l.DEBUG = !1;
        l.DISALLOW_TEST_ONLY_CODE = !l.DEBUG;
        l.provide = function(a) {}
        ;
        l.module = function(a) {}
        ;
        l.module.get = function(a) {}
        ;
        l.module.declareLegacyNamespace = function() {}
        ;
        l.setTestOnly = function(a) {
            if (l.DISALLOW_TEST_ONLY_CODE)
                throw a = a || "",
                Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
        }
        ;
        l.require = function(a) {}
        ;
        l.requireType = function(a) {}
        ;
        var q = {
            warn: function(a, b, c, d) {
                a = a + " was deprecated on " + b + " and will be deleted on " + c + ".";
                d && (a += "\nUse " + d + " instead.");
                console.warn(a)
            }
        }
          , v = {}
          , D = !1;
        v.register = function(a) {
            if (D)
                throw Error("CSS already injected");
            Array.isArray(a) ? ((0,
            q.warn)("Registering CSS by passing an array of strings", "September 2021", "September 2022", "css.register passing a multiline string"),
            v.content += "\n" + a.join("\n")) : v.content += "\n" + a
        }
        ;
        v.inject = function(a, b) {
            D || (D = !0,
            a && (a = b.replace(/[\\/]$/, ""),
            b = v.content.replace(/<<<PATH>>>/g, a),
            v.content = "",
            a = document.createElement("style"),
            a.id = "blockly-common-style",
            b = document.createTextNode(b),
            a.appendChild(b),
            document.head.insertBefore(a, document.head.firstChild)))
        }
        ;
        v.content = '\n  .blocklySvg {\n    background-color: #fff;\n    outline: none;\n    overflow: hidden;  /* IE overflows by default. */\n    position: absolute;\n    display: block;\n  }\n\n  .blocklyWidgetDiv {\n    display: none;\n    position: absolute;\n    z-index: 99999;  /* big value for bootstrap3 compatibility */\n  }\n\n  .injectionDiv {\n    height: 100%;\n    position: relative;\n    overflow: hidden;  /* So blocks in drag surface disappear at edges */\n    touch-action: none;\n  }\n\n  .blocklyNonSelectable {\n    user-select: none;\n    -ms-user-select: none;\n    -webkit-user-select: none;\n  }\n\n  .blocklyWsDragSurface {\n    display: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n\n  /* Added as a separate rule with multiple classes to make it more specific\n     than a bootstrap rule that selects svg:root. See issue #1275 for context.\n  */\n  .blocklyWsDragSurface.blocklyOverflowVisible {\n    overflow: visible;\n  }\n\n  .blocklyBlockDragSurface {\n    display: none;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    overflow: visible !important;\n    z-index: 50;  /* Display below toolbox, but above everything else. */\n  }\n\n  .blocklyBlockCanvas.blocklyCanvasTransitioning,\n  .blocklyBubbleCanvas.blocklyCanvasTransitioning {\n    transition: transform .5s;\n  }\n\n  .blocklyTooltipDiv {\n    background-color: #ffffc7;\n    border: 1px solid #ddc;\n    box-shadow: 4px 4px 20px 1px rgba(0,0,0,.15);\n    color: #000;\n    display: none;\n    font: 9pt sans-serif;\n    opacity: .9;\n    padding: 2px;\n    position: absolute;\n    z-index: 100000;  /* big value for bootstrap3 compatibility */\n  }\n\n  .blocklyDropDownDiv {\n    position: absolute;\n    left: 0;\n    top: 0;\n    z-index: 1000;\n    display: none;\n    border: 1px solid;\n    border-color: #dadce0;\n    background-color: #fff;\n    border-radius: 2px;\n    padding: 4px;\n    box-shadow: 0 0 3px 1px rgba(0,0,0,.3);\n  }\n\n  .blocklyDropDownDiv.blocklyFocused {\n    box-shadow: 0 0 6px 1px rgba(0,0,0,.3);\n  }\n\n  .blocklyDropDownContent {\n    max-height: 300px;  // @todo: spec for maximum height.\n    overflow: auto;\n    overflow-x: hidden;\n    position: relative;\n  }\n\n  .blocklyDropDownArrow {\n    position: absolute;\n    left: 0;\n    top: 0;\n    width: 16px;\n    height: 16px;\n    z-index: -1;\n    background-color: inherit;\n    border-color: inherit;\n  }\n\n  .blocklyDropDownButton {\n    display: inline-block;\n    float: left;\n    padding: 0;\n    margin: 4px;\n    border-radius: 4px;\n    outline: none;\n    border: 1px solid;\n    transition: box-shadow .1s;\n    cursor: pointer;\n  }\n\n  .blocklyArrowTop {\n    border-top: 1px solid;\n    border-left: 1px solid;\n    border-top-left-radius: 4px;\n    border-color: inherit;\n  }\n\n  .blocklyArrowBottom {\n    border-bottom: 1px solid;\n    border-right: 1px solid;\n    border-bottom-right-radius: 4px;\n    border-color: inherit;\n  }\n\n  .blocklyResizeSE {\n    cursor: se-resize;\n    fill: #aaa;\n  }\n\n  .blocklyResizeSW {\n    cursor: sw-resize;\n    fill: #aaa;\n  }\n\n  .blocklyResizeLine {\n    stroke: #515A5A;\n    stroke-width: 1;\n  }\n\n  .blocklyHighlightedConnectionPath {\n    fill: none;\n    stroke: #fc3;\n    stroke-width: 4px;\n  }\n\n  .blocklyPathLight {\n    fill: none;\n    stroke-linecap: round;\n    stroke-width: 1;\n  }\n\n  .blocklySelected>.blocklyPathLight {\n    display: none;\n  }\n\n  .blocklyDraggable {\n    /* backup for browsers (e.g. IE11) that don\'t support grab */\n    cursor: url("<<<PATH>>>/handopen.cur"), auto;\n    cursor: grab;\n    cursor: -webkit-grab;\n  }\n\n    /* backup for browsers (e.g. IE11) that don\'t support grabbing */\n  .blocklyDragging {\n    /* backup for browsers (e.g. IE11) that don\'t support grabbing */\n    cursor: url("<<<PATH>>>/handclosed.cur"), auto;\n    cursor: grabbing;\n    cursor: -webkit-grabbing;\n  }\n\n    /* Changes cursor on mouse down. Not effective in Firefox because of\n       https://bugzilla.mozilla.org/show_bug.cgi?id=771241 */\n  .blocklyDraggable:active {\n    /* backup for browsers (e.g. IE11) that don\'t support grabbing */\n    cursor: url("<<<PATH>>>/handclosed.cur"), auto;\n    cursor: grabbing;\n    cursor: -webkit-grabbing;\n  }\n\n  /* Change the cursor on the whole drag surface in case the mouse gets\n     ahead of block during a drag. This way the cursor is still a closed hand.\n    */\n  .blocklyBlockDragSurface .blocklyDraggable {\n    /* backup for browsers (e.g. IE11) that don\'t support grabbing */\n    cursor: url("<<<PATH>>>/handclosed.cur"), auto;\n    cursor: grabbing;\n    cursor: -webkit-grabbing;\n  }\n\n  .blocklyDragging.blocklyDraggingDelete {\n    cursor: url("<<<PATH>>>/handdelete.cur"), auto;\n  }\n\n  .blocklyDragging>.blocklyPath,\n  .blocklyDragging>.blocklyPathLight {\n    fill-opacity: .8;\n    stroke-opacity: .8;\n  }\n\n  .blocklyDragging>.blocklyPathDark {\n    display: none;\n  }\n\n  .blocklyDisabled>.blocklyPath {\n    fill-opacity: .5;\n    stroke-opacity: .5;\n  }\n\n  .blocklyDisabled>.blocklyPathLight,\n  .blocklyDisabled>.blocklyPathDark {\n    display: none;\n  }\n\n  .blocklyInsertionMarker>.blocklyPath,\n  .blocklyInsertionMarker>.blocklyPathLight,\n  .blocklyInsertionMarker>.blocklyPathDark {\n    fill-opacity: .2;\n    stroke: none;\n  }\n\n  .blocklyMultilineText {\n    font-family: monospace;\n  }\n\n  .blocklyNonEditableText>text {\n    pointer-events: none;\n  }\n\n  .blocklyFlyout {\n    position: absolute;\n    z-index: 20;\n  }\n\n  .blocklyText text {\n    cursor: default;\n  }\n\n  /*\n    Don\'t allow users to select text.  It gets annoying when trying to\n    drag a block and selected text moves instead.\n  */\n  .blocklySvg text,\n  .blocklyBlockDragSurface text {\n    user-select: none;\n    -ms-user-select: none;\n    -webkit-user-select: none;\n    cursor: inherit;\n  }\n\n  .blocklyHidden {\n    display: none;\n  }\n\n  .blocklyFieldDropdown:not(.blocklyHidden) {\n    display: block;\n  }\n\n  .blocklyIconGroup {\n    cursor: default;\n  }\n\n  .blocklyIconGroup:not(:hover),\n  .blocklyIconGroupReadonly {\n    opacity: .6;\n  }\n\n  .blocklyIconShape {\n    fill: #00f;\n    stroke: #fff;\n    stroke-width: 1px;\n  }\n\n  .blocklyIconSymbol {\n    fill: #fff;\n  }\n\n  .blocklyMinimalBody {\n    margin: 0;\n    padding: 0;\n  }\n\n  .blocklyHtmlInput {\n    border: none;\n    border-radius: 4px;\n    height: 100%;\n    margin: 0;\n    outline: none;\n    padding: 0;\n    width: 100%;\n    text-align: center;\n    display: block;\n    box-sizing: border-box;\n  }\n\n  /* Edge and IE introduce a close icon when the input value is longer than a\n     certain length. This affects our sizing calculations of the text input.\n     Hiding the close icon to avoid that. */\n  .blocklyHtmlInput::-ms-clear {\n    display: none;\n  }\n\n  .blocklyMainBackground {\n    stroke-width: 1;\n    stroke: #c6c6c6;  /* Equates to #ddd due to border being off-pixel. */\n  }\n\n  .blocklyMutatorBackground {\n    fill: #fff;\n    stroke: #ddd;\n    stroke-width: 1;\n  }\n\n  .blocklyFlyoutBackground {\n    fill: #ddd;\n    fill-opacity: .8;\n  }\n\n  .blocklyMainWorkspaceScrollbar {\n    z-index: 20;\n  }\n\n  .blocklyFlyoutScrollbar {\n    z-index: 30;\n  }\n\n  .blocklyScrollbarHorizontal,\n  .blocklyScrollbarVertical {\n    position: absolute;\n    outline: none;\n  }\n\n  .blocklyScrollbarBackground {\n    opacity: 0;\n  }\n\n  .blocklyScrollbarHandle {\n    fill: #ccc;\n  }\n\n  .blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,\n  .blocklyScrollbarHandle:hover {\n    fill: #bbb;\n  }\n\n  /* Darken flyout scrollbars due to being on a grey background. */\n  /* By contrast, workspace scrollbars are on a white background. */\n  .blocklyFlyout .blocklyScrollbarHandle {\n    fill: #bbb;\n  }\n\n  .blocklyFlyout .blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,\n  .blocklyFlyout .blocklyScrollbarHandle:hover {\n    fill: #aaa;\n  }\n\n  .blocklyInvalidInput {\n    background: #faa;\n  }\n\n  .blocklyVerticalMarker {\n    stroke-width: 3px;\n    fill: rgba(255,255,255,.5);\n    pointer-events: none;\n  }\n\n  .blocklyComputeCanvas {\n    position: absolute;\n    width: 0;\n    height: 0;\n  }\n\n  .blocklyNoPointerEvents {\n    pointer-events: none;\n  }\n\n  .blocklyContextMenu {\n    border-radius: 4px;\n    max-height: 100%;\n  }\n\n  .blocklyDropdownMenu {\n    border-radius: 2px;\n    padding: 0 !important;\n  }\n\n  .blocklyDropdownMenu .blocklyMenuItem {\n    /* 28px on the left for icon or checkbox. */\n    padding-left: 28px;\n  }\n\n  /* BiDi override for the resting state. */\n  .blocklyDropdownMenu .blocklyMenuItemRtl {\n    /* Flip left/right padding for BiDi. */\n    padding-left: 5px;\n    padding-right: 28px;\n  }\n\n  .blocklyWidgetDiv .blocklyMenu {\n    background: #fff;\n    border: 1px solid transparent;\n    box-shadow: 0 0 3px 1px rgba(0,0,0,.3);\n    font: normal 13px Arial, sans-serif;\n    margin: 0;\n    outline: none;\n    padding: 4px 0;\n    position: absolute;\n    overflow-y: auto;\n    overflow-x: hidden;\n    max-height: 100%;\n    z-index: 20000;  /* Arbitrary, but some apps depend on it... */\n  }\n\n  .blocklyWidgetDiv .blocklyMenu.blocklyFocused {\n    box-shadow: 0 0 6px 1px rgba(0,0,0,.3);\n  }\n\n  .blocklyDropDownDiv .blocklyMenu {\n    background: inherit;  /* Compatibility with gapi, reset from goog-menu */\n    border: inherit;  /* Compatibility with gapi, reset from goog-menu */\n    font: normal 13px "Helvetica Neue", Helvetica, sans-serif;\n    outline: none;\n    position: relative;  /* Compatibility with gapi, reset from goog-menu */\n    z-index: 20000;  /* Arbitrary, but some apps depend on it... */\n  }\n\n  /* State: resting. */\n  .blocklyMenuItem {\n    border: none;\n    color: #000;\n    cursor: pointer;\n    list-style: none;\n    margin: 0;\n    /* 7em on the right for shortcut. */\n    min-width: 7em;\n    padding: 6px 15px;\n    white-space: nowrap;\n  }\n\n  /* State: disabled. */\n  .blocklyMenuItemDisabled {\n    color: #ccc;\n    cursor: inherit;\n  }\n\n  /* State: hover. */\n  .blocklyMenuItemHighlight {\n    background-color: rgba(0,0,0,.1);\n  }\n\n  /* State: selected/checked. */\n  .blocklyMenuItemCheckbox {\n    height: 16px;\n    position: absolute;\n    width: 16px;\n  }\n\n  .blocklyMenuItemSelected .blocklyMenuItemCheckbox {\n    background: url(<<<PATH>>>/sprites.png) no-repeat -48px -16px;\n    float: left;\n    margin-left: -24px;\n    position: static;  /* Scroll with the menu. */\n  }\n\n  .blocklyMenuItemRtl .blocklyMenuItemCheckbox {\n    float: right;\n    margin-right: -24px;\n  }\n';
        e.module$exports$Blockly$utils$string = {
            startsWith: function(a, b) {
                return 0 === a.lastIndexOf(b, 0)
            },
            shortestStringLength: function(a) {
                return a.length ? a.reduce(function(b, c) {
                    return b.length < c.length ? b : c
                }).length : 0
            },
            commonWordPrefix: function(a, b) {
                if (!a.length)
                    return 0;
                if (1 === a.length)
                    return a[0].length;
                var c = 0;
                b = b || (0,
                e.module$exports$Blockly$utils$string.shortestStringLength)(a);
                var d;
                for (d = 0; d < b; d++) {
                    for (var f = a[0][d], g = 1; g < a.length; g++)
                        if (f !== a[g][d])
                            return c;
                    " " === f && (c = d + 1)
                }
                for (f = 1; f < a.length; f++)
                    if ((g = a[f][d]) && " " !== g)
                        return c;
                return b
            },
            commonWordSuffix: function(a, b) {
                if (!a.length)
                    return 0;
                if (1 === a.length)
                    return a[0].length;
                var c = 0;
                b = b || (0,
                e.module$exports$Blockly$utils$string.shortestStringLength)(a);
                var d;
                for (d = 0; d < b; d++) {
                    for (var f = a[0].substr(-d - 1, 1), g = 1; g < a.length; g++)
                        if (f !== a[g].substr(-d - 1, 1))
                            return c;
                    " " === f && (c = d + 1)
                }
                for (f = 1; f < a.length; f++)
                    if ((g = a[f].charAt(a[f].length - d - 1)) && " " !== g)
                        return c;
                return b
            },
            wrap: function(a, b) {
                a = a.split("\n");
                for (var c = 0; c < a.length; c++)
                    a[c] = P(a[c], b);
                return a.join("\n")
            }
        };
        var P = function(a, b) {
            if (a.length <= b)
                return a;
            for (var c = a.trim().split(/\s+/), d = 0; d < c.length; d++)
                c[d].length > b && (b = c[d].length);
            var f = -Infinity
              , g = 1;
            do {
                d = f;
                var m = a;
                a = [];
                f = c.length / g;
                for (var r = 1, B = 0; B < c.length - 1; B++)
                    r < (B + 1.5) / f ? (r++,
                    a[B] = !0) : a[B] = !1;
                a = Jb(c, a, b);
                f = xa(c, a, b);
                a = Bc(c, a);
                g++
            } while (f > d);
            return m
        };
        var xa = function(a, b, c) {
            for (var d = [0], f = [], g = 0; g < a.length; g++)
                d[d.length - 1] += a[g].length,
                !0 === b[g] ? (d.push(0),
                f.push(a[g].charAt(a[g].length - 1))) : !1 === b[g] && d[d.length - 1]++;
            a = Math.max.apply(Math, d);
            for (g = b = 0; g < d.length; g++)
                b -= 2 * Math.pow(Math.abs(c - d[g]), 1.5),
                b -= Math.pow(a - d[g], 1.5),
                -1 !== ".?!".indexOf(f[g]) ? b += c / 3 : -1 !== ",;)]}".indexOf(f[g]) && (b += c / 4);
            1 < d.length && d[d.length - 1] <= d[d.length - 2] && (b += .5);
            return b
        };
        var Jb = function(a, b, c) {
            for (var d = xa(a, b, c), f, g = 0; g < b.length - 1; g++)
                if (b[g] !== b[g + 1]) {
                    var m = [].concat(b);
                    m[g] = !m[g];
                    m[g + 1] = !m[g + 1];
                    var r = xa(a, m, c);
                    r > d && (d = r,
                    f = m)
                }
            return f ? Jb(a, f, c) : b
        };
        var Bc = function(a, b) {
            for (var c = [], d = 0; d < a.length; d++)
                c.push(a[d]),
                void 0 !== b[d] && c.push(b[d] ? "\n" : " ");
            return c.join("")
        };
        e.module$exports$Blockly$utils$string.isNumber = function(a) {
            return /^\s*-?\d+(\.\d+)?\s*$/.test(a)
        }
        ;
        e.module$exports$Blockly$ConnectionType = {
            ConnectionType: {
                INPUT_VALUE: 1,
                OUTPUT_VALUE: 2,
                NEXT_STATEMENT: 3,
                PREVIOUS_STATEMENT: 4
            }
        };
        e.module$exports$Blockly$internalConstants = {
            LINE_MODE_MULTIPLIER: 40,
            PAGE_MODE_MULTIPLIER: 125,
            DRAG_RADIUS: 5,
            FLYOUT_DRAG_RADIUS: 10,
            SNAP_RADIUS: 28
        };
        e.module$exports$Blockly$internalConstants.CONNECTING_SNAP_RADIUS = e.module$exports$Blockly$internalConstants.SNAP_RADIUS;
        e.module$exports$Blockly$internalConstants.CURRENT_CONNECTION_PREFERENCE = 8;
        e.module$exports$Blockly$internalConstants.BUMP_DELAY = 250;
        e.module$exports$Blockly$internalConstants.BUMP_RANDOMNESS = 10;
        e.module$exports$Blockly$internalConstants.COLLAPSE_CHARS = 30;
        e.module$exports$Blockly$internalConstants.LONGPRESS = 750;
        e.module$exports$Blockly$internalConstants.SOUND_LIMIT = 100;
        e.module$exports$Blockly$internalConstants.DRAG_STACK = !0;
        e.module$exports$Blockly$internalConstants.SPRITE = {
            width: 96,
            height: 124,
            url: "sprites.png"
        };
        e.module$exports$Blockly$internalConstants.DRAG_NONE = 0;
        e.module$exports$Blockly$internalConstants.DRAG_STICKY = 1;
        e.module$exports$Blockly$internalConstants.DRAG_BEGIN = 1;
        e.module$exports$Blockly$internalConstants.DRAG_FREE = 2;
        e.module$exports$Blockly$internalConstants.OPPOSITE_TYPE = [];
        e.module$exports$Blockly$internalConstants.OPPOSITE_TYPE[e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE] = e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE;
        e.module$exports$Blockly$internalConstants.OPPOSITE_TYPE[e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE] = e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE;
        e.module$exports$Blockly$internalConstants.OPPOSITE_TYPE[e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT] = e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT;
        e.module$exports$Blockly$internalConstants.OPPOSITE_TYPE[e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT] = e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT;
        e.module$exports$Blockly$internalConstants.RENAME_VARIABLE_ID = "RENAME_VARIABLE_ID";
        e.module$exports$Blockly$internalConstants.DELETE_VARIABLE_ID = "DELETE_VARIABLE_ID";
        e.module$exports$Blockly$utils$global = {};
        e.module$exports$Blockly$utils$global.globalThis = function() {
            return "object" === typeof globalThis ? globalThis : "object" === typeof self ? self : "object" === typeof window ? window : "object" === typeof global ? global : this
        }();
        var O = {};
        O.TOUCH_ENABLED = "ontouchstart"in e.module$exports$Blockly$utils$global.globalThis || !!(e.module$exports$Blockly$utils$global.globalThis.document && document.documentElement && "ontouchstart"in document.documentElement) || !(!e.module$exports$Blockly$utils$global.globalThis.navigator || !e.module$exports$Blockly$utils$global.globalThis.navigator.maxTouchPoints && !e.module$exports$Blockly$utils$global.globalThis.navigator.msMaxTouchPoints);
        var ab = null;
        O.TOUCH_MAP = {};
        e.module$exports$Blockly$utils$global.globalThis.PointerEvent ? O.TOUCH_MAP = {
            mousedown: ["pointerdown"],
            mouseenter: ["pointerenter"],
            mouseleave: ["pointerleave"],
            mousemove: ["pointermove"],
            mouseout: ["pointerout"],
            mouseover: ["pointerover"],
            mouseup: ["pointerup", "pointercancel"],
            touchend: ["pointerup"],
            touchcancel: ["pointercancel"]
        } : O.TOUCH_ENABLED && (O.TOUCH_MAP = {
            mousedown: ["touchstart"],
            mousemove: ["touchmove"],
            mouseup: ["touchend", "touchcancel"]
        });
        var sb = 0;
        O.longStart = function(a, b) {
            (0,
            O.longStop)();
            a.changedTouches && 1 !== a.changedTouches.length || (sb = setTimeout(function() {
                a.changedTouches && (a.button = 2,
                a.clientX = a.changedTouches[0].clientX,
                a.clientY = a.changedTouches[0].clientY);
                b && b.handleRightClick(a)
            }, e.module$exports$Blockly$internalConstants.LONGPRESS))
        }
        ;
        O.longStop = function() {
            sb && (clearTimeout(sb),
            sb = 0)
        }
        ;
        O.clearTouchIdentifier = function() {
            ab = null
        }
        ;
        O.shouldHandleEvent = function(a) {
            return !(0,
            O.isMouseOrTouchEvent)(a) || (0,
            O.checkTouchIdentifier)(a)
        }
        ;
        O.getTouchIdentifierFromEvent = function(a) {
            return void 0 !== a.pointerId ? a.pointerId : a.changedTouches && a.changedTouches[0] && void 0 !== a.changedTouches[0].identifier && null !== a.changedTouches[0].identifier ? a.changedTouches[0].identifier : "mouse"
        }
        ;
        O.checkTouchIdentifier = function(a) {
            var b = (0,
            O.getTouchIdentifierFromEvent)(a);
            return void 0 !== ab && null !== ab ? ab === b : "mousedown" === a.type || "touchstart" === a.type || "pointerdown" === a.type ? (ab = b,
            !0) : !1
        }
        ;
        O.setClientFromTouch = function(a) {
            if ((0,
            e.module$exports$Blockly$utils$string.startsWith)(a.type, "touch")) {
                var b = a.changedTouches[0];
                a.clientX = b.clientX;
                a.clientY = b.clientY
            }
        }
        ;
        O.isMouseOrTouchEvent = function(a) {
            return (0,
            e.module$exports$Blockly$utils$string.startsWith)(a.type, "touch") || (0,
            e.module$exports$Blockly$utils$string.startsWith)(a.type, "mouse") || (0,
            e.module$exports$Blockly$utils$string.startsWith)(a.type, "pointer")
        }
        ;
        O.isTouchEvent = function(a) {
            return (0,
            e.module$exports$Blockly$utils$string.startsWith)(a.type, "touch") || (0,
            e.module$exports$Blockly$utils$string.startsWith)(a.type, "pointer")
        }
        ;
        O.splitEventByTouches = function(a) {
            var b = [];
            if (a.changedTouches)
                for (var c = 0; c < a.changedTouches.length; c++)
                    b[c] = {
                        type: a.type,
                        changedTouches: [a.changedTouches[c]],
                        target: a.target,
                        stopPropagation: function() {
                            a.stopPropagation()
                        },
                        preventDefault: function() {
                            a.preventDefault()
                        }
                    };
            else
                b.push(a);
            return b
        }
        ;
        var V = {};
        (function(a) {
            function b(d) {
                return -1 !== c.indexOf(d.toUpperCase())
            }
            V.raw = a;
            var c = V.raw.toUpperCase();
            V.IE = b("Trident") || b("MSIE");
            V.EDGE = b("Edge");
            V.JavaFx = b("JavaFX");
            V.CHROME = (b("Chrome") || b("CriOS")) && !V.EDGE;
            V.WEBKIT = b("WebKit") && !V.EDGE;
            V.GECKO = b("Gecko") && !V.WEBKIT && !V.IE && !V.EDGE;
            V.ANDROID = b("Android");
            a = e.module$exports$Blockly$utils$global.globalThis.navigator && e.module$exports$Blockly$utils$global.globalThis.navigator.maxTouchPoints;
            V.IPAD = b("iPad") || b("Macintosh") && 0 < a;
            V.IPOD = b("iPod");
            V.IPHONE = b("iPhone") && !V.IPAD && !V.IPOD;
            V.MAC = b("Macintosh");
            V.TABLET = V.IPAD || V.ANDROID && !b("Mobile") || b("Silk");
            V.MOBILE = !V.TABLET && (V.IPOD || V.IPHONE || V.ANDROID || b("IEMobile"))
        }
        )(e.module$exports$Blockly$utils$global.globalThis.navigator && e.module$exports$Blockly$utils$global.globalThis.navigator.userAgent || "");
        var y = {
            conditionalBind: function(a, b, c, d, f, g) {
                var m = !1
                  , r = function(Fa) {
                    var Wa = !f;
                    Fa = (0,
                    O.splitEventByTouches)(Fa);
                    for (var Ga = 0; Ga < Fa.length; Ga++) {
                        var Cc = Fa[Ga];
                        if (!Wa || (0,
                        O.shouldHandleEvent)(Cc))
                            (0,
                            O.setClientFromTouch)(Cc),
                            c ? d.call(c, Cc) : d(Cc),
                            m = !0
                    }
                }
                  , B = [];
                if (e.module$exports$Blockly$utils$global.globalThis.PointerEvent && b in O.TOUCH_MAP)
                    for (var G = 0; G < O.TOUCH_MAP[b].length; G++) {
                        var W = O.TOUCH_MAP[b][G];
                        a.addEventListener(W, r, !1);
                        B.push([a, W, r])
                    }
                else if (a.addEventListener(b, r, !1),
                B.push([a, b, r]),
                b in O.TOUCH_MAP)
                    for (G = function(Fa) {
                        r(Fa);
                        var Wa = !g;
                        m && Wa && Fa.preventDefault()
                    }
                    ,
                    W = 0; W < O.TOUCH_MAP[b].length; W++) {
                        var ra = O.TOUCH_MAP[b][W];
                        a.addEventListener(ra, G, !1);
                        B.push([a, ra, G])
                    }
                return B
            },
            bind: function(a, b, c, d) {
                var f = function(G) {
                    c ? d.call(c, G) : d(G)
                }
                  , g = [];
                if (e.module$exports$Blockly$utils$global.globalThis.PointerEvent && b in O.TOUCH_MAP)
                    for (var m = 0; m < O.TOUCH_MAP[b].length; m++) {
                        var r = O.TOUCH_MAP[b][m];
                        a.addEventListener(r, f, !1);
                        g.push([a, r, f])
                    }
                else if (a.addEventListener(b, f, !1),
                g.push([a, b, f]),
                b in O.TOUCH_MAP)
                    for (m = function(G) {
                        if (G.changedTouches && 1 === G.changedTouches.length) {
                            var W = G.changedTouches[0];
                            G.clientX = W.clientX;
                            G.clientY = W.clientY
                        }
                        f(G);
                        G.preventDefault()
                    }
                    ,
                    r = 0; r < O.TOUCH_MAP[b].length; r++) {
                        var B = O.TOUCH_MAP[b][r];
                        a.addEventListener(B, m, !1);
                        g.push([a, B, m])
                    }
                return g
            },
            unbind: function(a) {
                for (var b; a.length; ) {
                    b = a.pop();
                    var c = b[0]
                      , d = b[1];
                    b = b[2];
                    c.removeEventListener(d, b, !1)
                }
                return b
            },
            isTargetInput: function(a) {
                return "textarea" === a.target.type || "text" === a.target.type || "number" === a.target.type || "email" === a.target.type || "password" === a.target.type || "search" === a.target.type || "tel" === a.target.type || "url" === a.target.type || a.target.isContentEditable || a.target.dataset && "true" === a.target.dataset.isTextInput
            },
            isRightButton: function(a) {
                return a.ctrlKey && V.MAC ? !0 : 2 === a.button
            },
            mouseToSvg: function(a, b, c) {
                var d = b.createSVGPoint();
                d.x = a.clientX;
                d.y = a.clientY;
                c || (c = b.getScreenCTM().inverse());
                return d.matrixTransform(c)
            },
            getScrollDeltaPixels: function(a) {
                switch (a.deltaMode) {
                default:
                    return {
                        x: a.deltaX,
                        y: a.deltaY
                    };
                case 1:
                    return {
                        x: a.deltaX * e.module$exports$Blockly$internalConstants.LINE_MODE_MULTIPLIER,
                        y: a.deltaY * e.module$exports$Blockly$internalConstants.LINE_MODE_MULTIPLIER
                    };
                case 2:
                    return {
                        x: a.deltaX * e.module$exports$Blockly$internalConstants.PAGE_MODE_MULTIPLIER,
                        y: a.deltaY * e.module$exports$Blockly$internalConstants.PAGE_MODE_MULTIPLIER
                    }
                }
            }
        };
        e.module$exports$Blockly$blocks = {};
        e.module$exports$Blockly$blocks.Blocks = Object.create(null);
        var he;
        e.module$exports$Blockly$common = {};
        e.module$exports$Blockly$common.getMainWorkspace = function() {
            return he
        }
        ;
        e.module$exports$Blockly$common.setMainWorkspace = function(a) {
            he = a
        }
        ;
        var ie = null;
        e.module$exports$Blockly$common.getSelected = function() {
            return ie
        }
        ;
        e.module$exports$Blockly$common.setSelected = function(a) {
            ie = a
        }
        ;
        var je;
        e.module$exports$Blockly$common.getParentContainer = function() {
            return je
        }
        ;
        e.module$exports$Blockly$common.setParentContainer = function(a) {
            je = a
        }
        ;
        e.module$exports$Blockly$common.svgResize = function(a) {
            for (; a.options.parentWorkspace; )
                a = a.options.parentWorkspace;
            var b = a.getParentSvg()
              , c = a.getCachedParentSvgSize()
              , d = b.parentNode;
            if (d) {
                var f = d.offsetWidth;
                d = d.offsetHeight;
                c.width !== f && (b.setAttribute("width", f + "px"),
                a.setCachedParentSvgSize(f, null));
                c.height !== d && (b.setAttribute("height", d + "px"),
                a.setCachedParentSvgSize(null, d));
                a.resize()
            }
        }
        ;
        e.module$exports$Blockly$common.draggingConnections = [];
        e.module$exports$Blockly$common.getBlockTypeCounts = function(a, b) {
            var c = Object.create(null)
              , d = a.getDescendants(!0);
            b && (a = a.getNextBlock()) && (a = d.indexOf(a),
            d.splice(a, d.length - a));
            for (a = 0; b = d[a]; a++)
                c[b.type] ? c[b.type]++ : c[b.type] = 1;
            return c
        }
        ;
        var Ue = function(a) {
            return function() {
                this.jsonInit(a)
            }
        };
        e.module$exports$Blockly$common.defineBlocksWithJsonArray = function(a) {
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                if (c) {
                    var d = c.type;
                    d ? (e.module$exports$Blockly$blocks.Blocks[d] && console.warn("Block definition #" + b + ' in JSON array overwrites prior definition of "' + d + '".'),
                    e.module$exports$Blockly$blocks.Blocks[d] = {
                        init: Ue(c)
                    }) : console.warn("Block definition #" + b + " in JSON array is missing a type attribute. Skipping.")
                } else
                    console.warn("Block definition #" + b + " in JSON array is " + c + ". Skipping.")
            }
        }
        ;
        var aa = {}
          , ad = !1;
        aa.isVisible = function() {
            return ad
        }
        ;
        Object.defineProperties(aa, {
            visible: {
                get: function() {
                    (0,
                    q.warn)("Blockly.Tooltip.visible", "September 2021", "September 2022", "Blockly.Tooltip.isVisible()");
                    return (0,
                    aa.isVisible)()
                }
            }
        });
        var Tc = !1;
        aa.LIMIT = 50;
        var ke = 0
          , bd = 0
          , Rd = 0
          , Sd = 0
          , Wb = null
          , cd = null;
        aa.OFFSET_X = 0;
        aa.OFFSET_Y = 10;
        aa.RADIUS_OK = 10;
        aa.HOVER_MS = 750;
        aa.MARGINS = 5;
        var Xa = null;
        aa.getDiv = function() {
            return Xa
        }
        ;
        Object.defineProperties(aa, {
            DIV: {
                get: function() {
                    (0,
                    q.warn)("Blockly.Tooltip.DIV", "September 2021", "September 2022", "Blockly.Tooltip.getDiv()");
                    return (0,
                    aa.getDiv)()
                }
            }
        });
        aa.getTooltipOfObject = function(a) {
            if (a = le(a)) {
                for (a = a.tooltip; "function" === typeof a; )
                    a = a();
                if ("string" !== typeof a)
                    throw Error("Tooltip function must return a string.");
                return a
            }
            return ""
        }
        ;
        var le = function(a) {
            for (; a && a.tooltip; ) {
                if ("string" === typeof a.tooltip || "function" === typeof a.tooltip)
                    return a;
                a = a.tooltip
            }
            return null
        };
        aa.createDom = function() {
            Xa || (Xa = document.createElement("div"),
            Xa.className = "blocklyTooltipDiv",
            ((0,
            e.module$exports$Blockly$common.getParentContainer)() || document.body).appendChild(Xa))
        }
        ;
        aa.bindMouseEvents = function(a) {
            a.mouseOverWrapper_ = (0,
            y.bind)(a, "mouseover", null, Ve);
            a.mouseOutWrapper_ = (0,
            y.bind)(a, "mouseout", null, We);
            a.addEventListener("mousemove", me, !1)
        }
        ;
        aa.unbindMouseEvents = function(a) {
            a && ((0,
            y.unbind)(a.mouseOverWrapper_),
            (0,
            y.unbind)(a.mouseOutWrapper_),
            a.removeEventListener("mousemove", me))
        }
        ;
        var Ve = function(a) {
            Tc || (a = le(a.currentTarget),
            Wb !== a && ((0,
            aa.hide)(),
            cd = null,
            Wb = a),
            clearTimeout(ke))
        }
          , We = function(a) {
            Tc || (ke = setTimeout(function() {
                cd = Wb = null;
                (0,
                aa.hide)()
            }, 1),
            clearTimeout(bd))
        }
          , me = function(a) {
            if (Wb && Wb.tooltip && !Tc)
                if (ad) {
                    var b = Rd - a.pageX;
                    a = Sd - a.pageY;
                    Math.sqrt(b * b + a * a) > aa.RADIUS_OK && (0,
                    aa.hide)()
                } else
                    cd !== Wb && (clearTimeout(bd),
                    Rd = a.pageX,
                    Sd = a.pageY,
                    bd = setTimeout(Xe, aa.HOVER_MS))
        };
        aa.dispose = function() {
            cd = Wb = null;
            (0,
            aa.hide)()
        }
        ;
        aa.hide = function() {
            ad && (ad = !1,
            Xa && (Xa.style.display = "none"));
            bd && clearTimeout(bd)
        }
        ;
        aa.block = function() {
            (0,
            aa.hide)();
            Tc = !0
        }
        ;
        aa.unblock = function() {
            Tc = !1
        }
        ;
        var Xe = function() {
            if (!Tc && (cd = Wb,
            Xa)) {
                Xa.textContent = "";
                var a = (0,
                aa.getTooltipOfObject)(Wb);
                a = (0,
                e.module$exports$Blockly$utils$string.wrap)(a, aa.LIMIT);
                a = a.split("\n");
                for (var b = 0; b < a.length; b++) {
                    var c = document.createElement("div");
                    c.appendChild(document.createTextNode(a[b]));
                    Xa.appendChild(c)
                }
                a = Wb.RTL;
                b = document.documentElement.clientWidth;
                c = document.documentElement.clientHeight;
                Xa.style.direction = a ? "rtl" : "ltr";
                Xa.style.display = "block";
                ad = !0;
                var d = Rd;
                d = a ? d - (aa.OFFSET_X + Xa.offsetWidth) : d + aa.OFFSET_X;
                var f = Sd + aa.OFFSET_Y;
                f + Xa.offsetHeight > c + window.scrollY && (f -= Xa.offsetHeight + 2 * aa.OFFSET_Y);
                a ? d = Math.max(aa.MARGINS - window.scrollX, d) : d + Xa.offsetWidth > b + window.scrollX - 2 * aa.MARGINS && (d = b - Xa.offsetWidth - 2 * aa.MARGINS);
                Xa.style.top = f + "px";
                Xa.style.left = d + "px"
            }
        }
          , n = {
            SVG_NS: "http://www.w3.org/2000/svg",
            HTML_NS: "http://www.w3.org/1999/xhtml",
            XLINK_NS: "http://www.w3.org/1999/xlink",
            NodeType: {
                ELEMENT_NODE: 1,
                TEXT_NODE: 3,
                COMMENT_NODE: 8,
                DOCUMENT_POSITION_CONTAINED_BY: 16
            }
        }
          , Kb = null
          , Td = 0
          , pd = null;
        n.createSvgElement = function(a, b, c) {
            a = document.createElementNS(n.SVG_NS, String(a));
            for (var d in b)
                a.setAttribute(d, b[d]);
            document.body.runtimeStyle && (a.runtimeStyle = a.currentStyle = a.style);
            c && c.appendChild(a);
            return a
        }
        ;
        n.addClass = function(a, b) {
            var c = a.getAttribute("class") || "";
            if (-1 !== (" " + c + " ").indexOf(" " + b + " "))
                return !1;
            c && (c += " ");
            a.setAttribute("class", c + b);
            return !0
        }
        ;
        n.removeClasses = function(a, b) {
            b = b.split(" ");
            for (var c = 0; c < b.length; c++)
                (0,
                n.removeClass)(a, b[c])
        }
        ;
        n.removeClass = function(a, b) {
            var c = a.getAttribute("class");
            if (-1 === (" " + c + " ").indexOf(" " + b + " "))
                return !1;
            c = c.split(/\s+/);
            for (var d = 0; d < c.length; d++)
                c[d] && c[d] !== b || (c.splice(d, 1),
                d--);
            c.length ? a.setAttribute("class", c.join(" ")) : a.removeAttribute("class");
            return !0
        }
        ;
        n.hasClass = function(a, b) {
            return -1 !== (" " + a.getAttribute("class") + " ").indexOf(" " + b + " ")
        }
        ;
        n.removeNode = function(a) {
            return a && a.parentNode ? a.parentNode.removeChild(a) : null
        }
        ;
        n.insertAfter = function(a, b) {
            var c = b.nextSibling;
            b = b.parentNode;
            if (!b)
                throw Error("Reference node has no parent.");
            c ? b.insertBefore(a, c) : b.appendChild(a)
        }
        ;
        n.containsNode = function(a, b) {
            return !!(a.compareDocumentPosition(b) & n.NodeType.DOCUMENT_POSITION_CONTAINED_BY)
        }
        ;
        n.setCssTransform = function(a, b) {
            a.style.transform = b;
            a.style["-webkit-transform"] = b
        }
        ;
        n.startTextWidthCache = function() {
            Td++;
            Kb || (Kb = Object.create(null))
        }
        ;
        n.stopTextWidthCache = function() {
            Td--;
            Td || (Kb = null)
        }
        ;
        n.getTextWidth = function(a) {
            var b = a.textContent + "\n" + a.className.baseVal, c;
            if (Kb && (c = Kb[b]))
                return c;
            try {
                c = V.IE || V.EDGE ? a.getBBox().width : a.getComputedTextLength()
            } catch (d) {
                return 8 * a.textContent.length
            }
            Kb && (Kb[b] = c);
            return c
        }
        ;
        n.getFastTextWidth = function(a, b, c, d) {
            return (0,
            n.getFastTextWidthWithSizeString)(a, b + "pt", c, d)
        }
        ;
        n.getFastTextWidthWithSizeString = function(a, b, c, d) {
            var f = a.textContent;
            a = f + "\n" + a.className.baseVal;
            var g;
            if (Kb && (g = Kb[a]))
                return g;
            pd || (g = document.createElement("canvas"),
            g.className = "blocklyComputeCanvas",
            document.body.appendChild(g),
            pd = g.getContext("2d"));
            pd.font = c + " " + b + " " + d;
            g = pd.measureText(f).width;
            Kb && (Kb[a] = g);
            return g
        }
        ;
        n.measureFontMetrics = function(a, b, c, d) {
            var f = document.createElement("span");
            f.style.font = c + " " + b + " " + d;
            f.textContent = a;
            a = document.createElement("div");
            a.style.width = "1px";
            a.style.height = 0;
            b = document.createElement("div");
            b.setAttribute("style", "position: fixed; top: 0; left: 0; display: flex;");
            b.appendChild(f);
            b.appendChild(a);
            document.body.appendChild(b);
            c = {
                height: 0,
                baseline: 0
            };
            try {
                b.style.alignItems = "baseline",
                c.baseline = a.offsetTop - f.offsetTop,
                b.style.alignItems = "flex-end",
                c.height = a.offsetTop - f.offsetTop
            } finally {
                document.body.removeChild(b)
            }
            return c
        }
        ;
        var sa = {}, qd = null, rd = null, dd = "", ed = "", Lb;
        sa.getDiv = function() {
            return Lb
        }
        ;
        sa.testOnly_setDiv = function(a) {
            Lb = a
        }
        ;
        Object.defineProperties(sa, {
            DIV: {
                get: function() {
                    (0,
                    q.warn)("Blockly.WidgetDiv.DIV", "September 2021", "September 2022", "Blockly.WidgetDiv.getDiv()");
                    return (0,
                    sa.getDiv)()
                }
            }
        });
        sa.createDom = function() {
            Lb || (Lb = document.createElement("div"),
            Lb.className = "blocklyWidgetDiv",
            ((0,
            e.module$exports$Blockly$common.getParentContainer)() || document.body).appendChild(Lb))
        }
        ;
        sa.show = function(a, b, c) {
            (0,
            sa.hide)();
            qd = a;
            rd = c;
            a = Lb;
            a.style.direction = b ? "rtl" : "ltr";
            a.style.display = "block";
            b = (0,
            e.module$exports$Blockly$common.getMainWorkspace)();
            dd = b.getRenderer().getClassName();
            ed = b.getTheme().getClassName();
            (0,
            n.addClass)(a, dd);
            (0,
            n.addClass)(a, ed)
        }
        ;
        sa.hide = function() {
            if ((0,
            sa.isVisible)()) {
                qd = null;
                var a = Lb;
                a.style.display = "none";
                a.style.left = "";
                a.style.top = "";
                rd && rd();
                rd = null;
                a.textContent = "";
                dd && ((0,
                n.removeClass)(a, dd),
                dd = "");
                ed && ((0,
                n.removeClass)(a, ed),
                ed = "");
                (0,
                e.module$exports$Blockly$common.getMainWorkspace)().markFocused()
            }
        }
        ;
        sa.isVisible = function() {
            return !!qd
        }
        ;
        sa.hideIfOwner = function(a) {
            qd === a && (0,
            sa.hide)()
        }
        ;
        var ne = function(a, b, c) {
            Lb.style.left = a + "px";
            Lb.style.top = b + "px";
            Lb.style.height = c + "px"
        };
        sa.positionWithAnchor = function(a, b, c, d) {
            var f = b.bottom + c.height >= a.bottom ? b.top - c.height : b.bottom;
            a = d ? Math.min(Math.max(b.right - c.width, a.left), a.right - c.width) : Math.max(Math.min(b.left, a.right - c.width), a.left);
            0 > f ? ne(a, 0, c.height + f) : ne(a, f, c.height)
        }
        ;
        var Q = {
            Role: {
                GRID: "grid",
                GRIDCELL: "gridcell",
                GROUP: "group",
                LISTBOX: "listbox",
                MENU: "menu",
                MENUITEM: "menuitem",
                MENUITEMCHECKBOX: "menuitemcheckbox",
                OPTION: "option",
                PRESENTATION: "presentation",
                ROW: "row",
                TREE: "tree",
                TREEITEM: "treeitem"
            },
            State: {
                ACTIVEDESCENDANT: "activedescendant",
                COLCOUNT: "colcount",
                DISABLED: "disabled",
                EXPANDED: "expanded",
                INVALID: "invalid",
                LABEL: "label",
                LABELLEDBY: "labelledby",
                LEVEL: "level",
                ORIENTATION: "orientation",
                POSINSET: "posinset",
                ROWCOUNT: "rowcount",
                SELECTED: "selected",
                SETSIZE: "setsize",
                VALUEMAX: "valuemax",
                VALUEMIN: "valuemin"
            },
            setRole: function(a, b) {
                a.setAttribute("role", b)
            },
            setState: function(a, b, c) {
                Array.isArray(c) && (c = c.join(" "));
                a.setAttribute("aria-" + b, c)
            }
        }
          , bb = {
            TEST_ONLY: {}
        }
          , Ye = 0;
        bb.getNextUniqueId = function() {
            return "blockly-" + (Ye++).toString(36)
        }
        ;
        bb.TEST_ONLY.genUid = function() {
            for (var a = [], b = 0; 20 > b; b++)
                a[b] = "!#$%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(88 * Math.random());
            return a.join("")
        }
        ;
        bb.genUid = function() {
            return bb.TEST_ONLY.genUid()
        }
        ;
        var w = {}
          , Dc = Object.create(null);
        w.TEST_ONLY = {
            typeMap: Dc
        };
        var sd = Object.create(null);
        w.DEFAULT = "default";
        w.Type = function(a) {
            this.name_ = a
        }
        ;
        w.Type.prototype.toString = function() {
            return this.name_
        }
        ;
        w.Type.CONNECTION_CHECKER = new w.Type("connectionChecker");
        w.Type.CURSOR = new w.Type("cursor");
        w.Type.EVENT = new w.Type("event");
        w.Type.FIELD = new w.Type("field");
        w.Type.RENDERER = new w.Type("renderer");
        w.Type.TOOLBOX = new w.Type("toolbox");
        w.Type.THEME = new w.Type("theme");
        w.Type.TOOLBOX_ITEM = new w.Type("toolboxItem");
        w.Type.FLYOUTS_VERTICAL_TOOLBOX = new w.Type("flyoutsVerticalToolbox");
        w.Type.FLYOUTS_HORIZONTAL_TOOLBOX = new w.Type("flyoutsHorizontalToolbox");
        w.Type.METRICS_MANAGER = new w.Type("metricsManager");
        w.Type.BLOCK_DRAGGER = new w.Type("blockDragger");
        w.Type.SERIALIZER = new w.Type("serializer");
        w.register = function(a, b, c, d) {
            if (!(a instanceof w.Type) && "string" !== typeof a || "" === String(a).trim())
                throw Error('Invalid type "' + a + '". The type must be a non-empty string or a Blockly.registry.Type.');
            a = String(a).toLowerCase();
            if ("string" !== typeof b || "" === b.trim())
                throw Error('Invalid name "' + b + '". The name must be a non-empty string.');
            var f = b.toLowerCase();
            if (!c)
                throw Error("Can not register a null value");
            var g = Dc[a]
              , m = sd[a];
            g || (g = Dc[a] = Object.create(null),
            m = sd[a] = Object.create(null));
            switch (a) {
            case String(w.Type.FIELD):
                if ("function" !== typeof c.fromJson)
                    throw Error('Type "' + a + '" must have a fromJson function');
            }
            if (!d && g[f])
                throw Error('Name "' + f + '" with type "' + a + '" already registered.');
            g[f] = c;
            m[f] = b
        }
        ;
        w.unregister = function(a, b) {
            a = String(a).toLowerCase();
            b = b.toLowerCase();
            var c = Dc[a];
            c && c[b] ? (delete Dc[a][b],
            delete sd[a][b]) : console.warn("Unable to unregister [" + b + "][" + a + "] from the registry.")
        }
        ;
        var oe = function(a, b, c) {
            a = String(a).toLowerCase();
            b = b.toLowerCase();
            var d = Dc[a];
            if (!d || !d[b]) {
                b = "Unable to find [" + b + "][" + a + "] in the registry.";
                if (c)
                    throw Error(b + " You must require or register a " + a + " plugin.");
                console.warn(b);
                return null
            }
            return d[b]
        };
        w.hasItem = function(a, b) {
            a = String(a).toLowerCase();
            b = b.toLowerCase();
            return (a = Dc[a]) ? !!a[b] : !1
        }
        ;
        w.getClass = function(a, b, c) {
            return oe(a, b, c)
        }
        ;
        w.getObject = function(a, b, c) {
            return oe(a, b, c)
        }
        ;
        w.getAllItems = function(a, b, c) {
            a = String(a).toLowerCase();
            var d = Dc[a];
            if (!d) {
                d = "Unable to find [" + a + "] in the registry.";
                if (c)
                    throw Error(d + " You must require or register a " + a + " plugin.");
                console.warn(d);
                return null
            }
            if (!b)
                return d;
            a = sd[a];
            c = Object.create(null);
            b = Object.keys(d);
            for (var f = 0; f < b.length; f++) {
                var g = b[f];
                c[a[g]] = d[g]
            }
            return c
        }
        ;
        w.getClassFromOptions = function(a, b, c) {
            b = b.plugins[a.toString()] || w.DEFAULT;
            return "function" === typeof b ? b : (0,
            w.getClass)(a, b, c)
        }
        ;
        var k = {}
          , pe = ""
          , fd = !0;
        k.setRecordUndo = function(a) {
            fd = a
        }
        ;
        k.getRecordUndo = function() {
            return fd
        }
        ;
        var Ud = 0;
        k.CREATE = "create";
        k.BLOCK_CREATE = k.CREATE;
        k.DELETE = "delete";
        k.BLOCK_DELETE = k.DELETE;
        k.CHANGE = "change";
        k.BLOCK_CHANGE = k.CHANGE;
        k.MOVE = "move";
        k.BLOCK_MOVE = k.MOVE;
        k.VAR_CREATE = "var_create";
        k.VAR_DELETE = "var_delete";
        k.VAR_RENAME = "var_rename";
        k.UI = "ui";
        k.BLOCK_DRAG = "drag";
        k.SELECTED = "selected";
        k.CLICK = "click";
        k.MARKER_MOVE = "marker_move";
        k.BUBBLE_OPEN = "bubble_open";
        k.TRASHCAN_OPEN = "trashcan_open";
        k.TOOLBOX_ITEM_SELECT = "toolbox_item_select";
        k.THEME_CHANGE = "theme_change";
        k.VIEWPORT_CHANGE = "viewport_change";
        k.COMMENT_CREATE = "comment_create";
        k.COMMENT_DELETE = "comment_delete";
        k.COMMENT_CHANGE = "comment_change";
        k.COMMENT_MOVE = "comment_move";
        k.FINISHED_LOADING = "finished_loading";
        k.BUMP_EVENTS = [k.CREATE, k.MOVE, k.COMMENT_CREATE, k.COMMENT_MOVE];
        var Uc = [];
        k.fire = function(a) {
            (0,
            k.isEnabled)() && (Uc.length || setTimeout(qe, 0),
            Uc.push(a))
        }
        ;
        var qe = function() {
            for (var a = (0,
            k.filter)(Uc, !0), b = Uc.length = 0, c; c = a[b]; b++)
                if (c.workspaceId) {
                    var d = N.Workspace.getById(c.workspaceId);
                    d && d.fireChangeListener(c)
                }
        };
        k.filter = function(a, b) {
            a = a.slice();
            b || a.reverse();
            for (var c = [], d = Object.create(null), f = 0, g = void 0; g = a[f]; f++)
                if (!g.isNull()) {
                    var m = [g.isUiEvent ? k.UI : g.type, g.blockId, g.workspaceId].join(" ")
                      , r = d[m]
                      , B = r ? r.event : null;
                    if (!r)
                        d[m] = {
                            event: g,
                            index: f
                        },
                        c.push(g);
                    else if (g.type === k.MOVE && r.index === f - 1)
                        B.newParentId = g.newParentId,
                        B.newInputName = g.newInputName,
                        B.newCoordinate = g.newCoordinate,
                        r.index = f;
                    else if (g.type === k.CHANGE && g.element === B.element && g.name === B.name)
                        B.newValue = g.newValue;
                    else if (g.type === k.VIEWPORT_CHANGE)
                        B.viewTop = g.viewTop,
                        B.viewLeft = g.viewLeft,
                        B.scale = g.scale,
                        B.oldScale = g.oldScale;
                    else if (g.type !== k.CLICK || B.type !== k.BUBBLE_OPEN)
                        d[m] = {
                            event: g,
                            index: f
                        },
                        c.push(g)
                }
            a = c.filter(function(G) {
                return !G.isNull()
            });
            b || a.reverse();
            b = 1;
            for (c = void 0; c = a[b]; b++)
                c.type === k.CHANGE && "mutation" === c.element && a.unshift(a.splice(b, 1)[0]);
            return a
        }
        ;
        k.clearPendingUndo = function() {
            for (var a = 0, b; b = Uc[a]; a++)
                b.recordUndo = !1
        }
        ;
        k.disable = function() {
            Ud++
        }
        ;
        k.enable = function() {
            Ud--
        }
        ;
        k.isEnabled = function() {
            return 0 === Ud
        }
        ;
        k.getGroup = function() {
            return pe
        }
        ;
        k.setGroup = function(a) {
            pe = "boolean" === typeof a ? a ? (0,
            bb.genUid)() : "" : a
        }
        ;
        k.getDescendantIds = function(a) {
            var b = [];
            a = a.getDescendants(!1);
            for (var c = 0, d; d = a[c]; c++)
                b[c] = d.id;
            return b
        }
        ;
        k.fromJson = function(a, b) {
            var c = (0,
            k.get)(a.type);
            if (!c)
                throw Error("Unknown event type.");
            c = new c;
            c.fromJson(a);
            c.workspaceId = b.id;
            return c
        }
        ;
        k.get = function(a) {
            return (0,
            w.getClass)(w.Type.EVENT, a)
        }
        ;
        k.disableOrphans = function(a) {
            if ((a.type === k.MOVE || a.type === k.CREATE) && a.workspaceId) {
                var b = N.Workspace.getById(a.workspaceId)
                  , c = b.getBlockById(a.blockId);
                if (c) {
                    a = fd;
                    try {
                        fd = !1;
                        var d = c.getParent();
                        if (d && d.isEnabled()) {
                            var f = c.getDescendants(!1);
                            b = 0;
                            for (d = void 0; d = f[b]; b++)
                                d.setEnabled(!0)
                        } else if ((c.outputConnection || c.previousConnection) && !b.isDragging()) {
                            do
                                c.setEnabled(!1),
                                c = c.getNextBlock();
                            while (c)
                        }
                    } finally {
                        fd = a
                    }
                }
            }
        }
        ;
        k.TEST_ONLY = {
            FIRE_QUEUE: Uc,
            fireNow: qe
        };
        var Eb = {
            toRadians: function(a) {
                return a * Math.PI / 180
            },
            toDegrees: function(a) {
                return 180 * a / Math.PI
            },
            clamp: function(a, b, c) {
                if (c < a) {
                    var d = c;
                    c = a;
                    a = d
                }
                return Math.max(a, Math.min(b, c))
            }
        }
          , Fc = {
            bumpIntoBounds: function(a, b, c) {
                var d = c.getBoundingRectangle()
                  , f = d.right - d.left
                  , g = (0,
                Eb.clamp)(b.top, d.top, b.top + b.height - (d.bottom - d.top)) - d.top
                  , m = b.left;
                b = b.left + b.width - f;
                a.RTL ? m = Math.min(b, m) : b = Math.max(m, b);
                return (a = (0,
                Eb.clamp)(m, d.left, b) - d.left) || g ? (c.moveBy(a, g),
                !0) : !1
            },
            bumpIntoBoundsHandler: function(a) {
                return function(b) {
                    var c = a.getMetricsManager();
                    if (c.hasFixedEdges() && !a.isDragging())
                        if (-1 !== k.BUMP_EVENTS.indexOf(b.type)) {
                            c = c.getScrollMetrics(!0);
                            var d = null;
                            switch (b.type) {
                            case k.CREATE:
                            case k.MOVE:
                                (d = a.getBlockById(b.blockId)) && (d = d.getRootBlock());
                                break;
                            case k.COMMENT_CREATE:
                            case k.COMMENT_MOVE:
                                d = a.getCommentById(b.commentId)
                            }
                            if (d) {
                                var f = (0,
                                k.getGroup)();
                                (0,
                                k.setGroup)(b.group);
                                (0,
                                Fc.bumpIntoBounds)(a, c, d) && !b.group && console.warn("Moved object in bounds but there was no event group. This may break undo.");
                                null !== f && (0,
                                k.setGroup)(f)
                            }
                        } else
                            b.type === k.VIEWPORT_CHANGE && b.scale > b.oldScale && (0,
                            Fc.bumpTopObjectsIntoBounds)(a)
                }
            },
            bumpTopObjectsIntoBounds: function(a) {
                var b = a.getMetricsManager();
                if (b.hasFixedEdges() && !a.isDragging()) {
                    b = b.getScrollMetrics(!0);
                    for (var c = a.getTopBoundedElements(), d = 0, f; f = c[d]; d++)
                        (0,
                        Fc.bumpIntoBounds)(a, b, f)
                }
            }
        }
          , J = function(a, b) {
            this.x = a;
            this.y = b
        };
        J.equals = function(a, b) {
            return a === b ? !0 : a && b ? a.x === b.x && a.y === b.y : !1
        }
        ;
        J.distance = function(a, b) {
            var c = a.x - b.x;
            a = a.y - b.y;
            return Math.sqrt(c * c + a * a)
        }
        ;
        J.magnitude = function(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y)
        }
        ;
        J.difference = function(a, b) {
            return new J(a.x - b.x,a.y - b.y)
        }
        ;
        J.sum = function(a, b) {
            return new J(a.x + b.x,a.y + b.y)
        }
        ;
        J.prototype.clone = function() {
            return new J(this.x,this.y)
        }
        ;
        J.prototype.scale = function(a) {
            this.x *= a;
            this.y *= a;
            return this
        }
        ;
        J.prototype.translate = function(a, b) {
            this.x += a;
            this.y += b;
            return this
        }
        ;
        var Pa = function(a, b) {
            this.width = a;
            this.height = b
        };
        Pa.equals = function(a, b) {
            return a === b ? !0 : a && b ? a.width === b.width && a.height === b.height : !1
        }
        ;
        var ta = {
            getSize: function(a) {
                if ("none" !== re(a, "display"))
                    return new Pa(a.offsetWidth,a.offsetHeight);
                var b = a.style
                  , c = b.display
                  , d = b.visibility
                  , f = b.position;
                b.visibility = "hidden";
                b.position = "absolute";
                b.display = "inline";
                var g = a.offsetWidth;
                a = a.offsetHeight;
                b.display = c;
                b.position = f;
                b.visibility = d;
                return new Pa(g,a)
            }
        }
          , re = function(a, b) {
            return (0,
            ta.getComputedStyle)(a, b) || (0,
            ta.getCascadedStyle)(a, b) || a.style && a.style[b]
        };
        ta.getComputedStyle = function(a, b) {
            return document.defaultView && document.defaultView.getComputedStyle && (a = document.defaultView.getComputedStyle(a, null)) ? a[b] || a.getPropertyValue(b) || "" : ""
        }
        ;
        ta.getCascadedStyle = function(a, b) {
            return a.currentStyle ? a.currentStyle[b] : null
        }
        ;
        ta.getPageOffset = function(a) {
            var b = new J(0,0);
            a = a.getBoundingClientRect();
            var c = document.documentElement;
            c = new J(window.pageXOffset || c.scrollLeft,window.pageYOffset || c.scrollTop);
            b.x = a.left + c.x;
            b.y = a.top + c.y;
            return b
        }
        ;
        ta.getViewportPageOffset = function() {
            var a = document.body
              , b = document.documentElement;
            return new J(a.scrollLeft || b.scrollLeft,a.scrollTop || b.scrollTop)
        }
        ;
        ta.setElementShown = function(a, b) {
            a.style.display = b ? "" : "none"
        }
        ;
        ta.isRightToLeft = function(a) {
            return "rtl" === re(a, "direction")
        }
        ;
        ta.getBorderBox = function(a) {
            var b = (0,
            ta.getComputedStyle)(a, "borderLeftWidth")
              , c = (0,
            ta.getComputedStyle)(a, "borderRightWidth")
              , d = (0,
            ta.getComputedStyle)(a, "borderTopWidth");
            a = (0,
            ta.getComputedStyle)(a, "borderBottomWidth");
            return {
                top: parseFloat(d),
                right: parseFloat(c),
                bottom: parseFloat(a),
                left: parseFloat(b)
            }
        }
        ;
        ta.scrollIntoContainerView = function(a, b, c) {
            a = (0,
            ta.getContainerOffsetToScrollInto)(a, b, c);
            b.scrollLeft = a.x;
            b.scrollTop = a.y
        }
        ;
        ta.getContainerOffsetToScrollInto = function(a, b, c) {
            var d = (0,
            ta.getPageOffset)(a)
              , f = (0,
            ta.getPageOffset)(b)
              , g = (0,
            ta.getBorderBox)(b)
              , m = d.x - f.x - g.left;
            d = d.y - f.y - g.top;
            f = new Pa(a.offsetWidth,a.offsetHeight);
            a = b.clientWidth - f.width;
            f = b.clientHeight - f.height;
            g = b.scrollLeft;
            b = b.scrollTop;
            c ? (g += m - a / 2,
            b += d - f / 2) : (g += Math.min(m, Math.max(m - a, 0)),
            b += Math.min(d, Math.max(d - f, 0)));
            return new J(g,b)
        }
        ;
        var Ha = function(a, b, c, d) {
            this.top = a;
            this.bottom = b;
            this.left = c;
            this.right = d
        };
        Ha.prototype.contains = function(a, b) {
            return a >= this.left && a <= this.right && b >= this.top && b <= this.bottom
        }
        ;
        Ha.prototype.intersects = function(a) {
            return !(this.left > a.right || this.right < a.left || this.top > a.bottom || this.bottom < a.top)
        }
        ;
        var ja = {}
          , se = /translate\(\s*([-+\d.e]+)([ ,]\s*([-+\d.e]+)\s*)?/
          , te = /transform:\s*translate(?:3d)?\(\s*([-+\d.e]+)\s*px([ ,]\s*([-+\d.e]+)\s*px)?/;
        ja.getRelativeXY = function(a) {
            var b = new J(0,0)
              , c = a.getAttribute("x");
            c && (b.x = parseInt(c, 10));
            if (c = a.getAttribute("y"))
                b.y = parseInt(c, 10);
            if (c = (c = a.getAttribute("transform")) && c.match(se))
                b.x += Number(c[1]),
                c[3] && (b.y += Number(c[3]));
            (a = a.getAttribute("style")) && -1 < a.indexOf("translate") && (a = a.match(te)) && (b.x += Number(a[1]),
            a[3] && (b.y += Number(a[3])));
            return b
        }
        ;
        ja.getInjectionDivXY = function(a) {
            for (var b = 0, c = 0; a; ) {
                var d = (0,
                ja.getRelativeXY)(a);
                b += d.x;
                c += d.y;
                if (-1 !== (" " + (a.getAttribute("class") || "") + " ").indexOf(" injectionDiv "))
                    break;
                a = a.parentNode
            }
            return new J(b,c)
        }
        ;
        ja.is3dSupported = function() {
            if (void 0 !== ja.is3dSupported.cached_)
                return ja.is3dSupported.cached_;
            if (!e.module$exports$Blockly$utils$global.globalThis.getComputedStyle)
                return !1;
            var a = document.createElement("p")
              , b = "none"
              , c = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            document.body.insertBefore(a, null);
            for (var d in c)
                if (void 0 !== a.style[d]) {
                    a.style[d] = "translate3d(1px,1px,1px)";
                    b = e.module$exports$Blockly$utils$global.globalThis.getComputedStyle(a);
                    if (!b)
                        return document.body.removeChild(a),
                        !1;
                    b = b.getPropertyValue(c[d])
                }
            document.body.removeChild(a);
            ja.is3dSupported.cached_ = "none" !== b;
            return ja.is3dSupported.cached_
        }
        ;
        ja.getViewportBBox = function() {
            var a = (0,
            ta.getViewportPageOffset)();
            return new Ha(a.y,document.documentElement.clientHeight + a.y,a.x,document.documentElement.clientWidth + a.x)
        }
        ;
        ja.getDocumentScroll = function() {
            var a = document.documentElement
              , b = window;
            return V.IE && b.pageYOffset !== a.scrollTop ? new J(a.scrollLeft,a.scrollTop) : new J(b.pageXOffset || a.scrollLeft,b.pageYOffset || a.scrollTop)
        }
        ;
        ja.screenToWsCoordinates = function(a, b) {
            var c = b.x;
            b = b.y;
            var d = a.getInjectionDiv().getBoundingClientRect();
            c = new J(c - d.left,b - d.top);
            b = a.getOriginOffsetInPixels();
            return J.difference(c, b).scale(1 / a.scale)
        }
        ;
        ja.svgSize = function(a) {
            (0,
            q.warn)("Blockly.svgSize", "March 2021", "March 2022", "workspace.getCachedParentSvgSize");
            return new Pa(a.cachedWidth_,a.cachedHeight_)
        }
        ;
        ja.TEST_ONLY = {
            XY_REGEX: se,
            XY_STYLE_REGEX: te
        };
        var u = function(a) {
            this.tagName_ = a
        };
        u.prototype.toString = function() {
            return this.tagName_
        }
        ;
        u.ANIMATE = new u("animate");
        u.CIRCLE = new u("circle");
        u.CLIPPATH = new u("clipPath");
        u.DEFS = new u("defs");
        u.FECOMPOSITE = new u("feComposite");
        u.FECOMPONENTTRANSFER = new u("feComponentTransfer");
        u.FEFLOOD = new u("feFlood");
        u.FEFUNCA = new u("feFuncA");
        u.FEGAUSSIANBLUR = new u("feGaussianBlur");
        u.FEPOINTLIGHT = new u("fePointLight");
        u.FESPECULARLIGHTING = new u("feSpecularLighting");
        u.FILTER = new u("filter");
        u.FOREIGNOBJECT = new u("foreignObject");
        u.G = new u("g");
        u.IMAGE = new u("image");
        u.LINE = new u("line");
        u.PATH = new u("path");
        u.PATTERN = new u("pattern");
        u.POLYGON = new u("polygon");
        u.RECT = new u("rect");
        u.SVG = new u("svg");
        u.TEXT = new u("text");
        u.TSPAN = new u("tspan");
        var Ta = function(a) {
            this.container_ = a;
            this.createDom()
        };
        Ta.prototype.SVG_ = null;
        Ta.prototype.dragGroup_ = null;
        Ta.prototype.container_ = null;
        Ta.prototype.scale_ = 1;
        Ta.prototype.surfaceXY_ = null;
        Ta.prototype.childSurfaceXY_ = new J(0,0);
        Ta.prototype.createDom = function() {
            this.SVG_ || (this.SVG_ = (0,
            n.createSvgElement)(u.SVG, {
                xmlns: n.SVG_NS,
                "xmlns:html": n.HTML_NS,
                "xmlns:xlink": n.XLINK_NS,
                version: "1.1",
                "class": "blocklyBlockDragSurface"
            }, this.container_),
            this.dragGroup_ = (0,
            n.createSvgElement)(u.G, {}, this.SVG_))
        }
        ;
        Ta.prototype.setBlocksAndShow = function(a) {
            if (this.dragGroup_.childNodes.length)
                throw Error("Already dragging a block.");
            this.dragGroup_.appendChild(a);
            this.SVG_.style.display = "block";
            this.surfaceXY_ = new J(0,0)
        }
        ;
        Ta.prototype.translateAndScaleGroup = function(a, b, c) {
            this.scale_ = c;
            a = a.toFixed(0);
            b = b.toFixed(0);
            this.childSurfaceXY_.x = parseInt(a, 10);
            this.childSurfaceXY_.y = parseInt(b, 10);
            this.dragGroup_.setAttribute("transform", "translate(" + a + "," + b + ") scale(" + c + ")")
        }
        ;
        Ta.prototype.translateSurfaceInternal_ = function() {
            var a = this.surfaceXY_.x
              , b = this.surfaceXY_.y;
            a = a.toFixed(0);
            b = b.toFixed(0);
            this.SVG_.style.display = "block";
            (0,
            n.setCssTransform)(this.SVG_, "translate3d(" + a + "px, " + b + "px, 0)")
        }
        ;
        Ta.prototype.translateBy = function(a, b) {
            this.surfaceXY_ = new J(this.surfaceXY_.x + a,this.surfaceXY_.y + b);
            this.translateSurfaceInternal_()
        }
        ;
        Ta.prototype.translateSurface = function(a, b) {
            this.surfaceXY_ = new J(a * this.scale_,b * this.scale_);
            this.translateSurfaceInternal_()
        }
        ;
        Ta.prototype.getSurfaceTranslation = function() {
            var a = (0,
            ja.getRelativeXY)(this.SVG_);
            return new J(a.x / this.scale_,a.y / this.scale_)
        }
        ;
        Ta.prototype.getGroup = function() {
            return this.dragGroup_
        }
        ;
        Ta.prototype.getSvgRoot = function() {
            return this.SVG_
        }
        ;
        Ta.prototype.getCurrentBlock = function() {
            return this.dragGroup_.firstChild
        }
        ;
        Ta.prototype.getWsTranslation = function() {
            return this.childSurfaceXY_.clone()
        }
        ;
        Ta.prototype.clearAndHide = function(a) {
            a ? a.appendChild(this.getCurrentBlock()) : this.dragGroup_.removeChild(this.getCurrentBlock());
            this.SVG_.style.display = "none";
            if (this.dragGroup_.childNodes.length)
                throw Error("Drag group was not cleared.");
            this.surfaceXY_ = null
        }
        ;
        var C = function() {};
        C.ARROW_SIZE = 16;
        C.BORDER_SIZE = 1;
        C.ARROW_HORIZONTAL_PADDING = 12;
        C.PADDING_Y = 16;
        C.ANIMATION_TIME = .25;
        C.animateOutTimer_ = null;
        C.onHide_ = null;
        C.rendererClassName_ = "";
        C.themeClassName_ = "";
        C.boundsElement_ = null;
        C.owner_ = null;
        C.positionToField_ = null;
        C.createDom = function() {
            if (!C.DIV_) {
                var a = document.createElement("div");
                a.className = "blocklyDropDownDiv";
                ((0,
                e.module$exports$Blockly$common.getParentContainer)() || document.body).appendChild(a);
                C.DIV_ = a;
                a = document.createElement("div");
                a.className = "blocklyDropDownContent";
                C.DIV_.appendChild(a);
                C.content_ = a;
                a = document.createElement("div");
                a.className = "blocklyDropDownArrow";
                C.DIV_.appendChild(a);
                C.arrow_ = a;
                C.DIV_.style.opacity = 0;
                C.DIV_.style.transition = "transform " + C.ANIMATION_TIME + "s, opacity " + C.ANIMATION_TIME + "s";
                C.DIV_.addEventListener("focusin", function() {
                    (0,
                    n.addClass)(C.DIV_, "blocklyFocused")
                });
                C.DIV_.addEventListener("focusout", function() {
                    (0,
                    n.removeClass)(C.DIV_, "blocklyFocused")
                })
            }
        }
        ;
        C.setBoundsElement = function(a) {
            C.boundsElement_ = a
        }
        ;
        C.getContentDiv = function() {
            return C.content_
        }
        ;
        C.clearContent = function() {
            C.content_.textContent = "";
            C.content_.style.width = ""
        }
        ;
        C.setColour = function(a, b) {
            C.DIV_.style.backgroundColor = a;
            C.DIV_.style.borderColor = b
        }
        ;
        C.showPositionedByBlock = function(a, b, c, d) {
            return ue(ve(b), a, c, d)
        }
        ;
        C.showPositionedByField = function(a, b, c) {
            C.positionToField_ = !0;
            return ue(we(a), a, b, c)
        }
        ;
        var gd = {}
          , ve = function(a) {
            var b = a.getSvgRoot()
              , c = b.getBBox()
              , d = a.workspace.scale;
            a = c.height * d;
            c = c.width * d;
            b = (0,
            ta.getPageOffset)(b);
            return new Ha(b.y,b.y + a,b.x,b.x + c)
        }
          , we = function(a) {
            a = a.getScaledBBox();
            return new Ha(a.top,a.bottom,a.left,a.right)
        }
          , ue = function(a, b, c, d) {
            var f = a.left + (a.right - a.left) / 2
              , g = a.bottom;
            a = a.top;
            d && (a += d);
            d = b.getSourceBlock();
            for (var m = d.workspace; m.options.parentWorkspace; )
                m = m.options.parentWorkspace;
            C.setBoundsElement(m.getParentSvg().parentNode);
            return C.show(b, d.RTL, f, g, f, a, c)
        };
        C.show = function(a, b, c, d, f, g, m) {
            C.owner_ = a;
            C.onHide_ = m || null;
            a = C.DIV_;
            a.style.direction = b ? "rtl" : "ltr";
            b = (0,
            e.module$exports$Blockly$common.getMainWorkspace)();
            C.rendererClassName_ = b.getRenderer().getClassName();
            C.themeClassName_ = b.getTheme().getClassName();
            (0,
            n.addClass)(a, C.rendererClassName_);
            (0,
            n.addClass)(a, C.themeClassName_);
            return xe(c, d, f, g)
        }
        ;
        gd.getBoundsInfo = function() {
            var a = (0,
            ta.getPageOffset)(C.boundsElement_)
              , b = (0,
            ta.getSize)(C.boundsElement_);
            return {
                left: a.x,
                right: a.x + b.width,
                top: a.y,
                bottom: a.y + b.height,
                width: b.width,
                height: b.height
            }
        }
        ;
        gd.getPositionMetrics = function(a, b, c, d) {
            var f = gd.getBoundsInfo()
              , g = (0,
            ta.getSize)(C.DIV_);
            b + g.height < f.bottom ? a = ye(a, b, f, g) : d - g.height > f.top ? a = ze(c, d, f, g) : b + g.height < document.documentElement.clientHeight ? a = ye(a, b, f, g) : d - g.height > document.documentElement.clientTop ? a = ze(c, d, f, g) : (a = C.getPositionX(a, f.left, f.right, g.width),
            a = {
                initialX: a.divX,
                initialY: 0,
                finalX: a.divX,
                finalY: 0,
                arrowAtTop: null,
                arrowX: null,
                arrowY: null,
                arrowVisible: !1
            });
            return a
        }
        ;
        var ye = function(a, b, c, d) {
            a = C.getPositionX(a, c.left, c.right, d.width);
            return {
                initialX: a.divX,
                initialY: b,
                finalX: a.divX,
                finalY: b + C.PADDING_Y,
                arrowX: a.arrowX,
                arrowY: -(C.ARROW_SIZE / 2 + C.BORDER_SIZE),
                arrowAtTop: !0,
                arrowVisible: !0
            }
        }
          , ze = function(a, b, c, d) {
            a = C.getPositionX(a, c.left, c.right, d.width);
            return {
                initialX: a.divX,
                initialY: b - d.height,
                finalX: a.divX,
                finalY: b - d.height - C.PADDING_Y,
                arrowX: a.arrowX,
                arrowY: d.height - 2 * C.BORDER_SIZE - C.ARROW_SIZE / 2,
                arrowAtTop: !1,
                arrowVisible: !0
            }
        };
        C.getPositionX = function(a, b, c, d) {
            b = (0,
            Eb.clamp)(b, a - d / 2, c - d);
            a = a - C.ARROW_SIZE / 2 - b;
            c = C.ARROW_HORIZONTAL_PADDING;
            a = (0,
            Eb.clamp)(c, a, d - c - C.ARROW_SIZE);
            return {
                arrowX: a,
                divX: b
            }
        }
        ;
        C.isVisible = function() {
            return !!C.owner_
        }
        ;
        C.hideIfOwner = function(a, b) {
            return C.owner_ === a ? (b ? C.hideWithoutAnimation() : C.hide(),
            !0) : !1
        }
        ;
        C.hide = function() {
            C.DIV_.style.transform = "translate(0, 0)";
            C.DIV_.style.opacity = 0;
            C.animateOutTimer_ = setTimeout(function() {
                C.hideWithoutAnimation()
            }, 1E3 * C.ANIMATION_TIME);
            C.onHide_ && (C.onHide_(),
            C.onHide_ = null)
        }
        ;
        C.hideWithoutAnimation = function() {
            if (C.isVisible()) {
                C.animateOutTimer_ && clearTimeout(C.animateOutTimer_);
                var a = C.DIV_;
                a.style.transform = "";
                a.style.left = "";
                a.style.top = "";
                a.style.opacity = 0;
                a.style.display = "none";
                a.style.backgroundColor = "";
                a.style.borderColor = "";
                C.onHide_ && (C.onHide_(),
                C.onHide_ = null);
                C.clearContent();
                C.owner_ = null;
                C.rendererClassName_ && ((0,
                n.removeClass)(a, C.rendererClassName_),
                C.rendererClassName_ = "");
                C.themeClassName_ && ((0,
                n.removeClass)(a, C.themeClassName_),
                C.themeClassName_ = "");
                (0,
                e.module$exports$Blockly$common.getMainWorkspace)().markFocused()
            }
        }
        ;
        var xe = function(a, b, c, d) {
            a = gd.getPositionMetrics(a, b, c, d);
            a.arrowVisible ? (C.arrow_.style.display = "",
            C.arrow_.style.transform = "translate(" + a.arrowX + "px," + a.arrowY + "px) rotate(45deg)",
            C.arrow_.setAttribute("class", a.arrowAtTop ? "blocklyDropDownArrow blocklyArrowTop" : "blocklyDropDownArrow blocklyArrowBottom")) : C.arrow_.style.display = "none";
            b = Math.floor(a.initialX);
            c = Math.floor(a.initialY);
            d = Math.floor(a.finalX);
            var f = Math.floor(a.finalY)
              , g = C.DIV_;
            g.style.left = b + "px";
            g.style.top = c + "px";
            g.style.display = "block";
            g.style.opacity = 1;
            g.style.transform = "translate(" + (d - b) + "px," + (f - c) + "px)";
            return !!a.arrowAtTop
        };
        C.repositionForWindowResize = function() {
            if (C.owner_) {
                var a = C.owner_
                  , b = a.getSourceBlock();
                a = C.positionToField_ ? we(a) : ve(b);
                b = a.left + (a.right - a.left) / 2;
                xe(b, a.bottom, b, a.top)
            } else
                C.hide()
        }
        ;
        C.TEST_ONLY = gd;
        var Fb = function(a, b) {
            this.gridPattern_ = a;
            this.spacing_ = b.spacing;
            this.length_ = b.length;
            this.line2_ = (this.line1_ = a.firstChild) && this.line1_.nextSibling;
            this.snapToGrid_ = b.snap
        };
        Fb.prototype.scale_ = 1;
        Fb.prototype.dispose = function() {
            this.gridPattern_ = null
        }
        ;
        Fb.prototype.shouldSnap = function() {
            return this.snapToGrid_
        }
        ;
        Fb.prototype.getSpacing = function() {
            return this.spacing_
        }
        ;
        Fb.prototype.getPatternId = function() {
            return this.gridPattern_.id
        }
        ;
        Fb.prototype.update = function(a) {
            this.scale_ = a;
            var b = this.spacing_ * a || 100;
            this.gridPattern_.setAttribute("width", b);
            this.gridPattern_.setAttribute("height", b);
            b = Math.floor(this.spacing_ / 2) + .5;
            var c = b - this.length_ / 2
              , d = b + this.length_ / 2;
            b *= a;
            c *= a;
            d *= a;
            this.setLineAttributes_(this.line1_, a, c, d, b, b);
            this.setLineAttributes_(this.line2_, a, b, b, c, d)
        }
        ;
        Fb.prototype.setLineAttributes_ = function(a, b, c, d, f, g) {
            a && (a.setAttribute("stroke-width", b),
            a.setAttribute("x1", c),
            a.setAttribute("y1", f),
            a.setAttribute("x2", d),
            a.setAttribute("y2", g))
        }
        ;
        Fb.prototype.moveTo = function(a, b) {
            this.gridPattern_.setAttribute("x", a);
            this.gridPattern_.setAttribute("y", b);
            (V.IE || V.EDGE) && this.update(this.scale_)
        }
        ;
        Fb.createDom = function(a, b, c) {
            a = (0,
            n.createSvgElement)(u.PATTERN, {
                id: "blocklyGridPattern" + a,
                patternUnits: "userSpaceOnUse"
            }, c);
            0 < b.length && 0 < b.spacing ? ((0,
            n.createSvgElement)(u.LINE, {
                stroke: b.colour
            }, a),
            1 < b.length && (0,
            n.createSvgElement)(u.LINE, {
                stroke: b.colour
            }, a)) : (0,
            n.createSvgElement)(u.LINE, {}, a);
            return a
        }
        ;
        e.module$exports$Blockly$Msg = {};
        e.module$exports$Blockly$Msg.Msg = Object.create(null);
        e.module$exports$Blockly$utils$xml = {
            NAME_SPACE: "https://developers.google.com/blockly/xml"
        };
        var td = e.module$exports$Blockly$utils$global.globalThis.document;
        e.module$exports$Blockly$utils$xml.getDocument = function() {
            return td
        }
        ;
        e.module$exports$Blockly$utils$xml.setDocument = function(a) {
            td = a
        }
        ;
        e.module$exports$Blockly$utils$xml.createElement = function(a) {
            return td.createElementNS(e.module$exports$Blockly$utils$xml.NAME_SPACE, a)
        }
        ;
        e.module$exports$Blockly$utils$xml.createTextNode = function(a) {
            return td.createTextNode(a)
        }
        ;
        e.module$exports$Blockly$utils$xml.textToDomDocument = function(a) {
            return (new DOMParser).parseFromString(a, "text/xml")
        }
        ;
        e.module$exports$Blockly$utils$xml.domToText = function(a) {
            return (new XMLSerializer).serializeToString(a)
        }
        ;
        e.module$exports$Blockly$inputTypes = {};
        e.module$exports$Blockly$inputTypes.inputTypes = {
            VALUE: e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE,
            STATEMENT: e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT,
            DUMMY: 5
        };
        e.module$exports$Blockly$Xml = {
            workspaceToDom: function(a, b) {
                var c = (0,
                e.module$exports$Blockly$utils$xml.createElement)("xml")
                  , d = (0,
                e.module$exports$Blockly$Xml.variablesToDom)(e.module$exports$Blockly$Variables.allUsedVarModels(a));
                d.hasChildNodes() && c.appendChild(d);
                d = a.getTopComments(!0);
                for (var f = 0; f < d.length; f++)
                    c.appendChild(d[f].toXmlWithXY(b));
                a = a.getTopBlocks(!0);
                for (d = 0; d < a.length; d++)
                    c.appendChild((0,
                    e.module$exports$Blockly$Xml.blockToDomWithXY)(a[d], b));
                return c
            },
            variablesToDom: function(a) {
                for (var b = (0,
                e.module$exports$Blockly$utils$xml.createElement)("variables"), c = 0; c < a.length; c++) {
                    var d = a[c]
                      , f = (0,
                    e.module$exports$Blockly$utils$xml.createElement)("variable");
                    f.appendChild((0,
                    e.module$exports$Blockly$utils$xml.createTextNode)(d.name));
                    d.type && f.setAttribute("type", d.type);
                    f.id = d.getId();
                    b.appendChild(f)
                }
                return b
            },
            blockToDomWithXY: function(a, b) {
                if (a.isInsertionMarker() && (a = a.getChildren(!1)[0],
                !a))
                    return new DocumentFragment;
                var c;
                a.workspace.RTL && (c = a.workspace.getWidth());
                b = (0,
                e.module$exports$Blockly$Xml.blockToDom)(a, b);
                var d = a.getRelativeToSurfaceXY();
                b.setAttribute("x", Math.round(a.workspace.RTL ? c - d.x : d.x));
                b.setAttribute("y", Math.round(d.y));
                return b
            }
        };
        var Ze = function(a) {
            if (a.isSerializable()) {
                var b = (0,
                e.module$exports$Blockly$utils$xml.createElement)("field");
                b.setAttribute("name", a.name || "");
                return a.toXml(b)
            }
            return null
        };
        var $e = function(a, b) {
            for (var c = 0; c < a.inputList.length; c++)
                for (var d = a.inputList[c], f = 0; f < d.fieldRow.length; f++) {
                    var g = Ze(d.fieldRow[f]);
                    g && b.appendChild(g)
                }
        };
        e.module$exports$Blockly$Xml.blockToDom = function(a, b) {
            if (a.isInsertionMarker())
                return (b = a.getChildren(!1)[0]) ? (0,
                e.module$exports$Blockly$Xml.blockToDom)(b) : new DocumentFragment;
            var c = (0,
            e.module$exports$Blockly$utils$xml.createElement)(a.isShadow() ? "shadow" : "block");
            c.setAttribute("type", a.type);
            b || c.setAttribute("id", a.id);
            if (a.mutationToDom) {
                var d = a.mutationToDom();
                d && (d.hasChildNodes() || d.hasAttributes()) && c.appendChild(d)
            }
            $e(a, c);
            if (d = a.getCommentText()) {
                var f = a.commentModel.size
                  , g = a.commentModel.pinned
                  , m = (0,
                e.module$exports$Blockly$utils$xml.createElement)("comment");
                m.appendChild((0,
                e.module$exports$Blockly$utils$xml.createTextNode)(d));
                m.setAttribute("pinned", g);
                m.setAttribute("h", f.height);
                m.setAttribute("w", f.width);
                c.appendChild(m)
            }
            a.data && (d = (0,
            e.module$exports$Blockly$utils$xml.createElement)("data"),
            d.appendChild((0,
            e.module$exports$Blockly$utils$xml.createTextNode)(a.data)),
            c.appendChild(d));
            for (d = 0; d < a.inputList.length; d++)
                if (f = a.inputList[d],
                g = void 0,
                m = !0,
                f.type !== e.module$exports$Blockly$inputTypes.inputTypes.DUMMY) {
                    var r = f.connection.targetBlock();
                    f.type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE ? g = (0,
                    e.module$exports$Blockly$utils$xml.createElement)("value") : f.type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT && (g = (0,
                    e.module$exports$Blockly$utils$xml.createElement)("statement"));
                    var B = f.connection.getShadowDom();
                    !B || r && r.isShadow() || g.appendChild(Ae(B, b));
                    r && (r = (0,
                    e.module$exports$Blockly$Xml.blockToDom)(r, b),
                    r.nodeType === n.NodeType.ELEMENT_NODE && (g.appendChild(r),
                    m = !1));
                    g.setAttribute("name", f.name);
                    m || c.appendChild(g)
                }
            void 0 !== a.inputsInline && a.inputsInline !== a.inputsInlineDefault && c.setAttribute("inline", a.inputsInline);
            a.isCollapsed() && c.setAttribute("collapsed", !0);
            a.isEnabled() || c.setAttribute("disabled", !0);
            a.isDeletable() || a.isShadow() || c.setAttribute("deletable", !1);
            a.isMovable() || a.isShadow() || c.setAttribute("movable", !1);
            a.isEditable() || c.setAttribute("editable", !1);
            if ((d = a.getNextBlock()) && (f = (0,
            e.module$exports$Blockly$Xml.blockToDom)(d, b),
            f.nodeType === n.NodeType.ELEMENT_NODE)) {
                var G = (0,
                e.module$exports$Blockly$utils$xml.createElement)("next");
                G.appendChild(f);
                c.appendChild(G)
            }
            a = a.nextConnection && a.nextConnection.getShadowDom();
            !a || d && d.isShadow() || G.appendChild(Ae(a, b));
            return c
        }
        ;
        var Ae = function(a, b) {
            for (var c = a = a.cloneNode(!0), d; c; )
                if (b && "shadow" === c.nodeName && c.removeAttribute("id"),
                c.firstChild)
                    c = c.firstChild;
                else {
                    for (; c && !c.nextSibling; )
                        d = c,
                        c = c.parentNode,
                        d.nodeType === n.NodeType.TEXT_NODE && "" === d.data.trim() && c.firstChild !== d && (0,
                        n.removeNode)(d);
                    c && (d = c,
                    c = c.nextSibling,
                    d.nodeType === n.NodeType.TEXT_NODE && "" === d.data.trim() && (0,
                    n.removeNode)(d))
                }
            return a
        };
        e.module$exports$Blockly$Xml.domToText = function(a) {
            return (0,
            e.module$exports$Blockly$utils$xml.domToText)(a).replace(/<(\w+)([^<]*)\/>/g, "<$1$2></$1>")
        }
        ;
        e.module$exports$Blockly$Xml.domToPrettyText = function(a) {
            a = (0,
            e.module$exports$Blockly$Xml.domToText)(a).split("<");
            for (var b = "", c = 1; c < a.length; c++) {
                var d = a[c];
                "/" === d[0] && (b = b.substring(2));
                a[c] = b + "<" + d;
                "/" !== d[0] && "/>" !== d.slice(-2) && (b += "  ")
            }
            a = a.join("\n");
            a = a.replace(/(<(\w+)\b[^>]*>[^\n]*)\n *<\/\2>/g, "$1</$2>");
            return a.replace(/^\n/, "")
        }
        ;
        e.module$exports$Blockly$Xml.textToDom = function(a) {
            var b = (0,
            e.module$exports$Blockly$utils$xml.textToDomDocument)(a);
            if (!b || !b.documentElement || b.getElementsByTagName("parsererror").length)
                throw Error("textToDom was unable to parse: " + a);
            return b.documentElement
        }
        ;
        e.module$exports$Blockly$Xml.clearWorkspaceAndLoadFromXml = function(a, b) {
            b.setResizesEnabled(!1);
            b.clear();
            a = (0,
            e.module$exports$Blockly$Xml.domToWorkspace)(a, b);
            b.setResizesEnabled(!0);
            return a
        }
        ;
        e.module$exports$Blockly$Xml.domToWorkspace = function(a, b) {
            if (a instanceof N.Workspace) {
                var c = a;
                a = b;
                b = c;
                console.warn("Deprecated call to domToWorkspace, swap the arguments.")
            }
            var d;
            b.RTL && (d = b.getWidth());
            c = [];
            (0,
            n.startTextWidthCache)();
            var f = (0,
            k.getGroup)();
            f || (0,
            k.setGroup)(!0);
            b.setResizesEnabled && b.setResizesEnabled(!1);
            var g = !0;
            try {
                for (var m = 0, r = void 0; r = a.childNodes[m]; m++) {
                    var B = r.nodeName.toLowerCase()
                      , G = r;
                    if ("block" === B || "shadow" === B && !(0,
                    k.getRecordUndo)()) {
                        var W = (0,
                        e.module$exports$Blockly$Xml.domToBlock)(G, b);
                        c.push(W.id);
                        var ra = G.hasAttribute("x") ? parseInt(G.getAttribute("x"), 10) : 10
                          , Fa = G.hasAttribute("y") ? parseInt(G.getAttribute("y"), 10) : 10;
                        isNaN(ra) || isNaN(Fa) || W.moveBy(b.RTL ? d - ra : ra, Fa);
                        g = !1
                    } else {
                        if ("shadow" === B)
                            throw TypeError("Shadow block cannot be a top-level block.");
                        if ("comment" === B)
                            if (b.rendered) {
                                var Wa = S.WorkspaceCommentSvg;
                                Wa ? Wa.fromXml(G, b, d) : console.warn("Missing require for Blockly.WorkspaceCommentSvg, ignoring workspace comment.")
                            } else {
                                var Ga = ua.WorkspaceComment;
                                Ga ? Ga.fromXml(G, b) : console.warn("Missing require for Blockly.WorkspaceComment, ignoring workspace comment.")
                            }
                        else if ("variables" === B) {
                            if (g)
                                (0,
                                e.module$exports$Blockly$Xml.domToVariables)(G, b);
                            else
                                throw Error("'variables' tag must exist once before block and shadow tag elements in the workspace XML, but it was found in another location.");
                            g = !1
                        }
                    }
                }
            } finally {
                f || (0,
                k.setGroup)(!1),
                (0,
                n.stopTextWidthCache)()
            }
            b.setResizesEnabled && b.setResizesEnabled(!0);
            (0,
            k.fire)(new ((0,
            k.get)(k.FINISHED_LOADING))(b));
            return c
        }
        ;
        e.module$exports$Blockly$Xml.appendDomToWorkspace = function(a, b) {
            var c;
            Object.prototype.hasOwnProperty.call(b, "scale") && (c = b.getBlocksBoundingBox());
            a = (0,
            e.module$exports$Blockly$Xml.domToWorkspace)(a, b);
            if (c && c.top !== c.bottom) {
                var d = c.bottom;
                c = b.RTL ? c.right : c.left;
                for (var f = Infinity, g = -Infinity, m = Infinity, r = 0; r < a.length; r++) {
                    var B = b.getBlockById(a[r]).getRelativeToSurfaceXY();
                    B.y < m && (m = B.y);
                    B.x < f && (f = B.x);
                    B.x > g && (g = B.x)
                }
                d = d - m + 10;
                c = b.RTL ? c - g : c - f;
                for (f = 0; f < a.length; f++)
                    b.getBlockById(a[f]).moveBy(c, d)
            }
            return a
        }
        ;
        e.module$exports$Blockly$Xml.domToBlock = function(a, b) {
            if (a instanceof N.Workspace) {
                var c = a;
                a = b;
                b = c;
                console.warn("Deprecated call to domToBlock, swap the arguments.")
            }
            (0,
            k.disable)();
            c = b.getAllVariables();
            try {
                var d = Vd(a, b)
                  , f = d.getDescendants(!1);
                if (b.rendered) {
                    d.setConnectionTracking(!1);
                    for (var g = f.length - 1; 0 <= g; g--)
                        f[g].initSvg();
                    for (var m = f.length - 1; 0 <= m; m--)
                        f[m].render(!1);
                    setTimeout(function() {
                        d.disposed || d.setConnectionTracking(!0)
                    }, 1);
                    d.updateDisabled();
                    b.resizeContents()
                } else
                    for (var r = f.length - 1; 0 <= r; r--)
                        f[r].initModel()
            } finally {
                (0,
                k.enable)()
            }
            if ((0,
            k.isEnabled)()) {
                a = e.module$exports$Blockly$Variables.getAddedVariables(b, c);
                for (b = 0; b < a.length; b++)
                    f = a[b],
                    (0,
                    k.fire)(new ((0,
                    k.get)(k.VAR_CREATE))(f));
                (0,
                k.fire)(new ((0,
                k.get)(k.CREATE))(d))
            }
            return d
        }
        ;
        e.module$exports$Blockly$Xml.domToVariables = function(a, b) {
            for (var c = 0; c < a.childNodes.length; c++) {
                var d = a.childNodes[c];
                if (d.nodeType === n.NodeType.ELEMENT_NODE) {
                    var f = d.getAttribute("type")
                      , g = d.getAttribute("id");
                    b.createVariable(d.textContent, f, g)
                }
            }
        }
        ;
        var af = function(a, b) {
            for (var c = 0; c < a.length; c++) {
                var d = a[c]
                  , f = d.textContent
                  , g = "true" === d.getAttribute("pinned")
                  , m = parseInt(d.getAttribute("w"), 10);
                d = parseInt(d.getAttribute("h"), 10);
                b.setCommentText(f);
                b.commentModel.pinned = g;
                isNaN(m) || isNaN(d) || (b.commentModel.size = new Pa(m,d));
                g && b.getCommentIcon && !b.isInFlyout && setTimeout(function() {
                    b.getCommentIcon().setVisible(!0)
                }, 1)
            }
        }
          , Be = function(a) {
            for (var b = {
                childBlockElement: null,
                childShadowElement: null
            }, c = 0; c < a.childNodes.length; c++) {
                var d = a.childNodes[c];
                d.nodeType === n.NodeType.ELEMENT_NODE && ("block" === d.nodeName.toLowerCase() ? b.childBlockElement = d : "shadow" === d.nodeName.toLowerCase() && (b.childShadowElement = d))
            }
            return b
        }
          , Vd = function(a, b, c, d) {
            var f = a.getAttribute("type");
            if (!f)
                throw TypeError("Block type unspecified: " + a.outerHTML);
            var g = a.getAttribute("id");
            g = b.newBlock(f, g);
            for (var m = a, r = [], B = [], G = [], W = [], ra = [], Fa = [], Wa = 0; Wa < m.childNodes.length; Wa++) {
                var Ga = m.childNodes[Wa];
                if (Ga.nodeType !== n.NodeType.TEXT_NODE)
                    switch (Ga.nodeName.toLowerCase()) {
                    case "mutation":
                        r.push(Ga);
                        break;
                    case "comment":
                        if (!Qa) {
                            console.warn("Missing require for Comment, ignoring block comment.");
                            break
                        }
                        B.push(Ga);
                        break;
                    case "data":
                        G.push(Ga);
                        break;
                    case "title":
                    case "field":
                        W.push(Ga);
                        break;
                    case "value":
                    case "statement":
                        ra.push(Ga);
                        break;
                    case "next":
                        Fa.push(Ga);
                        break;
                    default:
                        console.warn("Ignoring unknown tag: " + Ga.nodeName)
                    }
            }
            m = g;
            Wa = !1;
            for (Ga = 0; Ga < r.length; Ga++) {
                var Cc = r[Ga];
                m.domToMutation && (m.domToMutation(Cc),
                m.initSvg && (Wa = !0))
            }
            r = Wa;
            af(B, g);
            B = g;
            for (m = 0; m < G.length; m++)
                B.data = G[m].textContent;
            if (c)
                if (d)
                    if (g.previousConnection)
                        c.connect(g.previousConnection);
                    else
                        throw TypeError("Next block does not have previous statement.");
                else if (g.outputConnection)
                    c.connect(g.outputConnection);
                else if (g.previousConnection)
                    c.connect(g.previousConnection);
                else
                    throw TypeError("Child block does not have output or previous statement.");
            c = g;
            for (d = 0; d < W.length; d++)
                m = W[d],
                B = m.getAttribute("name"),
                G = c,
                (Wa = G.getField(B)) ? Wa.fromXml(m) : console.warn("Ignoring non-existent field " + B + " in block " + G.type);
            W = b;
            c = g;
            for (d = 0; d < ra.length; d++) {
                G = ra[d];
                B = G.getAttribute("name");
                m = c.getInput(B);
                if (!m) {
                    console.warn("Ignoring non-existent input " + B + " in block " + f);
                    break
                }
                G = Be(G);
                if (G.childBlockElement) {
                    if (!m.connection)
                        throw TypeError("Input connection does not exist.");
                    Vd(G.childBlockElement, W, m.connection, !1)
                }
                G.childShadowElement && m.connection.setShadowDom(G.childShadowElement)
            }
            f = b;
            ra = g;
            for (W = 0; W < Fa.length; W++) {
                c = Be(Fa[W]);
                if (c.childBlockElement) {
                    if (!ra.nextConnection)
                        throw TypeError("Next statement does not exist.");
                    if (ra.nextConnection.isConnected())
                        throw TypeError("Next statement is already connected.");
                    Vd(c.childBlockElement, f, ra.nextConnection, !0)
                }
                c.childShadowElement && ra.nextConnection && ra.nextConnection.setShadowDom(c.childShadowElement)
            }
            r && g.initSvg();
            (b = a.getAttribute("inline")) && g.setInputsInline("true" === b);
            (b = a.getAttribute("disabled")) && g.setEnabled("true" !== b && "disabled" !== b);
            (b = a.getAttribute("deletable")) && g.setDeletable("true" === b);
            (b = a.getAttribute("movable")) && g.setMovable("true" === b);
            (b = a.getAttribute("editable")) && g.setEditable("true" === b);
            (b = a.getAttribute("collapsed")) && g.setCollapsed("true" === b);
            if ("shadow" === a.nodeName.toLowerCase()) {
                a = g.getChildren(!1);
                for (b = 0; b < a.length; b++)
                    if (!a[b].isShadow())
                        throw TypeError("Shadow block not allowed non-shadow child.");
                if (g.getVarModels().length)
                    throw TypeError("Shadow blocks cannot have variable references.");
                g.setShadow(!0)
            }
            return g
        };
        e.module$exports$Blockly$Xml.deleteNext = function(a) {
            for (var b = 0; b < a.childNodes.length; b++) {
                var c = a.childNodes[b];
                if ("next" === c.nodeName.toLowerCase()) {
                    a.removeChild(c);
                    break
                }
            }
        }
        ;
        var X = {
            Position: {
                TOP: 0,
                BOTTOM: 1,
                LEFT: 2,
                RIGHT: 3
            },
            convertToolboxDefToJson: function(a) {
                if (!a)
                    return null;
                if (a instanceof Element || "string" === typeof a) {
                    a = (0,
                    X.parseToolboxTree)(a);
                    var b = {
                        contents: Wd(a)
                    };
                    a instanceof Node && Ce(a, b);
                    a = b
                }
                b = a;
                var c = b.kind;
                b = b.contents;
                if (c && "flyoutToolbox" !== c && "categoryToolbox" !== c)
                    throw Error("Invalid toolbox kind " + c + ". Please supply either flyoutToolbox or categoryToolbox");
                if (!b)
                    throw Error("Toolbox must have a contents attribute.");
                return a
            },
            convertFlyoutDefToJsonArray: function(a) {
                return a ? a.contents ? a.contents : Array.isArray(a) && 0 < a.length && !a[0].nodeType ? a : Wd(a) : []
            },
            hasCategories: function(a) {
                if (!a)
                    return !1;
                var b = a.kind;
                return b ? "categoryToolbox" === b : !!a.contents.filter(function(c) {
                    return "CATEGORY" === c.kind.toUpperCase()
                }).length
            },
            isCategoryCollapsible: function(a) {
                return a && a.contents ? !!a.contents.filter(function(b) {
                    return "CATEGORY" === b.kind.toUpperCase()
                }).length : !1
            }
        }
          , Wd = function(a) {
            var b = []
              , c = a.childNodes;
            c || (c = a);
            a = 0;
            for (var d; d = c[a]; a++)
                if (d.tagName) {
                    var f = {}
                      , g = d.tagName.toUpperCase();
                    f.kind = g;
                    "BLOCK" === g ? f.blockxml = d : d.childNodes && 0 < d.childNodes.length && (f.contents = Wd(d));
                    Ce(d, f);
                    b.push(f)
                }
            return b
        }
          , Ce = function(a, b) {
            for (var c = 0; c < a.attributes.length; c++) {
                var d = a.attributes[c];
                -1 < d.nodeName.indexOf("css-") ? (b.cssconfig = b.cssconfig || {},
                b.cssconfig[d.nodeName.replace("css-", "")] = d.value) : b[d.nodeName] = d.value
            }
        };
        X.parseToolboxTree = function(a) {
            if (a) {
                if ("string" !== typeof a && (V.IE && a.outerHTML ? a = a.outerHTML : a instanceof Element || (a = null)),
                "string" === typeof a && (a = (0,
                e.module$exports$Blockly$Xml.textToDom)(a),
                "xml" !== a.nodeName.toLowerCase()))
                    throw TypeError("Toolbox should be an <xml> document.");
            } else
                a = null;
            return a
        }
        ;
        e.module$exports$Blockly$utils$object = {
            inherits: function(a, b) {
                a.superClass_ = b.prototype;
                Object.setPrototypeOf(a, b);
                a.prototype = Object.create(b.prototype);
                a.prototype.constructor = a
            },
            mixin: function(a, b) {
                for (var c in b)
                    a[c] = b[c]
            },
            deepMerge: function(a, b) {
                for (var c in b)
                    a[c] = null !== b[c] && "object" === typeof b[c] ? (0,
                    e.module$exports$Blockly$utils$object.deepMerge)(a[c] || Object.create(null), b[c]) : b[c];
                return a
            },
            values: function(a) {
                return Object.values ? Object.values(a) : Object.keys(a).map(function(b) {
                    return a[b]
                })
            }
        };
        var mb = function(a, b, c, d) {
            this.name = a;
            this.blockStyles = b || Object.create(null);
            this.categoryStyles = c || Object.create(null);
            this.componentStyles = d || Object.create(null);
            this.fontStyle = Object.create(null);
            this.startHats = null;
            (0,
            w.register)(w.Type.THEME, a, this)
        };
        mb.prototype.getClassName = function() {
            return this.name + "-theme"
        }
        ;
        mb.prototype.setBlockStyle = function(a, b) {
            this.blockStyles[a] = b
        }
        ;
        mb.prototype.setCategoryStyle = function(a, b) {
            this.categoryStyles[a] = b
        }
        ;
        mb.prototype.getComponentStyle = function(a) {
            return (a = this.componentStyles[a]) && "string" === typeof a && this.getComponentStyle(a) ? this.getComponentStyle(a) : a ? String(a) : null
        }
        ;
        mb.prototype.setComponentStyle = function(a, b) {
            this.componentStyles[a] = b
        }
        ;
        mb.prototype.setFontStyle = function(a) {
            this.fontStyle = a
        }
        ;
        mb.prototype.setStartHats = function(a) {
            this.startHats = a
        }
        ;
        mb.defineTheme = function(a, b) {
            var c = new mb(a)
              , d = b.base;
            d && ("string" === typeof d && (d = (0,
            w.getObject)(w.Type.THEME, d)),
            d instanceof mb && ((0,
            e.module$exports$Blockly$utils$object.deepMerge)(c, d),
            c.name = a));
            (0,
            e.module$exports$Blockly$utils$object.deepMerge)(c.blockStyles, b.blockStyles);
            (0,
            e.module$exports$Blockly$utils$object.deepMerge)(c.categoryStyles, b.categoryStyles);
            (0,
            e.module$exports$Blockly$utils$object.deepMerge)(c.componentStyles, b.componentStyles);
            (0,
            e.module$exports$Blockly$utils$object.deepMerge)(c.fontStyle, b.fontStyle);
            null !== b.startHats && (c.startHats = b.startHats);
            return c
        }
        ;
        var ud = new mb("classic",{
            colour_blocks: {
                colourPrimary: "20"
            },
            list_blocks: {
                colourPrimary: "260"
            },
            logic_blocks: {
                colourPrimary: "210"
            },
            loop_blocks: {
                colourPrimary: "120"
            },
            math_blocks: {
                colourPrimary: "230"
            },
            procedure_blocks: {
                colourPrimary: "290"
            },
            text_blocks: {
                colourPrimary: "160"
            },
            variable_blocks: {
                colourPrimary: "330"
            },
            variable_dynamic_blocks: {
                colourPrimary: "310"
            },
            hat_blocks: {
                colourPrimary: "330",
                hat: "cap"
            }
        },{
            colour_category: {
                colour: "20"
            },
            list_category: {
                colour: "260"
            },
            logic_category: {
                colour: "210"
            },
            loop_category: {
                colour: "120"
            },
            math_category: {
                colour: "230"
            },
            procedure_category: {
                colour: "290"
            },
            text_category: {
                colour: "160"
            },
            variable_category: {
                colour: "330"
            },
            variable_dynamic_category: {
                colour: "310"
            }
        });
        var nb = {
            Options: function(a) {
                var b = null
                  , c = !1
                  , d = !1
                  , f = !1
                  , g = !1
                  , m = !1
                  , r = !1
                  , B = !!a.readOnly;
                B || (b = (0,
                X.convertToolboxDefToJson)(a.toolbox),
                c = (0,
                X.hasCategories)(b),
                d = a.trashcan,
                void 0 === d && (d = c),
                f = a.collapse,
                void 0 === f && (f = c),
                g = a.comments,
                void 0 === g && (g = c),
                m = a.disable,
                void 0 === m && (m = c),
                r = a.sounds,
                void 0 === r && (r = !0));
                var G = a.maxTrashcanContents;
                d ? void 0 === G && (G = 32) : G = 0;
                var W = !!a.rtl
                  , ra = a.horizontalLayout;
                void 0 === ra && (ra = !1);
                var Fa = a.toolboxPosition;
                Fa = "end" !== Fa;
                Fa = ra ? Fa ? X.Position.TOP : X.Position.BOTTOM : Fa === W ? X.Position.RIGHT : X.Position.LEFT;
                var Wa = a.css;
                void 0 === Wa && (Wa = !0);
                var Ga = "https://blockly-demo.appspot.com/static/media/";
                a.media ? Ga = a.media : a.path && (Ga = a.path + "media/");
                var Cc = void 0 === a.oneBasedIndex ? !0 : !!a.oneBasedIndex
                  , bf = a.renderer || "geras"
                  , cf = a.plugins || {};
                this.RTL = W;
                this.oneBasedIndex = Cc;
                this.collapse = f;
                this.comments = g;
                this.disable = m;
                this.readOnly = B;
                this.maxBlocks = a.maxBlocks || Infinity;
                this.maxInstances = a.maxInstances;
                this.pathToMedia = Ga;
                this.hasCategories = c;
                this.moveOptions = nb.Options.parseMoveOptions_(a, c);
                this.hasScrollbars = !!this.moveOptions.scrollbars;
                this.hasTrashcan = d;
                this.maxTrashcanContents = G;
                this.hasSounds = r;
                this.hasCss = Wa;
                this.horizontalLayout = ra;
                this.languageTree = b;
                this.gridOptions = nb.Options.parseGridOptions_(a);
                this.zoomOptions = nb.Options.parseZoomOptions_(a);
                this.toolboxPosition = Fa;
                this.theme = nb.Options.parseThemeOptions_(a);
                this.renderer = bf;
                this.rendererOverrides = a.rendererOverrides;
                this.gridPattern = null;
                this.parentWorkspace = a.parentWorkspace;
                this.plugins = cf
            }
        };
        nb.Options.parseMoveOptions_ = function(a, b) {
            var c = a.move || {}
              , d = {};
            void 0 === c.scrollbars && void 0 === a.scrollbars ? d.scrollbars = b : "object" === typeof c.scrollbars ? (d.scrollbars = {},
            d.scrollbars.horizontal = !!c.scrollbars.horizontal,
            d.scrollbars.vertical = !!c.scrollbars.vertical,
            d.scrollbars.horizontal && d.scrollbars.vertical ? d.scrollbars = !0 : d.scrollbars.horizontal || d.scrollbars.vertical || (d.scrollbars = !1)) : d.scrollbars = !!c.scrollbars || !!a.scrollbars;
            d.wheel = d.scrollbars && void 0 !== c.wheel ? !!c.wheel : "object" === typeof d.scrollbars;
            d.drag = d.scrollbars ? void 0 === c.drag ? !0 : !!c.drag : !1;
            return d
        }
        ;
        nb.Options.parseZoomOptions_ = function(a) {
            a = a.zoom || {};
            var b = {};
            b.controls = void 0 === a.controls ? !1 : !!a.controls;
            b.wheel = void 0 === a.wheel ? !1 : !!a.wheel;
            b.startScale = void 0 === a.startScale ? 1 : Number(a.startScale);
            b.maxScale = void 0 === a.maxScale ? 3 : Number(a.maxScale);
            b.minScale = void 0 === a.minScale ? .3 : Number(a.minScale);
            b.scaleSpeed = void 0 === a.scaleSpeed ? 1.2 : Number(a.scaleSpeed);
            b.pinch = void 0 === a.pinch ? b.wheel || b.controls : !!a.pinch;
            return b
        }
        ;
        nb.Options.parseGridOptions_ = function(a) {
            a = a.grid || {};
            var b = {};
            b.spacing = Number(a.spacing) || 0;
            b.colour = a.colour || "#888";
            b.length = void 0 === a.length ? 1 : Number(a.length);
            b.snap = 0 < b.spacing && !!a.snap;
            return b
        }
        ;
        nb.Options.parseThemeOptions_ = function(a) {
            a = a.theme || ud;
            return "string" === typeof a ? (0,
            w.getObject)(w.Type.THEME, a) : a instanceof mb ? a : mb.defineTheme(a.name || "builtin" + (0,
            bb.getNextUniqueId)(), a)
        }
        ;
        var L = {
            Scrollbar: function(a, b, c, d, f) {
                this.workspace_ = a;
                this.pair_ = c || !1;
                this.horizontal_ = b;
                this.margin_ = void 0 !== f ? f : L.Scrollbar.DEFAULT_SCROLLBAR_MARGIN;
                this.ratio = this.oldHostMetrics_ = null;
                this.createDom_(d);
                this.position = new J(0,0);
                a = L.Scrollbar.scrollbarThickness;
                b ? (this.svgBackground_.setAttribute("height", a),
                this.outerSvg_.setAttribute("height", a),
                this.svgHandle_.setAttribute("height", a - 5),
                this.svgHandle_.setAttribute("y", 2.5),
                this.lengthAttribute_ = "width",
                this.positionAttribute_ = "x") : (this.svgBackground_.setAttribute("width", a),
                this.outerSvg_.setAttribute("width", a),
                this.svgHandle_.setAttribute("width", a - 5),
                this.svgHandle_.setAttribute("x", 2.5),
                this.lengthAttribute_ = "height",
                this.positionAttribute_ = "y");
                this.onMouseDownBarWrapper_ = (0,
                y.conditionalBind)(this.svgBackground_, "mousedown", this, this.onMouseDownBar_);
                this.onMouseDownHandleWrapper_ = (0,
                y.conditionalBind)(this.svgHandle_, "mousedown", this, this.onMouseDownHandle_)
            }
        };
        L.Scrollbar.prototype.origin_ = new J(0,0);
        L.Scrollbar.prototype.startDragMouse_ = 0;
        L.Scrollbar.prototype.scrollbarLength_ = 0;
        L.Scrollbar.prototype.handleLength_ = 0;
        L.Scrollbar.prototype.handlePosition_ = 0;
        L.Scrollbar.prototype.isVisible_ = !0;
        L.Scrollbar.prototype.containerVisible_ = !0;
        L.Scrollbar.scrollbarThickness = 15;
        O.TOUCH_ENABLED && (L.Scrollbar.scrollbarThickness = 25);
        L.Scrollbar.DEFAULT_SCROLLBAR_MARGIN = .5;
        L.Scrollbar.metricsAreEquivalent_ = function(a, b) {
            return a.viewWidth === b.viewWidth && a.viewHeight === b.viewHeight && a.viewLeft === b.viewLeft && a.viewTop === b.viewTop && a.absoluteTop === b.absoluteTop && a.absoluteLeft === b.absoluteLeft && a.scrollWidth === b.scrollWidth && a.scrollHeight === b.scrollHeight && a.scrollLeft === b.scrollLeft && a.scrollTop === b.scrollTop
        }
        ;
        L.Scrollbar.prototype.dispose = function() {
            this.cleanUp_();
            (0,
            y.unbind)(this.onMouseDownBarWrapper_);
            this.onMouseDownBarWrapper_ = null;
            (0,
            y.unbind)(this.onMouseDownHandleWrapper_);
            this.onMouseDownHandleWrapper_ = null;
            (0,
            n.removeNode)(this.outerSvg_);
            this.svgBackground_ = this.svgGroup_ = this.outerSvg_ = null;
            this.svgHandle_ && (this.workspace_.getThemeManager().unsubscribe(this.svgHandle_),
            this.svgHandle_ = null);
            this.workspace_ = null
        }
        ;
        L.Scrollbar.prototype.constrainHandleLength_ = function(a) {
            return 0 >= a || isNaN(a) ? 0 : Math.min(a, this.scrollbarLength_)
        }
        ;
        L.Scrollbar.prototype.setHandleLength_ = function(a) {
            this.handleLength_ = a;
            this.svgHandle_.setAttribute(this.lengthAttribute_, this.handleLength_)
        }
        ;
        L.Scrollbar.prototype.constrainHandlePosition_ = function(a) {
            return 0 >= a || isNaN(a) ? 0 : Math.min(a, this.scrollbarLength_ - this.handleLength_)
        }
        ;
        L.Scrollbar.prototype.setHandlePosition = function(a) {
            this.handlePosition_ = a;
            this.svgHandle_.setAttribute(this.positionAttribute_, this.handlePosition_)
        }
        ;
        L.Scrollbar.prototype.setScrollbarLength_ = function(a) {
            this.scrollbarLength_ = a;
            this.outerSvg_.setAttribute(this.lengthAttribute_, this.scrollbarLength_);
            this.svgBackground_.setAttribute(this.lengthAttribute_, this.scrollbarLength_)
        }
        ;
        L.Scrollbar.prototype.setPosition = function(a, b) {
            this.position.x = a;
            this.position.y = b;
            (0,
            n.setCssTransform)(this.outerSvg_, "translate(" + (this.position.x + this.origin_.x) + "px," + (this.position.y + this.origin_.y) + "px)")
        }
        ;
        L.Scrollbar.prototype.resize = function(a) {
            if (a || (a = this.workspace_.getMetrics(),
            a))
                this.oldHostMetrics_ && L.Scrollbar.metricsAreEquivalent_(a, this.oldHostMetrics_) || (this.horizontal_ ? this.resizeHorizontal_(a) : this.resizeVertical_(a),
                this.oldHostMetrics_ = a,
                this.updateMetrics_())
        }
        ;
        L.Scrollbar.prototype.requiresViewResize_ = function(a) {
            return this.oldHostMetrics_ ? this.oldHostMetrics_.viewWidth !== a.viewWidth || this.oldHostMetrics_.viewHeight !== a.viewHeight || this.oldHostMetrics_.absoluteLeft !== a.absoluteLeft || this.oldHostMetrics_.absoluteTop !== a.absoluteTop : !0
        }
        ;
        L.Scrollbar.prototype.resizeHorizontal_ = function(a) {
            this.requiresViewResize_(a) ? this.resizeViewHorizontal(a) : this.resizeContentHorizontal(a)
        }
        ;
        L.Scrollbar.prototype.resizeViewHorizontal = function(a) {
            var b = a.viewWidth - 2 * this.margin_;
            this.pair_ && (b -= L.Scrollbar.scrollbarThickness);
            this.setScrollbarLength_(Math.max(0, b));
            b = a.absoluteLeft + this.margin_;
            this.pair_ && this.workspace_.RTL && (b += L.Scrollbar.scrollbarThickness);
            this.setPosition(b, a.absoluteTop + a.viewHeight - L.Scrollbar.scrollbarThickness - this.margin_);
            this.resizeContentHorizontal(a)
        }
        ;
        L.Scrollbar.prototype.resizeContentHorizontal = function(a) {
            if (a.viewWidth >= a.scrollWidth)
                this.setHandleLength_(this.scrollbarLength_),
                this.setHandlePosition(0),
                this.pair_ || this.setVisible(!1);
            else {
                this.pair_ || this.setVisible(!0);
                var b = this.scrollbarLength_ * a.viewWidth / a.scrollWidth;
                b = this.constrainHandleLength_(b);
                this.setHandleLength_(b);
                b = a.scrollWidth - a.viewWidth;
                var c = this.scrollbarLength_ - this.handleLength_;
                a = (a.viewLeft - a.scrollLeft) / b * c;
                a = this.constrainHandlePosition_(a);
                this.setHandlePosition(a);
                this.ratio = c / b
            }
        }
        ;
        L.Scrollbar.prototype.resizeVertical_ = function(a) {
            this.requiresViewResize_(a) ? this.resizeViewVertical(a) : this.resizeContentVertical(a)
        }
        ;
        L.Scrollbar.prototype.resizeViewVertical = function(a) {
            var b = a.viewHeight - 2 * this.margin_;
            this.pair_ && (b -= L.Scrollbar.scrollbarThickness);
            this.setScrollbarLength_(Math.max(0, b));
            this.setPosition(this.workspace_.RTL ? a.absoluteLeft + this.margin_ : a.absoluteLeft + a.viewWidth - L.Scrollbar.scrollbarThickness - this.margin_, a.absoluteTop + this.margin_);
            this.resizeContentVertical(a)
        }
        ;
        L.Scrollbar.prototype.resizeContentVertical = function(a) {
            if (a.viewHeight >= a.scrollHeight)
                this.setHandleLength_(this.scrollbarLength_),
                this.setHandlePosition(0),
                this.pair_ || this.setVisible(!1);
            else {
                this.pair_ || this.setVisible(!0);
                var b = this.scrollbarLength_ * a.viewHeight / a.scrollHeight;
                b = this.constrainHandleLength_(b);
                this.setHandleLength_(b);
                b = a.scrollHeight - a.viewHeight;
                var c = this.scrollbarLength_ - this.handleLength_;
                a = (a.viewTop - a.scrollTop) / b * c;
                a = this.constrainHandlePosition_(a);
                this.setHandlePosition(a);
                this.ratio = c / b
            }
        }
        ;
        L.Scrollbar.prototype.createDom_ = function(a) {
            var b = "blocklyScrollbar" + (this.horizontal_ ? "Horizontal" : "Vertical");
            a && (b += " " + a);
            this.outerSvg_ = (0,
            n.createSvgElement)(u.SVG, {
                "class": b
            }, null);
            this.svgGroup_ = (0,
            n.createSvgElement)(u.G, {}, this.outerSvg_);
            this.svgBackground_ = (0,
            n.createSvgElement)(u.RECT, {
                "class": "blocklyScrollbarBackground"
            }, this.svgGroup_);
            a = Math.floor((L.Scrollbar.scrollbarThickness - 5) / 2);
            this.svgHandle_ = (0,
            n.createSvgElement)(u.RECT, {
                "class": "blocklyScrollbarHandle",
                rx: a,
                ry: a
            }, this.svgGroup_);
            this.workspace_.getThemeManager().subscribe(this.svgHandle_, "scrollbarColour", "fill");
            this.workspace_.getThemeManager().subscribe(this.svgHandle_, "scrollbarOpacity", "fill-opacity");
            (0,
            n.insertAfter)(this.outerSvg_, this.workspace_.getParentSvg())
        }
        ;
        L.Scrollbar.prototype.isVisible = function() {
            return this.isVisible_
        }
        ;
        L.Scrollbar.prototype.setContainerVisible = function(a) {
            var b = a !== this.containerVisible_;
            this.containerVisible_ = a;
            b && this.updateDisplay_()
        }
        ;
        L.Scrollbar.prototype.setVisible = function(a) {
            var b = a !== this.isVisible();
            if (this.pair_)
                throw Error("Unable to toggle visibility of paired scrollbars.");
            this.isVisible_ = a;
            b && this.updateDisplay_()
        }
        ;
        L.Scrollbar.prototype.updateDisplay_ = function() {
            this.containerVisible_ && this.isVisible() ? this.outerSvg_.setAttribute("display", "block") : this.outerSvg_.setAttribute("display", "none")
        }
        ;
        L.Scrollbar.prototype.onMouseDownBar_ = function(a) {
            this.workspace_.markFocused();
            (0,
            O.clearTouchIdentifier)();
            this.cleanUp_();
            if ((0,
            y.isRightButton)(a))
                a.stopPropagation();
            else {
                var b = (0,
                y.mouseToSvg)(a, this.workspace_.getParentSvg(), this.workspace_.getInverseScreenCTM());
                b = this.horizontal_ ? b.x : b.y;
                var c = (0,
                ja.getInjectionDivXY)(this.svgHandle_);
                c = this.horizontal_ ? c.x : c.y;
                var d = this.handlePosition_
                  , f = .95 * this.handleLength_;
                b <= c ? d -= f : b >= c + this.handleLength_ && (d += f);
                this.setHandlePosition(this.constrainHandlePosition_(d));
                this.updateMetrics_();
                a.stopPropagation();
                a.preventDefault()
            }
        }
        ;
        L.Scrollbar.prototype.onMouseDownHandle_ = function(a) {
            this.workspace_.markFocused();
            this.cleanUp_();
            (0,
            y.isRightButton)(a) ? a.stopPropagation() : (this.startDragHandle = this.handlePosition_,
            this.workspace_.setupDragSurface(),
            this.startDragMouse_ = this.horizontal_ ? a.clientX : a.clientY,
            L.Scrollbar.onMouseUpWrapper_ = (0,
            y.conditionalBind)(document, "mouseup", this, this.onMouseUpHandle_),
            L.Scrollbar.onMouseMoveWrapper_ = (0,
            y.conditionalBind)(document, "mousemove", this, this.onMouseMoveHandle_),
            a.stopPropagation(),
            a.preventDefault())
        }
        ;
        L.Scrollbar.prototype.onMouseMoveHandle_ = function(a) {
            this.setHandlePosition(this.constrainHandlePosition_(this.startDragHandle + ((this.horizontal_ ? a.clientX : a.clientY) - this.startDragMouse_)));
            this.updateMetrics_()
        }
        ;
        L.Scrollbar.prototype.onMouseUpHandle_ = function() {
            this.workspace_.resetDragSurface();
            (0,
            O.clearTouchIdentifier)();
            this.cleanUp_()
        }
        ;
        L.Scrollbar.prototype.cleanUp_ = function() {
            this.workspace_.hideChaff(!0);
            L.Scrollbar.onMouseUpWrapper_ && ((0,
            y.unbind)(L.Scrollbar.onMouseUpWrapper_),
            L.Scrollbar.onMouseUpWrapper_ = null);
            L.Scrollbar.onMouseMoveWrapper_ && ((0,
            y.unbind)(L.Scrollbar.onMouseMoveWrapper_),
            L.Scrollbar.onMouseMoveWrapper_ = null)
        }
        ;
        L.Scrollbar.prototype.getRatio_ = function() {
            var a = this.handlePosition_ / (this.scrollbarLength_ - this.handleLength_);
            isNaN(a) && (a = 0);
            return a
        }
        ;
        L.Scrollbar.prototype.updateMetrics_ = function() {
            var a = this.getRatio_()
              , b = {};
            this.horizontal_ ? b.x = a : b.y = a;
            this.workspace_.setMetrics(b)
        }
        ;
        L.Scrollbar.prototype.set = function(a, b) {
            this.setHandlePosition(this.constrainHandlePosition_(a * this.ratio));
            (b || void 0 === b) && this.updateMetrics_()
        }
        ;
        L.Scrollbar.prototype.setOrigin = function(a, b) {
            this.origin_ = new J(a,b)
        }
        ;
        var ob = function(a, b, c, d, f) {
            this.workspace_ = a;
            b = void 0 === b ? !0 : b;
            c = void 0 === c ? !0 : c;
            var g = b && c;
            b && (this.hScroll = new L.Scrollbar(a,!0,g,d,f));
            c && (this.vScroll = new L.Scrollbar(a,!1,g,d,f));
            g && (this.corner_ = (0,
            n.createSvgElement)(u.RECT, {
                height: L.Scrollbar.scrollbarThickness,
                width: L.Scrollbar.scrollbarThickness,
                "class": "blocklyScrollbarBackground"
            }, null),
            (0,
            n.insertAfter)(this.corner_, a.getBubbleCanvas()));
            this.oldHostMetrics_ = null
        };
        ob.prototype.dispose = function() {
            (0,
            n.removeNode)(this.corner_);
            this.oldHostMetrics_ = this.workspace_ = this.corner_ = null;
            this.hScroll && (this.hScroll.dispose(),
            this.hScroll = null);
            this.vScroll && (this.vScroll.dispose(),
            this.vScroll = null)
        }
        ;
        ob.prototype.resize = function() {
            var a = this.workspace_.getMetrics();
            if (a) {
                var b = !1
                  , c = !1;
                this.oldHostMetrics_ && this.oldHostMetrics_.viewWidth === a.viewWidth && this.oldHostMetrics_.viewHeight === a.viewHeight && this.oldHostMetrics_.absoluteTop === a.absoluteTop && this.oldHostMetrics_.absoluteLeft === a.absoluteLeft ? (this.oldHostMetrics_ && this.oldHostMetrics_.scrollWidth === a.scrollWidth && this.oldHostMetrics_.viewLeft === a.viewLeft && this.oldHostMetrics_.scrollLeft === a.scrollLeft || (b = !0),
                this.oldHostMetrics_ && this.oldHostMetrics_.scrollHeight === a.scrollHeight && this.oldHostMetrics_.viewTop === a.viewTop && this.oldHostMetrics_.scrollTop === a.scrollTop || (c = !0)) : c = b = !0;
                if (b || c) {
                    try {
                        (0,
                        k.disable)(),
                        this.hScroll && b && this.hScroll.resize(a),
                        this.vScroll && c && this.vScroll.resize(a)
                    } finally {
                        (0,
                        k.enable)()
                    }
                    this.workspace_.maybeFireViewportChangeEvent()
                }
                this.hScroll && this.vScroll && (this.oldHostMetrics_ && this.oldHostMetrics_.viewWidth === a.viewWidth && this.oldHostMetrics_.absoluteLeft === a.absoluteLeft || this.corner_.setAttribute("x", this.vScroll.position.x),
                this.oldHostMetrics_ && this.oldHostMetrics_.viewHeight === a.viewHeight && this.oldHostMetrics_.absoluteTop === a.absoluteTop || this.corner_.setAttribute("y", this.hScroll.position.y));
                this.oldHostMetrics_ = a
            }
        }
        ;
        ob.prototype.canScrollHorizontally = function() {
            return !!this.hScroll
        }
        ;
        ob.prototype.canScrollVertically = function() {
            return !!this.vScroll
        }
        ;
        ob.prototype.setOrigin = function(a, b) {
            this.hScroll && this.hScroll.setOrigin(a, b);
            this.vScroll && this.vScroll.setOrigin(a, b)
        }
        ;
        ob.prototype.set = function(a, b, c) {
            this.hScroll && this.hScroll.set(a, !1);
            this.vScroll && this.vScroll.set(b, !1);
            if (c || void 0 === c)
                a = {},
                this.hScroll && (a.x = this.hScroll.getRatio_()),
                this.vScroll && (a.y = this.vScroll.getRatio_()),
                this.workspace_.setMetrics(a)
        }
        ;
        ob.prototype.setX = function(a) {
            this.hScroll && this.hScroll.set(a, !0)
        }
        ;
        ob.prototype.setY = function(a) {
            this.vScroll && this.vScroll.set(a, !0)
        }
        ;
        ob.prototype.setContainerVisible = function(a) {
            this.hScroll && this.hScroll.setContainerVisible(a);
            this.vScroll && this.vScroll.setContainerVisible(a)
        }
        ;
        ob.prototype.isVisible = function() {
            var a = !1;
            this.hScroll && (a = this.hScroll.isVisible());
            this.vScroll && (a = a || this.vScroll.isVisible());
            return a
        }
        ;
        ob.prototype.resizeContent = function(a) {
            this.hScroll && this.hScroll.resizeContentHorizontal(a);
            this.vScroll && this.vScroll.resizeContentVertical(a)
        }
        ;
        ob.prototype.resizeView = function(a) {
            this.hScroll && this.hScroll.resizeViewHorizontal(a);
            this.vScroll && this.vScroll.resizeViewVertical(a)
        }
        ;
        var M = {
            WIN_KEY_FF_LINUX: 0,
            MAC_ENTER: 3,
            BACKSPACE: 8,
            TAB: 9,
            NUM_CENTER: 12,
            ENTER: 13,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAUSE: 19,
            CAPS_LOCK: 20,
            ESC: 27,
            SPACE: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            PLUS_SIGN: 43,
            PRINT_SCREEN: 44,
            INSERT: 45,
            DELETE: 46,
            ZERO: 48,
            ONE: 49,
            TWO: 50,
            THREE: 51,
            FOUR: 52,
            FIVE: 53,
            SIX: 54,
            SEVEN: 55,
            EIGHT: 56,
            NINE: 57,
            FF_SEMICOLON: 59,
            FF_EQUALS: 61,
            FF_DASH: 173,
            FF_HASH: 163,
            QUESTION_MARK: 63,
            AT_SIGN: 64,
            A: 65,
            B: 66,
            C: 67,
            D: 68,
            E: 69,
            F: 70,
            G: 71,
            H: 72,
            I: 73,
            J: 74,
            K: 75,
            L: 76,
            M: 77,
            N: 78,
            O: 79,
            P: 80,
            Q: 81,
            R: 82,
            S: 83,
            T: 84,
            U: 85,
            V: 86,
            W: 87,
            X: 88,
            Y: 89,
            Z: 90,
            META: 91,
            WIN_KEY_RIGHT: 92,
            CONTEXT_MENU: 93,
            NUM_ZERO: 96,
            NUM_ONE: 97,
            NUM_TWO: 98,
            NUM_THREE: 99,
            NUM_FOUR: 100,
            NUM_FIVE: 101,
            NUM_SIX: 102,
            NUM_SEVEN: 103,
            NUM_EIGHT: 104,
            NUM_NINE: 105,
            NUM_MULTIPLY: 106,
            NUM_PLUS: 107,
            NUM_MINUS: 109,
            NUM_PERIOD: 110,
            NUM_DIVISION: 111,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            NUMLOCK: 144,
            SCROLL_LOCK: 145,
            FIRST_MEDIA_KEY: 166,
            LAST_MEDIA_KEY: 183,
            SEMICOLON: 186,
            DASH: 189,
            EQUALS: 187,
            COMMA: 188,
            PERIOD: 190,
            SLASH: 191,
            APOSTROPHE: 192,
            TILDE: 192,
            SINGLE_QUOTE: 222,
            OPEN_SQUARE_BRACKET: 219,
            BACKSLASH: 220,
            CLOSE_SQUARE_BRACKET: 221,
            WIN_KEY: 224,
            MAC_FF_META: 224,
            MAC_WK_CMD_LEFT: 91,
            MAC_WK_CMD_RIGHT: 93,
            WIN_IME: 229,
            VK_NONAME: 252,
            PHANTOM: 255
        }
          , R = {
            ShortcutRegistry: function() {
                R.ShortcutRegistry.registry = this;
                this.registry_ = Object.create(null);
                this.keyMap_ = Object.create(null)
            }
        };
        R.ShortcutRegistry.modifierKeys = {
            Shift: M.SHIFT,
            Control: M.CTRL,
            Alt: M.ALT,
            Meta: M.META
        };
        R.ShortcutRegistry.prototype.register = function(a, b) {
            if (this.registry_[a.name] && !b)
                throw Error('Shortcut with name "' + a.name + '" already exists.');
            this.registry_[a.name] = a
        }
        ;
        R.ShortcutRegistry.prototype.unregister = function(a) {
            if (!this.registry_[a])
                return console.warn('Keyboard shortcut with name "' + a + '" not found.'),
                !1;
            this.removeAllKeyMappings(a);
            delete this.registry_[a];
            return !0
        }
        ;
        R.ShortcutRegistry.prototype.addKeyMapping = function(a, b, c) {
            a = String(a);
            var d = this.keyMap_[a];
            if (d && !c)
                throw Error('Shortcut with name "' + b + '" collides with shortcuts ' + d.toString());
            d && c ? d.unshift(b) : this.keyMap_[a] = [b]
        }
        ;
        R.ShortcutRegistry.prototype.removeKeyMapping = function(a, b, c) {
            var d = this.keyMap_[a];
            if (!d && !c)
                return console.warn('No keyboard shortcut with name "' + b + '" registered with key code "' + a + '"'),
                !1;
            var f = d.indexOf(b);
            if (-1 < f)
                return d.splice(f, 1),
                0 === d.length && delete this.keyMap_[a],
                !0;
            c || console.warn('No keyboard shortcut with name "' + b + '" registered with key code "' + a + '"');
            return !1
        }
        ;
        R.ShortcutRegistry.prototype.removeAllKeyMappings = function(a) {
            for (var b in this.keyMap_)
                this.removeKeyMapping(b, a, !0)
        }
        ;
        R.ShortcutRegistry.prototype.setKeyMap = function(a) {
            this.keyMap_ = a
        }
        ;
        R.ShortcutRegistry.prototype.getKeyMap = function() {
            return (0,
            e.module$exports$Blockly$utils$object.deepMerge)(Object.create(null), this.keyMap_)
        }
        ;
        R.ShortcutRegistry.prototype.getRegistry = function() {
            return (0,
            e.module$exports$Blockly$utils$object.deepMerge)(Object.create(null), this.registry_)
        }
        ;
        R.ShortcutRegistry.prototype.onKeyDown = function(a, b) {
            var c = this.serializeKeyEvent_(b);
            c = this.getShortcutNamesByKeyCode(c);
            if (!c)
                return !1;
            for (var d = 0, f; f = c[d]; d++)
                if (f = this.registry_[f],
                (!f.preconditionFn || f.preconditionFn(a)) && f.callback && f.callback(a, b, f))
                    return !0;
            return !1
        }
        ;
        R.ShortcutRegistry.prototype.getShortcutNamesByKeyCode = function(a) {
            return this.keyMap_[a] || []
        }
        ;
        R.ShortcutRegistry.prototype.getKeyCodesByShortcutName = function(a) {
            var b = [], c;
            for (c in this.keyMap_)
                -1 < this.keyMap_[c].indexOf(a) && b.push(c);
            return b
        }
        ;
        R.ShortcutRegistry.prototype.serializeKeyEvent_ = function(a) {
            var b = "", c;
            for (c in R.ShortcutRegistry.modifierKeys)
                a.getModifierState(c) && ("" !== b && (b += "+"),
                b += c);
            "" !== b && a.keyCode ? b = b + "+" + a.keyCode : a.keyCode && (b = a.keyCode.toString());
            return b
        }
        ;
        R.ShortcutRegistry.prototype.checkModifiers_ = function(a) {
            for (var b = (0,
            e.module$exports$Blockly$utils$object.values)(R.ShortcutRegistry.modifierKeys), c = 0, d; d = a[c]; c++)
                if (0 > b.indexOf(d))
                    throw Error(d + " is not a valid modifier key.");
        }
        ;
        R.ShortcutRegistry.prototype.createSerializedKey = function(a, b) {
            var c = "";
            if (b) {
                this.checkModifiers_(b);
                for (var d in R.ShortcutRegistry.modifierKeys)
                    -1 < b.indexOf(R.ShortcutRegistry.modifierKeys[d]) && ("" !== c && (c += "+"),
                    c += d)
            }
            "" !== c && a ? c = c + "+" + a : a && (c = a.toString());
            return c
        }
        ;
        new R.ShortcutRegistry;
        var jc = function(a) {
            this.container_ = a;
            this.createDom()
        };
        jc.prototype.SVG_ = null;
        jc.prototype.container_ = null;
        jc.prototype.createDom = function() {
            this.SVG_ || (this.SVG_ = (0,
            n.createSvgElement)(u.SVG, {
                xmlns: n.SVG_NS,
                "xmlns:html": n.HTML_NS,
                "xmlns:xlink": n.XLINK_NS,
                version: "1.1",
                "class": "blocklyWsDragSurface blocklyOverflowVisible"
            }, null),
            this.container_.appendChild(this.SVG_))
        }
        ;
        jc.prototype.translateSurface = function(a, b) {
            a = a.toFixed(0);
            b = b.toFixed(0);
            this.SVG_.style.display = "block";
            (0,
            n.setCssTransform)(this.SVG_, "translate3d(" + a + "px, " + b + "px, 0)")
        }
        ;
        jc.prototype.getSurfaceTranslation = function() {
            return (0,
            ja.getRelativeXY)(this.SVG_)
        }
        ;
        jc.prototype.clearAndHide = function(a) {
            if (!a)
                throw Error("Couldn't clear and hide the drag surface: missing new surface.");
            var b = this.SVG_.childNodes[0]
              , c = this.SVG_.childNodes[1];
            if (!(b && c && (0,
            n.hasClass)(b, "blocklyBlockCanvas") && (0,
            n.hasClass)(c, "blocklyBubbleCanvas")))
                throw Error("Couldn't clear and hide the drag surface. A node was missing.");
            null !== this.previousSibling_ ? (0,
            n.insertAfter)(b, this.previousSibling_) : a.insertBefore(b, a.firstChild);
            (0,
            n.insertAfter)(c, b);
            this.SVG_.style.display = "none";
            if (this.SVG_.childNodes.length)
                throw Error("Drag surface was not cleared.");
            (0,
            n.setCssTransform)(this.SVG_, "");
            this.previousSibling_ = null
        }
        ;
        jc.prototype.setContentsAndShow = function(a, b, c, d, f, g) {
            if (this.SVG_.childNodes.length)
                throw Error("Already dragging a block.");
            this.previousSibling_ = c;
            a.setAttribute("transform", "translate(0, 0) scale(" + g + ")");
            b.setAttribute("transform", "translate(0, 0) scale(" + g + ")");
            this.SVG_.setAttribute("width", d);
            this.SVG_.setAttribute("height", f);
            this.SVG_.appendChild(a);
            this.SVG_.appendChild(b);
            this.SVG_.style.display = "block"
        }
        ;
        var yb = {}
          , kc = null;
        yb.copy = function(a) {
            kc = a.toCopyData()
        }
        ;
        yb.paste = function() {
            if (!kc)
                return !1;
            var a = kc.source;
            a.isFlyout && (a = a.targetWorkspace);
            return kc.typeCounts && a.isCapacityAvailable(kc.typeCounts) ? ((0,
            k.setGroup)(!0),
            a.paste(kc.saveInfo),
            (0,
            k.setGroup)(!1),
            !0) : !1
        }
        ;
        yb.duplicate = function(a) {
            var b = kc;
            (0,
            yb.copy)(a);
            a.workspace.paste(kc.saveInfo);
            kc = b
        }
        ;
        var eb = function(a, b) {
            this.content_ = a;
            this.value_ = b;
            this.enabled_ = !0;
            this.element_ = null;
            this.rightToLeft_ = !1;
            this.roleName_ = null;
            this.highlight_ = this.checked_ = this.checkable_ = !1;
            this.actionHandler_ = null
        };
        eb.prototype.createDom = function() {
            var a = document.createElement("div");
            a.id = (0,
            bb.getNextUniqueId)();
            this.element_ = a;
            a.className = "blocklyMenuItem goog-menuitem " + (this.enabled_ ? "" : "blocklyMenuItemDisabled goog-menuitem-disabled ") + (this.checked_ ? "blocklyMenuItemSelected goog-option-selected " : "") + (this.highlight_ ? "blocklyMenuItemHighlight goog-menuitem-highlight " : "") + (this.rightToLeft_ ? "blocklyMenuItemRtl goog-menuitem-rtl " : "");
            var b = document.createElement("div");
            b.className = "blocklyMenuItemContent goog-menuitem-content";
            if (this.checkable_) {
                var c = document.createElement("div");
                c.className = "blocklyMenuItemCheckbox goog-menuitem-checkbox";
                b.appendChild(c)
            }
            c = this.content_;
            "string" === typeof this.content_ && (c = document.createTextNode(this.content_));
            b.appendChild(c);
            a.appendChild(b);
            this.roleName_ && (0,
            Q.setRole)(a, this.roleName_);
            (0,
            Q.setState)(a, Q.State.SELECTED, this.checkable_ && this.checked_ || !1);
            (0,
            Q.setState)(a, Q.State.DISABLED, !this.enabled_);
            return a
        }
        ;
        eb.prototype.dispose = function() {
            this.element_ = null
        }
        ;
        eb.prototype.getElement = function() {
            return this.element_
        }
        ;
        eb.prototype.getId = function() {
            return this.element_.id
        }
        ;
        eb.prototype.getValue = function() {
            return this.value_
        }
        ;
        eb.prototype.setRightToLeft = function(a) {
            this.rightToLeft_ = a
        }
        ;
        eb.prototype.setRole = function(a) {
            this.roleName_ = a
        }
        ;
        eb.prototype.setCheckable = function(a) {
            this.checkable_ = a
        }
        ;
        eb.prototype.setChecked = function(a) {
            this.checked_ = a
        }
        ;
        eb.prototype.setHighlighted = function(a) {
            this.highlight_ = a;
            var b = this.getElement();
            b && this.isEnabled() && (a ? ((0,
            n.addClass)(b, "blocklyMenuItemHighlight"),
            (0,
            n.addClass)(b, "goog-menuitem-highlight")) : ((0,
            n.removeClass)(b, "blocklyMenuItemHighlight"),
            (0,
            n.removeClass)(b, "goog-menuitem-highlight")))
        }
        ;
        eb.prototype.isEnabled = function() {
            return this.enabled_
        }
        ;
        eb.prototype.setEnabled = function(a) {
            this.enabled_ = a
        }
        ;
        eb.prototype.performAction = function() {
            this.isEnabled() && this.actionHandler_ && this.actionHandler_(this)
        }
        ;
        eb.prototype.onAction = function(a, b) {
            this.actionHandler_ = a.bind(b)
        }
        ;
        var Ma = function() {
            this.menuItems_ = [];
            this.roleName_ = this.element_ = this.onKeyDownHandler_ = this.mouseLeaveHandler_ = this.mouseEnterHandler_ = this.clickHandler_ = this.mouseOverHandler_ = this.highlightedItem_ = this.openingCoords = null
        };
        Ma.prototype.addChild = function(a) {
            this.menuItems_.push(a)
        }
        ;
        Ma.prototype.render = function(a) {
            var b = document.createElement("div");
            b.className = "blocklyMenu goog-menu blocklyNonSelectable";
            b.tabIndex = 0;
            this.roleName_ && (0,
            Q.setRole)(b, this.roleName_);
            this.element_ = b;
            for (var c = 0, d; d = this.menuItems_[c]; c++)
                b.appendChild(d.createDom());
            this.mouseOverHandler_ = (0,
            y.conditionalBind)(b, "mouseover", this, this.handleMouseOver_, !0);
            this.clickHandler_ = (0,
            y.conditionalBind)(b, "click", this, this.handleClick_, !0);
            this.mouseEnterHandler_ = (0,
            y.conditionalBind)(b, "mouseenter", this, this.handleMouseEnter_, !0);
            this.mouseLeaveHandler_ = (0,
            y.conditionalBind)(b, "mouseleave", this, this.handleMouseLeave_, !0);
            this.onKeyDownHandler_ = (0,
            y.conditionalBind)(b, "keydown", this, this.handleKeyEvent_);
            a.appendChild(b)
        }
        ;
        Ma.prototype.getElement = function() {
            return this.element_
        }
        ;
        Ma.prototype.focus = function() {
            var a = this.getElement();
            a && (a.focus({
                preventScroll: !0
            }),
            (0,
            n.addClass)(a, "blocklyFocused"))
        }
        ;
        Ma.prototype.blur_ = function() {
            var a = this.getElement();
            a && (a.blur(),
            (0,
            n.removeClass)(a, "blocklyFocused"))
        }
        ;
        Ma.prototype.setRole = function(a) {
            this.roleName_ = a
        }
        ;
        Ma.prototype.dispose = function() {
            this.mouseOverHandler_ && ((0,
            y.unbind)(this.mouseOverHandler_),
            this.mouseOverHandler_ = null);
            this.clickHandler_ && ((0,
            y.unbind)(this.clickHandler_),
            this.clickHandler_ = null);
            this.mouseEnterHandler_ && ((0,
            y.unbind)(this.mouseEnterHandler_),
            this.mouseEnterHandler_ = null);
            this.mouseLeaveHandler_ && ((0,
            y.unbind)(this.mouseLeaveHandler_),
            this.mouseLeaveHandler_ = null);
            this.onKeyDownHandler_ && ((0,
            y.unbind)(this.onKeyDownHandler_),
            this.onKeyDownHandler_ = null);
            for (var a = 0, b; b = this.menuItems_[a]; a++)
                b.dispose();
            this.element_ = null
        }
        ;
        Ma.prototype.getMenuItem_ = function(a) {
            for (var b = this.getElement(); a && a !== b; ) {
                if ((0,
                n.hasClass)(a, "blocklyMenuItem"))
                    for (var c = 0, d; d = this.menuItems_[c]; c++)
                        if (d.getElement() === a)
                            return d;
                a = a.parentElement
            }
            return null
        }
        ;
        Ma.prototype.setHighlighted = function(a) {
            var b = this.highlightedItem_;
            b && (b.setHighlighted(!1),
            this.highlightedItem_ = null);
            a && (a.setHighlighted(!0),
            this.highlightedItem_ = a,
            b = this.getElement(),
            (0,
            ta.scrollIntoContainerView)(a.getElement(), b),
            (0,
            Q.setState)(b, Q.State.ACTIVEDESCENDANT, a.getId()))
        }
        ;
        Ma.prototype.highlightNext = function() {
            var a = this.menuItems_.indexOf(this.highlightedItem_);
            this.highlightHelper_(a, 1)
        }
        ;
        Ma.prototype.highlightPrevious = function() {
            var a = this.menuItems_.indexOf(this.highlightedItem_);
            this.highlightHelper_(0 > a ? this.menuItems_.length : a, -1)
        }
        ;
        Ma.prototype.highlightFirst_ = function() {
            this.highlightHelper_(-1, 1)
        }
        ;
        Ma.prototype.highlightLast_ = function() {
            this.highlightHelper_(this.menuItems_.length, -1)
        }
        ;
        Ma.prototype.highlightHelper_ = function(a, b) {
            a += b; 
            for (var c; c = this.menuItems_[a]; ) {
                if (c.isEnabled()) {
                    this.setHighlighted(c);
                    break
                }
                a += b
            }
        }
        ;
        Ma.prototype.handleMouseOver_ = function(a) {
            (a = this.getMenuItem_(a.target)) && (a.isEnabled() ? this.highlightedItem_ !== a && this.setHighlighted(a) : this.setHighlighted(null))
        }
        ;
        Ma.prototype.handleClick_ = function(a) {
            var b = this.openingCoords;
            this.openingCoords = null;
            if (b && "number" === typeof a.clientX) {
                var c = new J(a.clientX,a.clientY);
                if (1 > J.distance(b, c))
                    return
            }
            (a = this.getMenuItem_(a.target)) && a.performAction()
        }
        ;
        Ma.prototype.handleMouseEnter_ = function(a) {
            this.focus()
        }
        ;
        Ma.prototype.handleMouseLeave_ = function(a) {
            this.getElement() && (this.blur_(),
            this.setHighlighted(null))
        }
        ;
        Ma.prototype.handleKeyEvent_ = function(a) {
            if (this.menuItems_.length && !(a.shiftKey || a.ctrlKey || a.metaKey || a.altKey)) {
                var b = this.highlightedItem_;
                switch (a.keyCode) {
                case M.ENTER:
                case M.SPACE:
                    b && b.performAction();
                    break;
                case M.UP:
                    this.highlightPrevious();
                    break;
                case M.DOWN:
                    this.highlightNext();
                    break;
                case M.PAGE_UP:
                case M.HOME:
                    this.highlightFirst_();
                    break;
                case M.PAGE_DOWN:
                case M.END:
                    this.highlightLast_();
                    break;
                default:
                    return
                }
                a.preventDefault();
                a.stopPropagation()
            }
        }
        ;
        Ma.prototype.getSize = function() {
            var a = this.getElement()
              , b = (0,
            ta.getSize)(a);
            b.height = a.scrollHeight;
            return b
        }
        ;
        var Xd = {
            VARIABLES: 100,
            BLOCKS: 50
        }
          , Yd = {
            register: function(a, b) {
                (0,
                w.register)(w.Type.SERIALIZER, a, b)
            },
            unregister: function(a) {
                (0,
                w.unregister)(w.Type.SERIALIZER, a)
            }
        }
          , Ba = {
            DeserializationError: function() {
                var a = Error.apply(this, arguments);
                this.message = a.message;
                "stack"in a && (this.stack = a.stack)
            }
        };
        z.inherits(Ba.DeserializationError, Error);
        Ba.MissingBlockType = function(a) {
            Ba.DeserializationError.call(this, "Expected to find a 'type' property, defining the block type");
            this.state = a
        }
        ;
        z.inherits(Ba.MissingBlockType, Ba.DeserializationError);
        Ba.MissingConnection = function(a, b, c) {
            Ba.DeserializationError.call(this, "The block " + b.toDevString() + " is missing a(n) " + a + "\nconnection");
            this.block = b;
            this.state = c
        }
        ;
        z.inherits(Ba.MissingConnection, Ba.DeserializationError);
        Ba.BadConnectionCheck = function(a, b, c, d) {
            Ba.DeserializationError.call(this, "The block " + c.toDevString() + " could not connect its\n" + b + " to its parent, because: " + a);
            this.childBlock = c;
            this.childState = d
        }
        ;
        z.inherits(Ba.BadConnectionCheck, Ba.DeserializationError);
        Ba.RealChildOfShadow = function(a) {
            Ba.DeserializationError.call(this, "Encountered a real block which is defined as a child of a shadow\nblock. It is an invariant of Blockly that shadow blocks only have shadow\nchildren");
            this.state = a
        }
        ;
        z.inherits(Ba.RealChildOfShadow, Ba.DeserializationError);
        var vd = function() {};
        vd.prototype.save = function(a) {}
        ;
        vd.prototype.load = function(a, b) {}
        ;
        vd.prototype.clear = function(a) {}
        ;
        var Ya = {
            save: function(a, b) {
                var c = void 0 === b ? {} : b;
                b = void 0 === c.addCoordinates ? !1 : c.addCoordinates;
                var d = void 0 === c.addInputBlocks ? !0 : c.addInputBlocks
                  , f = void 0 === c.addNextBlocks ? !0 : c.addNextBlocks;
                c = void 0 === c.doFullSerialization ? !0 : c.doFullSerialization;
                if (a.isInsertionMarker())
                    return null;
                var g = {
                    type: a.type,
                    id: a.id
                };
                if (b) {
                    b = a;
                    var m = b.workspace;
                    b = b.getRelativeToSurfaceXY();
                    g.x = Math.round(m.RTL ? m.getWidth() - b.x : b.x);
                    g.y = Math.round(b.y)
                }
                a.isCollapsed() && (g.collapsed = !0);
                a.isEnabled() || (g.enabled = !1);
                void 0 !== a.inputsInline && a.inputsInline !== a.inputsInlineDefault && (g.inline = a.inputsInline);
                a.data && (g.data = a.data);
                b = a;
                b.saveExtraState ? (b = b.saveExtraState(),
                null !== b && (g.extraState = b)) : b.mutationToDom && (b = b.mutationToDom(),
                null !== b && (g.extraState = (0,
                e.module$exports$Blockly$Xml.domToText)(b).replace(' xmlns="https://developers.google.com/blockly/xml"', "")));
                a.getCommentText() && (g.icons = {
                    comment: {
                        text: a.getCommentText(),
                        pinned: a.commentModel.pinned,
                        height: Math.round(a.commentModel.size.height),
                        width: Math.round(a.commentModel.size.width)
                    }
                });
                b = c;
                m = Object.create(null);
                for (var r = 0; r < a.inputList.length; r++)
                    for (var B = a.inputList[r], G = 0; G < B.fieldRow.length; G++) {
                        var W = B.fieldRow[G];
                        W.isSerializable() && (m[W.name] = W.saveState(b))
                    }
                Object.keys(m).length && (g.fields = m);
                if (d) {
                    d = c;
                    b = Object.create(null);
                    for (m = 0; m < a.inputList.length; m++)
                        r = a.inputList[m],
                        r.type !== e.module$exports$Blockly$inputTypes.inputTypes.DUMMY && (B = De(r.connection, d)) && (b[r.name] = B);
                    Object.keys(b).length && (g.inputs = b)
                }
                f && a.nextConnection && (a = De(a.nextConnection, c)) && (g.next = a);
                return g
            }
        }
          , De = function(a, b) {
            var c = a.getShadowState(!0);
            a = a.targetBlock();
            if (!c && !a)
                return null;
            var d = Object.create(null);
            c && (d.shadow = c);
            a && !a.isShadow() && (d.block = (0,
            Ya.save)(a, {
                doFullSerialization: b
            }));
            return d
        };
        Ya.append = function(a, b, c) {
            c = void 0 === c ? {} : c;
            return (0,
            Ya.appendInternal)(a, b, {
                recordUndo: void 0 === c.recordUndo ? !1 : c.recordUndo
            })
        }
        ;
        Ya.appendInternal = function(a, b, c) {
            var d = void 0 === c ? {} : c;
            c = void 0 === d.parentConnection ? void 0 : d.parentConnection;
            var f = void 0 === d.isShadow ? !1 : d.isShadow
              , g = void 0 === d.recordUndo ? !1 : d.recordUndo;
            d = (0,
            k.getRecordUndo)();
            (0,
            k.setRecordUndo)(g);
            (g = (0,
            k.getGroup)()) || (0,
            k.setGroup)(!0);
            (0,
            k.disable)();
            var m = Ee(a, b, {
                parentConnection: c,
                isShadow: f
            });
            (0,
            k.enable)();
            (0,
            k.fire)(new ((0,
            k.get)(k.CREATE))(m));
            (0,
            k.setGroup)(g);
            (0,
            k.setRecordUndo)(d);
            b.rendered && setTimeout(function() {
                m.disposed || m.setConnectionTracking(!0)
            }, 1);
            return m
        }
        ;
        var Ee = function(a, b, c) {
            var d = void 0 === c ? {} : c;
            c = void 0 === d.parentConnection ? void 0 : d.parentConnection;
            d = void 0 === d.isShadow ? !1 : d.isShadow;
            if (!a.type)
                throw new Ba.MissingBlockType(a);
            var f = b.newBlock(a.type, a.id);
            f.setShadow(d);
            d = a;
            var g = void 0 === d.x ? 0 : d.x;
            d = void 0 === d.y ? 0 : d.y;
            var m = f.workspace;
            g = m.RTL ? m.getWidth() - g : g;
            f.moveBy(g, d);
            a.collapsed && f.setCollapsed(!0);
            !1 === a.enabled && f.setEnabled(!1);
            void 0 !== a.inline && f.setInputsInline(a.inline);
            void 0 !== a.data && (f.data = a.data);
            a.extraState && (f.loadExtraState ? f.loadExtraState(a.extraState) : f.domToMutation((0,
            e.module$exports$Blockly$Xml.textToDom)(a.extraState)));
            if (c) {
                if (c.getSourceBlock().isShadow() && !f.isShadow())
                    throw new Ba.RealChildOfShadow(a);
                if (c.type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE) {
                    var r = f.outputConnection;
                    if (!r)
                        throw new Ba.MissingConnection("output",f,a);
                } else if (r = f.previousConnection,
                !r)
                    throw new Ba.MissingConnection("previous",f,a);
                if (!c.connect(r))
                    throw b = f.workspace.connectionChecker,
                    new Ba.BadConnectionCheck(b.getErrorMessage(b.canConnectWithReason(r, c, !1), r, c),c.type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE ? "output connection" : "previous connection",f,a);
            }
            df(f, a);
            if (a.fields)
                for (r = Object.keys(a.fields),
                c = 0; c < r.length; c++)
                    d = r[c],
                    g = a.fields[d],
                    (m = f.getField(d)) ? m.loadState(g) : console.warn("Ignoring non-existant field " + d + " in block " + f.type);
            if (a.inputs)
                for (r = Object.keys(a.inputs),
                c = 0; c < r.length; c++) {
                    d = r[c];
                    g = f.getInput(d);
                    if (!g || !g.connection)
                        throw new Ba.MissingConnection(d,f,a);
                    Fe(g.connection, a.inputs[d])
                }
            if (a.next) {
                if (!f.nextConnection)
                    throw new Ba.MissingConnection("next",f,a);
                Fe(f.nextConnection, a.next)
            }
            b.rendered ? (f.setConnectionTracking(!1),
            f.initSvg(),
            f.render(!1)) : f.initModel();
            return f
        }
          , df = function(a, b) {
            b.icons && (b = b.icons.comment) && (a.setCommentText(b.text),
            a.commentModel.pinned = b.pinned,
            a.commentModel.size = new Pa(b.width,b.height),
            b.pinned && a.getCommentIcon && !a.isInFlyout && setTimeout(function() {
                return a.getCommentIcon().setVisible(!0)
            }, 1))
        }
          , Fe = function(a, b) {
            b.shadow && a.setShadowState(b.shadow);
            b.block && Ee(b.block, a.getSourceBlock().workspace, {
                parentConnection: a
            })
        }
          , ef = Ya.save
          , wd = function() {
            this.priority = Xd.BLOCKS
        };
        wd.prototype.save = function(a) {
            var b = [];
            a = z.makeIterator(a.getTopBlocks(!1));
            for (var c = a.next(); !c.done; c = a.next())
                (c = ef(c.value, {
                    addCoordinates: !0,
                    doFullSerialization: !1
                })) && b.push(c);
            return b.length ? {
                languageVersion: 0,
                blocks: b
            } : null
        }
        ;
        wd.prototype.load = function(a, b) {
            a = z.makeIterator(a.blocks);
            for (var c = a.next(); !c.done; c = a.next())
                (0,
                Ya.append)(c.value, b, {
                    recordUndo: (0,
                    k.getRecordUndo)()
                })
        }
        ;
        wd.prototype.clear = function(a) {
            a = z.makeIterator(a.getTopBlocks(!1));
            for (var b = a.next(); !b.done; b = a.next())
                b.value.dispose(!1)
        }
        ;
        (0,
        Yd.register)("blocks", new wd);
        var Gb = function() {
            this.isBlank = null;
            this.workspaceId = void 0;
            this.group = (0,
            k.getGroup)();
            this.recordUndo = (0,
            k.getRecordUndo)()
        };
        Gb.prototype.isUiEvent = !1;
        Gb.prototype.toJson = function() {
            var a = {
                type: this.type
            };
            this.group && (a.group = this.group);
            return a
        }
        ;
        Gb.prototype.fromJson = function(a) {
            this.isBlank = !1;
            this.group = a.group
        }
        ;
        Gb.prototype.isNull = function() {
            return !1
        }
        ;
        Gb.prototype.run = function(a) {}
        ;
        Gb.prototype.getEventWorkspace_ = function() {
            var a;
            this.workspaceId && (a = N.Workspace.getById(this.workspaceId));
            if (!a)
                throw Error("Workspace is null. Event must have been generated from real Blockly events.");
            return a
        }
        ;
        var Mb = {
            BlockBase: function(a) {
                Mb.BlockBase.superClass_.constructor.call(this);
                this.blockId = (this.isBlank = "undefined" === typeof a) ? "" : a.id;
                this.workspaceId = this.isBlank ? "" : a.workspace.id
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Mb.BlockBase, Gb);
        Mb.BlockBase.prototype.toJson = function() {
            var a = Mb.BlockBase.superClass_.toJson.call(this);
            a.blockId = this.blockId;
            return a
        }
        ;
        Mb.BlockBase.prototype.fromJson = function(a) {
            Mb.BlockBase.superClass_.fromJson.call(this, a);
            this.blockId = a.blockId
        }
        ;
        var Xb = {
            BlockCreate: function(a) {
                Xb.BlockCreate.superClass_.constructor.call(this, a);
                a && (a.isShadow() && (this.recordUndo = !1),
                this.xml = (0,
                e.module$exports$Blockly$Xml.blockToDomWithXY)(a),
                this.ids = (0,
                k.getDescendantIds)(a),
                this.json = (0,
                Ya.save)(a, {
                    addCoordinates: !0
                }))
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Xb.BlockCreate, Mb.BlockBase);
        Xb.BlockCreate.prototype.type = k.CREATE;
        Xb.BlockCreate.prototype.toJson = function() {
            var a = Xb.BlockCreate.superClass_.toJson.call(this);
            a.xml = (0,
            e.module$exports$Blockly$Xml.domToText)(this.xml);
            a.ids = this.ids;
            a.json = this.json;
            this.recordUndo || (a.recordUndo = this.recordUndo);
            return a
        }
        ;
        Xb.BlockCreate.prototype.fromJson = function(a) {
            Xb.BlockCreate.superClass_.fromJson.call(this, a);
            this.xml = (0,
            e.module$exports$Blockly$Xml.textToDom)(a.xml);
            this.ids = a.ids;
            this.json = a.json;
            void 0 !== a.recordUndo && (this.recordUndo = a.recordUndo)
        }
        ;
        Xb.BlockCreate.prototype.run = function(a) {
            var b = this.getEventWorkspace_();
            if (a)
                (0,
                Ya.append)(this.json, b);
            else
                for (a = 0; a < this.ids.length; a++) {
                    var c = this.ids[a]
                      , d = b.getBlockById(c);
                    d ? d.dispose(!1) : c === this.blockId && console.warn("Can't uncreate non-existent block: " + c)
                }
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.CREATE, Xb.BlockCreate);
        e.module$exports$Blockly$ContextMenu = {};
        var xd = null;
        e.module$exports$Blockly$ContextMenu.getCurrentBlock = function() {
            return xd
        }
        ;
        e.module$exports$Blockly$ContextMenu.setCurrentBlock = function(a) {
            xd = a
        }
        ;
        Object.defineProperties(e.module$exports$Blockly$ContextMenu, {
            currentBlock: {
                get: function() {
                    (0,
                    q.warn)("Blockly.ContextMenu.currentBlock", "September 2021", "September 2022", "Blockly.Tooltip.getCurrentBlock()");
                    return (0,
                    e.module$exports$Blockly$ContextMenu.getCurrentBlock)()
                },
                set: function(a) {
                    (0,
                    q.warn)("Blockly.ContextMenu.currentBlock", "September 2021", "September 2022", "Blockly.Tooltip.setCurrentBlock(block)");
                    (0,
                    e.module$exports$Blockly$ContextMenu.setCurrentBlock)(a)
                }
            }
        });
        var yd = null;
        e.module$exports$Blockly$ContextMenu.show = function(a, b, c) {
            (0,
            sa.show)(e.module$exports$Blockly$ContextMenu, c, e.module$exports$Blockly$ContextMenu.dispose);
            if (b.length) {
                var d = ff(b, c);
                yd = d;
                gf(d, a, c);
                setTimeout(function() {
                    d.focus()
                }, 1);
                xd = null
            } else
                (0,
                e.module$exports$Blockly$ContextMenu.hide)()
        }
        ;
        var ff = function(a, b) {
            var c = new Ma;
            c.setRole(Q.Role.MENU);
            for (var d = 0; d < a.length; d++) {
                var f = a[d]
                  , g = new eb(f.text);
                g.setRightToLeft(b);
                g.setRole(Q.Role.MENUITEM);
                c.addChild(g);
                g.setEnabled(f.enabled);
                if (f.enabled)
                    g.onAction(function(m) {
                        (0,
                        e.module$exports$Blockly$ContextMenu.hide)();
                        this.callback(this.scope)
                    }, f)
            }
            return c
        }
          , gf = function(a, b, c) {
            var d = (0,
            ja.getViewportBBox)();
            b = new Ha(b.clientY + d.top,b.clientY + d.top,b.clientX + d.left,b.clientX + d.left);
            var f = (0,
            sa.getDiv)();
            if (!f)
                throw Error("Attempting to create a context menu when widget div is null");
            a.render(f);
            f = a.getElement();
            (0,
            n.addClass)(f, "blocklyContextMenu");
            (0,
            y.conditionalBind)(f, "contextmenu", null, hf);
            a.focus();
            f = a.getSize();
            c && (b.left += f.width,
            b.right += f.width,
            d.left += f.width,
            d.right += f.width);
            (0,
            sa.positionWithAnchor)(d, b, f, c);
            a.focus()
        }
          , hf = function(a) {
            a.preventDefault();
            a.stopPropagation()
        };
        e.module$exports$Blockly$ContextMenu.hide = function() {
            (0,
            sa.hideIfOwner)(e.module$exports$Blockly$ContextMenu);
            xd = null
        }
        ;
        e.module$exports$Blockly$ContextMenu.dispose = function() {
            yd && (yd.dispose(),
            yd = null)
        }
        ;
        e.module$exports$Blockly$ContextMenu.callbackFactory = function(a, b) {
            return function() {
                (0,
                k.disable)();
                try {
                    var c = (0,
                    e.module$exports$Blockly$Xml.domToBlock)(b, a.workspace)
                      , d = a.getRelativeToSurfaceXY();
                    d.x = a.RTL ? d.x - e.module$exports$Blockly$internalConstants.SNAP_RADIUS : d.x + e.module$exports$Blockly$internalConstants.SNAP_RADIUS;
                    d.y += 2 * e.module$exports$Blockly$internalConstants.SNAP_RADIUS;
                    c.moveBy(d.x, d.y)
                } finally {
                    (0,
                    k.enable)()
                }
                (0,
                k.isEnabled)() && !c.isShadow() && (0,
                k.fire)(new ((0,
                k.get)(k.CREATE))(c));
                c.select()
            }
        }
        ;
        e.module$exports$Blockly$ContextMenu.commentDeleteOption = function(a) {
            return {
                text: e.module$exports$Blockly$Msg.Msg.REMOVE_COMMENT,
                enabled: !0,
                callback: function() {
                    (0,
                    k.setGroup)(!0);
                    a.dispose();
                    (0,
                    k.setGroup)(!1)
                }
            }
        }
        ;
        e.module$exports$Blockly$ContextMenu.commentDuplicateOption = function(a) {
            return {
                text: e.module$exports$Blockly$Msg.Msg.DUPLICATE_COMMENT,
                enabled: !0,
                callback: function() {
                    (0,
                    yb.duplicate)(a)
                }
            }
        }
        ;
        e.module$exports$Blockly$ContextMenu.workspaceCommentOption = function(a, b) {
            var c = S;
            if (!c)
                throw Error("Missing require for Blockly.WorkspaceCommentSvg");
            var d = {
                enabled: !V.IE
            };
            d.text = e.module$exports$Blockly$Msg.Msg.ADD_COMMENT;
            d.callback = function() {
                var f = new c(a,e.module$exports$Blockly$Msg.Msg.WORKSPACE_COMMENT_DEFAULT_TEXT,c.DEFAULT_SIZE,c.DEFAULT_SIZE)
                  , g = a.getInjectionDiv().getBoundingClientRect();
                g = new J(b.clientX - g.left,b.clientY - g.top);
                var m = a.getOriginOffsetInPixels();
                g = J.difference(g, m);
                g.scale(1 / a.scale);
                f.moveBy(g.x, g.y);
                a.rendered && (f.initSvg(),
                f.render(),
                f.select())
            }
            ;
            return d
        }
        ;
        var zb = function(a, b) {
            b = a.indexOf(b);
            if (-1 === b)
                return !1;
            a.splice(b, 1);
            return !0
        }
          , Nb = {}
          , Zd = !1;
        Nb.isDebuggerEnabled = function() {
            return Zd
        }
        ;
        Nb.startDebugger = function() {
            Zd = !0
        }
        ;
        Nb.stopDebugger = function() {
            Zd = !1
        }
        ;
        var p = {
            NONE: 0,
            FIELD: 1,
            HAT: 2,
            ICON: 4,
            SPACER: 8,
            BETWEEN_ROW_SPACER: 16,
            IN_ROW_SPACER: 32,
            EXTERNAL_VALUE_INPUT: 64,
            INPUT: 128,
            INLINE_INPUT: 256,
            STATEMENT_INPUT: 512,
            CONNECTION: 1024,
            PREVIOUS_CONNECTION: 2048,
            NEXT_CONNECTION: 4096,
            OUTPUT_CONNECTION: 8192,
            CORNER: 16384,
            LEFT_SQUARE_CORNER: 32768,
            LEFT_ROUND_CORNER: 65536,
            RIGHT_SQUARE_CORNER: 131072,
            RIGHT_ROUND_CORNER: 262144,
            JAGGED_EDGE: 524288,
            ROW: 1048576,
            TOP_ROW: 2097152,
            BOTTOM_ROW: 4194304,
            INPUT_ROW: 8388608
        };
        p.LEFT_CORNER = p.LEFT_SQUARE_CORNER | p.LEFT_ROUND_CORNER;
        p.RIGHT_CORNER = p.RIGHT_SQUARE_CORNER | p.RIGHT_ROUND_CORNER;
        p.nextTypeValue_ = 16777216;
        p.getType = function(a) {
            Object.prototype.hasOwnProperty.call(p, a) || (p[a] = p.nextTypeValue_,
            p.nextTypeValue_ <<= 1);
            return p[a]
        }
        ;
        p.isField = function(a) {
            return a.type & p.FIELD
        }
        ;
        p.isHat = function(a) {
            return a.type & p.HAT
        }
        ;
        p.isIcon = function(a) {
            return a.type & p.ICON
        }
        ;
        p.isSpacer = function(a) {
            return a.type & p.SPACER
        }
        ;
        p.isInRowSpacer = function(a) {
            return a.type & p.IN_ROW_SPACER
        }
        ;
        p.isInput = function(a) {
            return a.type & p.INPUT
        }
        ;
        p.isExternalInput = function(a) {
            return a.type & p.EXTERNAL_VALUE_INPUT
        }
        ;
        p.isInlineInput = function(a) {
            return a.type & p.INLINE_INPUT
        }
        ;
        p.isStatementInput = function(a) {
            return a.type & p.STATEMENT_INPUT
        }
        ;
        p.isPreviousConnection = function(a) {
            return a.type & p.PREVIOUS_CONNECTION
        }
        ;
        p.isNextConnection = function(a) {
            return a.type & p.NEXT_CONNECTION
        }
        ;
        p.isPreviousOrNextConnection = function(a) {
            return a.type & (p.PREVIOUS_CONNECTION | p.NEXT_CONNECTION)
        }
        ;
        p.isLeftRoundedCorner = function(a) {
            return a.type & p.LEFT_ROUND_CORNER
        }
        ;
        p.isRightRoundedCorner = function(a) {
            return a.type & p.RIGHT_ROUND_CORNER
        }
        ;
        p.isLeftSquareCorner = function(a) {
            return a.type & p.LEFT_SQUARE_CORNER
        }
        ;
        p.isRightSquareCorner = function(a) {
            return a.type & p.RIGHT_SQUARE_CORNER
        }
        ;
        p.isCorner = function(a) {
            return a.type & p.CORNER
        }
        ;
        p.isJaggedEdge = function(a) {
            return a.type & p.JAGGED_EDGE
        }
        ;
        p.isRow = function(a) {
            return a.type & p.ROW
        }
        ;
        p.isBetweenRowSpacer = function(a) {
            return a.type & p.BETWEEN_ROW_SPACER
        }
        ;
        p.isTopRow = function(a) {
            return a.type & p.TOP_ROW
        }
        ;
        p.isBottomRow = function(a) {
            return a.type & p.BOTTOM_ROW
        }
        ;
        p.isTopOrBottomRow = function(a) {
            return a.type & (p.TOP_ROW | p.BOTTOM_ROW)
        }
        ;
        p.isInputRow = function(a) {
            return a.type & p.INPUT_ROW
        }
        ;
        var Ob = function(a) {
            this.type = p.ROW;
            this.elements = [];
            this.xPos = this.yPos = this.widthWithConnectedBlocks = this.minWidth = this.minHeight = this.width = this.height = 0;
            this.hasJaggedEdge = this.hasDummyInput = this.hasInlineInput = this.hasStatement = this.hasExternalInput = !1;
            this.constants_ = a;
            this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT;
            this.align = null
        };
        Ob.prototype.getLastInput = function() {
            for (var a = this.elements.length - 1; 0 <= a; a--) {
                var b = this.elements[a];
                if (p.isInput(b))
                    return b
            }
            return null
        }
        ;
        Ob.prototype.measure = function() {
            throw Error("Unexpected attempt to measure a base Row.");
        }
        ;
        Ob.prototype.startsWithElemSpacer = function() {
            return !0
        }
        ;
        Ob.prototype.endsWithElemSpacer = function() {
            return !0
        }
        ;
        Ob.prototype.getFirstSpacer = function() {
            for (var a = 0; a < this.elements.length; a++) {
                var b = this.elements[a];
                if (p.isSpacer(b))
                    return b
            }
            return null
        }
        ;
        Ob.prototype.getLastSpacer = function() {
            for (var a = this.elements.length - 1; 0 <= a; a--) {
                var b = this.elements[a];
                if (p.isSpacer(b))
                    return b
            }
            return null
        }
        ;
        var Yb = {
            BottomRow: function(a) {
                Yb.BottomRow.superClass_.constructor.call(this, a);
                this.type |= p.BOTTOM_ROW;
                this.hasNextConnection = !1;
                this.connection = null;
                this.baseline = this.descenderHeight = 0
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Yb.BottomRow, Ob);
        Yb.BottomRow.prototype.hasLeftSquareCorner = function(a) {
            return !!a.outputConnection || !!a.getNextBlock()
        }
        ;
        Yb.BottomRow.prototype.hasRightSquareCorner = function(a) {
            return !0
        }
        ;
        Yb.BottomRow.prototype.measure = function() {
            for (var a = 0, b = 0, c = 0, d = 0; d < this.elements.length; d++) {
                var f = this.elements[d];
                b += f.width;
                p.isSpacer(f) || (p.isNextConnection(f) ? c = Math.max(c, f.height) : a = Math.max(a, f.height))
            }
            this.width = Math.max(this.minWidth, b);
            this.height = Math.max(this.minHeight, a) + c;
            this.descenderHeight = c;
            this.widthWithConnectedBlocks = this.width
        }
        ;
        Yb.BottomRow.prototype.startsWithElemSpacer = function() {
            return !1
        }
        ;
        Yb.BottomRow.prototype.endsWithElemSpacer = function() {
            return !1
        }
        ;
        var Zb = function(a) {
            this.height = this.width = 0;
            this.type = p.NONE;
            this.centerline = this.xPos = 0;
            this.constants_ = a;
            this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT
        }
          , Gc = {
            Connection: function(a, b) {
                Gc.Connection.superClass_.constructor.call(this, a);
                this.connectionModel = b;
                this.shape = this.constants_.shapeFor(b);
                this.isDynamicShape = !!this.shape.isDynamic;
                this.type |= p.CONNECTION
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Gc.Connection, Zb);
        var na = {}
          , $d = .45;
        na.getHsvSaturation = function() {
            return $d
        }
        ;
        na.setHsvSaturation = function(a) {
            $d = a
        }
        ;
        var ae = .65;
        na.getHsvValue = function() {
            return ae
        }
        ;
        na.setHsvValue = function(a) {
            ae = a
        }
        ;
        na.parse = function(a) {
            a = String(a).toLowerCase().trim();
            var b = na.names[a];
            if (b)
                return b;
            b = "0x" === a.substring(0, 2) ? "#" + a.substring(2) : a;
            b = "#" === b[0] ? b : "#" + b;
            if (/^#[0-9a-f]{6}$/.test(b))
                return b;
            if (/^#[0-9a-f]{3}$/.test(b))
                return ["#", b[1], b[1], b[2], b[2], b[3], b[3]].join("");
            var c = a.match(/^(?:rgb)?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
            return c && (a = Number(c[1]),
            b = Number(c[2]),
            c = Number(c[3]),
            0 <= a && 256 > a && 0 <= b && 256 > b && 0 <= c && 256 > c) ? (0,
            na.rgbToHex)(a, b, c) : null
        }
        ;
        na.rgbToHex = function(a, b, c) {
            b = a << 16 | b << 8 | c;
            return 16 > a ? "#" + (16777216 | b).toString(16).substr(1) : "#" + b.toString(16)
        }
        ;
        na.hexToRgb = function(a) {
            a = (0,
            na.parse)(a);
            if (!a)
                return [0, 0, 0];
            a = parseInt(a.substr(1), 16);
            return [a >> 16, a >> 8 & 255, a & 255]
        }
        ;
        na.hsvToHex = function(a, b, c) {
            var d = 0
              , f = 0
              , g = 0;
            if (0 === b)
                g = f = d = c;
            else {
                var m = Math.floor(a / 60)
                  , r = a / 60 - m;
                a = c * (1 - b);
                var B = c * (1 - b * r);
                b = c * (1 - b * (1 - r));
                switch (m) {
                case 1:
                    d = B;
                    f = c;
                    g = a;
                    break;
                case 2:
                    d = a;
                    f = c;
                    g = b;
                    break;
                case 3:
                    d = a;
                    f = B;
                    g = c;
                    break;
                case 4:
                    d = b;
                    f = a;
                    g = c;
                    break;
                case 5:
                    d = c;
                    f = a;
                    g = B;
                    break;
                case 6:
                case 0:
                    d = c,
                    f = b,
                    g = a
                }
            }
            return (0,
            na.rgbToHex)(Math.floor(d), Math.floor(f), Math.floor(g))
        }
        ;
        na.blend = function(a, b, c) {
            a = (0,
            na.parse)(a);
            if (!a)
                return null;
            b = (0,
            na.parse)(b);
            if (!b)
                return null;
            a = (0,
            na.hexToRgb)(a);
            b = (0,
            na.hexToRgb)(b);
            return (0,
            na.rgbToHex)(Math.round(b[0] + c * (a[0] - b[0])), Math.round(b[1] + c * (a[1] - b[1])), Math.round(b[2] + c * (a[2] - b[2])))
        }
        ;
        na.names = {
            aqua: "#00ffff",
            black: "#000000",
            blue: "#0000ff",
            fuchsia: "#ff00ff",
            gray: "#808080",
            green: "#008000",
            lime: "#00ff00",
            maroon: "#800000",
            navy: "#000080",
            olive: "#808000",
            purple: "#800080",
            red: "#ff0000",
            silver: "#c0c0c0",
            teal: "#008080",
            white: "#ffffff",
            yellow: "#ffff00"
        };
        na.hueToHex = function(a) {
            return (0,
            na.hsvToHex)(a, $d, 255 * ae)
        }
        ;
        var t = {
            point: function(a, b) {
                return " " + a + "," + b + " "
            },
            curve: function(a, b) {
                return " " + a + b.join("")
            },
            moveTo: function(a, b) {
                return " M " + a + "," + b + " "
            },
            moveBy: function(a, b) {
                return " m " + a + "," + b + " "
            },
            lineTo: function(a, b) {
                return " l " + a + "," + b + " "
            },
            line: function(a) {
                return " l" + a.join("")
            },
            lineOnAxis: function(a, b) {
                return " " + a + " " + b + " "
            },
            arc: function(a, b, c, d) {
                return a + " " + c + " " + c + " " + b + d
            }
        }
          , ka = {}
          , be = function(a, b) {
            var c = []
              , d = a.split("");
            d.push("");
            var f = 0;
            a = [];
            for (var g = null, m = 0; m < d.length; m++) {
                var r = d[m];
                0 === f ? "%" === r ? ((f = a.join("")) && c.push(f),
                a.length = 0,
                f = 1) : a.push(r) : 1 === f ? "%" === r ? (a.push(r),
                f = 0) : b && "0" <= r && "9" >= r ? (f = 2,
                g = r,
                (r = a.join("")) && c.push(r),
                a.length = 0) : "{" === r ? f = 3 : (a.push("%", r),
                f = 0) : 2 === f ? "0" <= r && "9" >= r ? g += r : (c.push(parseInt(g, 10)),
                m--,
                f = 0) : 3 === f && ("" === r ? (a.splice(0, 0, "%{"),
                m--,
                f = 0) : "}" !== r ? a.push(r) : (f = a.join(""),
                /[A-Z]\w*/i.test(f) ? (r = f.toUpperCase(),
                (r = (0,
                e.module$exports$Blockly$utils$string.startsWith)(r, "BKY_") ? r.substring(4) : null) && r in e.module$exports$Blockly$Msg.Msg ? (f = e.module$exports$Blockly$Msg.Msg[r],
                "string" === typeof f ? Array.prototype.push.apply(c, be(f, b)) : b ? c.push(String(f)) : c.push(f)) : c.push("%{" + f + "}")) : c.push("%{" + f + "}"),
                f = a.length = 0))
            }
            (b = a.join("")) && c.push(b);
            d = [];
            for (g = a.length = 0; g < c.length; g++)
                "string" === typeof c[g] ? a.push(c[g]) : ((b = a.join("")) && d.push(b),
                a.length = 0,
                d.push(c[g]));
            (b = a.join("")) && d.push(b);
            a.length = 0;
            return d
        };
        ka.tokenizeInterpolation = function(a) {
            return be(a, !0)
        }
        ;
        ka.replaceMessageReferences = function(a) {
            if ("string" !== typeof a)
                return a;
            a = be(a, !1);
            return a.length ? String(a[0]) : ""
        }
        ;
        ka.checkMessageReferences = function(a) {
            for (var b = !0, c = e.module$exports$Blockly$Msg.Msg, d = a.match(/%{BKY_[A-Z]\w*}/ig), f = 0; f < d.length; f++) {
                var g = d[f].toUpperCase();
                void 0 === c[g.slice(6, -1)] && (console.warn("No message string for " + d[f] + " in " + a),
                b = !1)
            }
            return b
        }
        ;
        ka.parseBlockColour = function(a) {
            var b = "string" === typeof a ? (0,
            ka.replaceMessageReferences)(a) : a
              , c = Number(b);
            if (!isNaN(c) && 0 <= c && 360 >= c)
                return {
                    hue: c,
                    hex: (0,
                    na.hsvToHex)(c, (0,
                    na.getHsvSaturation)(), 255 * (0,
                    na.getHsvValue)())
                };
            if (c = (0,
            na.parse)(b))
                return {
                    hue: null,
                    hex: c
                };
            c = 'Invalid colour: "' + b + '"';
            a !== b && (c += ' (from "' + a + '")');
            throw Error(c);
        }
        ;
        var va = function() {
            this.NO_PADDING = 0;
            this.SMALL_PADDING = 3;
            this.MEDIUM_PADDING = 5;
            this.MEDIUM_LARGE_PADDING = 8;
            this.LARGE_PADDING = 10;
            this.TALL_INPUT_FIELD_OFFSET_Y = this.MEDIUM_PADDING;
            this.TAB_HEIGHT = 15;
            this.TAB_OFFSET_FROM_TOP = 5;
            this.TAB_VERTICAL_OVERLAP = 2.5;
            this.TAB_WIDTH = 8;
            this.NOTCH_WIDTH = 15;
            this.NOTCH_HEIGHT = 4;
            this.MIN_BLOCK_WIDTH = 12;
            this.EMPTY_BLOCK_SPACER_HEIGHT = 16;
            this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = this.DUMMY_INPUT_MIN_HEIGHT = this.TAB_HEIGHT;
            this.CORNER_RADIUS = 8;
            this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT = 15;
            this.STATEMENT_BOTTOM_SPACER = 0;
            this.STATEMENT_INPUT_PADDING_LEFT = 20;
            this.BETWEEN_STATEMENT_PADDING_Y = 4;
            this.TOP_ROW_MIN_HEIGHT = this.MEDIUM_PADDING;
            this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING;
            this.BOTTOM_ROW_MIN_HEIGHT = this.MEDIUM_PADDING;
            this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING;
            this.ADD_START_HATS = !1;
            this.START_HAT_HEIGHT = 15;
            this.START_HAT_WIDTH = 100;
            this.SPACER_DEFAULT_HEIGHT = 15;
            this.MIN_BLOCK_HEIGHT = 24;
            this.EMPTY_INLINE_INPUT_PADDING = 14.5;
            this.EMPTY_INLINE_INPUT_HEIGHT = this.TAB_HEIGHT + 11;
            this.EXTERNAL_VALUE_INPUT_PADDING = 2;
            this.EMPTY_STATEMENT_INPUT_HEIGHT = this.MIN_BLOCK_HEIGHT;
            this.START_POINT = (0,
            t.moveBy)(0, 0);
            this.JAGGED_TEETH_HEIGHT = 12;
            this.JAGGED_TEETH_WIDTH = 6;
            this.FIELD_TEXT_FONTSIZE = 11;
            this.FIELD_TEXT_FONTWEIGHT = "normal";
            this.FIELD_TEXT_FONTFAMILY = "sans-serif";
            this.FIELD_TEXT_BASELINE = this.FIELD_TEXT_HEIGHT = -1;
            this.FIELD_BORDER_RECT_RADIUS = 4;
            this.FIELD_BORDER_RECT_HEIGHT = 16;
            this.FIELD_BORDER_RECT_X_PADDING = 5;
            this.FIELD_BORDER_RECT_Y_PADDING = 3;
            this.FIELD_BORDER_RECT_COLOUR = "#fff";
            this.FIELD_TEXT_BASELINE_CENTER = !V.IE && !V.EDGE;
            this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT;
            this.FIELD_DROPDOWN_SVG_ARROW = this.FIELD_DROPDOWN_COLOURED_DIV = this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = !1;
            this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING;
            this.FIELD_DROPDOWN_SVG_ARROW_SIZE = 12;
            this.FIELD_DROPDOWN_SVG_ARROW_DATAURI = "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMi43MSIgaGVpZ2h0PSI4Ljc5IiB2aWV3Qm94PSIwIDAgMTIuNzEgOC43OSI+PHRpdGxlPmRyb3Bkb3duLWFycm93PC90aXRsZT48ZyBvcGFjaXR5PSIwLjEiPjxwYXRoIGQ9Ik0xMi43MSwyLjQ0QTIuNDEsMi40MSwwLDAsMSwxMiw0LjE2TDguMDgsOC4wOGEyLjQ1LDIuNDUsMCwwLDEtMy40NSwwTDAuNzIsNC4xNkEyLjQyLDIuNDIsMCwwLDEsMCwyLjQ0LDIuNDgsMi40OCwwLDAsMSwuNzEuNzFDMSwwLjQ3LDEuNDMsMCw2LjM2LDBTMTEuNzUsMC40NiwxMiwuNzFBMi40NCwyLjQ0LDAsMCwxLDEyLjcxLDIuNDRaIiBmaWxsPSIjMjMxZjIwIi8+PC9nPjxwYXRoIGQ9Ik02LjM2LDcuNzlhMS40MywxLjQzLDAsMCwxLTEtLjQyTDEuNDIsMy40NWExLjQ0LDEuNDQsMCwwLDEsMC0yYzAuNTYtLjU2LDkuMzEtMC41Niw5Ljg3LDBhMS40NCwxLjQ0LDAsMCwxLDAsMkw3LjM3LDcuMzdBMS40MywxLjQzLDAsMCwxLDYuMzYsNy43OVoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=";
            this.FIELD_COLOUR_FULL_BLOCK = this.FIELD_TEXTINPUT_BOX_SHADOW = !1;
            this.FIELD_COLOUR_DEFAULT_WIDTH = 26;
            this.FIELD_COLOUR_DEFAULT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT;
            this.FIELD_CHECKBOX_X_OFFSET = this.FIELD_BORDER_RECT_X_PADDING - 3;
            this.randomIdentifier = String(Math.random()).substring(2);
            this.defs_ = null;
            this.embossFilterId = "";
            this.embossFilter_ = null;
            this.disabledPatternId = "";
            this.disabledPattern_ = null;
            this.debugFilterId = "";
            this.cssNode_ = this.debugFilter_ = null;
            this.CURSOR_COLOUR = "#cc0a0a";
            this.MARKER_COLOUR = "#4286f4";
            this.CURSOR_WS_WIDTH = 100;
            this.WS_CURSOR_HEIGHT = 5;
            this.CURSOR_STACK_PADDING = 10;
            this.CURSOR_BLOCK_PADDING = 2;
            this.CURSOR_STROKE_WIDTH = 4;
            this.FULL_BLOCK_FIELDS = !1;
            this.INSERTION_MARKER_COLOUR = "#000000";
            this.INSERTION_MARKER_OPACITY = .2;
            this.SHAPES = {
                PUZZLE: 1,
                NOTCH: 2
            }
        };
        va.prototype.init = function() {
            this.JAGGED_TEETH = this.makeJaggedTeeth();
            this.NOTCH = this.makeNotch();
            this.START_HAT = this.makeStartHat();
            this.PUZZLE_TAB = this.makePuzzleTab();
            this.INSIDE_CORNERS = this.makeInsideCorners();
            this.OUTSIDE_CORNERS = this.makeOutsideCorners()
        }
        ;
        va.prototype.setTheme = function(a) {
            this.blockStyles = Object.create(null);
            var b = a.blockStyles, c;
            for (c in b)
                this.blockStyles[c] = this.validatedBlockStyle_(b[c]);
            this.setDynamicProperties_(a)
        }
        ;
        va.prototype.setDynamicProperties_ = function(a) {
            this.setFontConstants_(a);
            this.setComponentConstants_(a);
            this.ADD_START_HATS = null !== a.startHats ? a.startHats : this.ADD_START_HATS
        }
        ;
        va.prototype.setFontConstants_ = function(a) {
            this.FIELD_TEXT_FONTFAMILY = a.fontStyle && void 0 !== a.fontStyle.family ? a.fontStyle.family : this.FIELD_TEXT_FONTFAMILY;
            this.FIELD_TEXT_FONTWEIGHT = a.fontStyle && void 0 !== a.fontStyle.weight ? a.fontStyle.weight : this.FIELD_TEXT_FONTWEIGHT;
            this.FIELD_TEXT_FONTSIZE = a.fontStyle && void 0 !== a.fontStyle.size ? a.fontStyle.size : this.FIELD_TEXT_FONTSIZE;
            a = (0,
            n.measureFontMetrics)("Hg", this.FIELD_TEXT_FONTSIZE + "pt", this.FIELD_TEXT_FONTWEIGHT, this.FIELD_TEXT_FONTFAMILY);
            this.FIELD_TEXT_HEIGHT = a.height;
            this.FIELD_TEXT_BASELINE = a.baseline
        }
        ;
        va.prototype.setComponentConstants_ = function(a) {
            this.CURSOR_COLOUR = a.getComponentStyle("cursorColour") || this.CURSOR_COLOUR;
            this.MARKER_COLOUR = a.getComponentStyle("markerColour") || this.MARKER_COLOUR;
            this.INSERTION_MARKER_COLOUR = a.getComponentStyle("insertionMarkerColour") || this.INSERTION_MARKER_COLOUR;
            this.INSERTION_MARKER_OPACITY = Number(a.getComponentStyle("insertionMarkerOpacity")) || this.INSERTION_MARKER_OPACITY
        }
        ;
        va.prototype.getBlockStyleForColour = function(a) {
            var b = "auto_" + a;
            this.blockStyles[b] || (this.blockStyles[b] = this.createBlockStyle_(a));
            return {
                style: this.blockStyles[b],
                name: b
            }
        }
        ;
        va.prototype.getBlockStyle = function(a) {
            return this.blockStyles[a || ""] || (a && 0 === a.indexOf("auto_") ? this.getBlockStyleForColour(a.substring(5)).style : this.createBlockStyle_("#000000"))
        }
        ;
        va.prototype.createBlockStyle_ = function(a) {
            return this.validatedBlockStyle_({
                colourPrimary: a
            })
        }
        ;
        va.prototype.validatedBlockStyle_ = function(a) {
            var b = {};
            a && (0,
            e.module$exports$Blockly$utils$object.mixin)(b, a);
            a = (0,
            ka.parseBlockColour)(b.colourPrimary || "#000");
            b.colourPrimary = a.hex;
            b.colourSecondary = b.colourSecondary ? (0,
            ka.parseBlockColour)(b.colourSecondary).hex : this.generateSecondaryColour_(b.colourPrimary);
            b.colourTertiary = b.colourTertiary ? (0,
            ka.parseBlockColour)(b.colourTertiary).hex : this.generateTertiaryColour_(b.colourPrimary);
            b.hat = b.hat || "";
            return b
        }
        ;
        va.prototype.generateSecondaryColour_ = function(a) {
            return (0,
            na.blend)("#fff", a, .6) || a
        }
        ;
        va.prototype.generateTertiaryColour_ = function(a) {
            return (0,
            na.blend)("#fff", a, .3) || a
        }
        ;
        va.prototype.dispose = function() {
            this.embossFilter_ && (0,
            n.removeNode)(this.embossFilter_);
            this.disabledPattern_ && (0,
            n.removeNode)(this.disabledPattern_);
            this.debugFilter_ && (0,
            n.removeNode)(this.debugFilter_);
            this.cssNode_ = null
        }
        ;
        va.prototype.makeJaggedTeeth = function() {
            var a = this.JAGGED_TEETH_HEIGHT
              , b = this.JAGGED_TEETH_WIDTH
              , c = (0,
            t.line)([(0,
            t.point)(b, a / 4), (0,
            t.point)(2 * -b, a / 2), (0,
            t.point)(b, a / 4)]);
            return {
                height: a,
                width: b,
                path: c
            }
        }
        ;
        va.prototype.makeStartHat = function() {
            var a = this.START_HAT_HEIGHT
              , b = this.START_HAT_WIDTH
              , c = (0,
            t.curve)("c", [(0,
            t.point)(30, -a), (0,
            t.point)(70, -a), (0,
            t.point)(b, 0)]);
            return {
                height: a,
                width: b,
                path: c
            }
        }
        ;
        va.prototype.makePuzzleTab = function() {
            function a(g) {
                g = g ? -1 : 1;
                var m = -g
                  , r = c / 2
                  , B = r + 2.5
                  , G = r + .5
                  , W = (0,
                t.point)(-b, g * r);
                r = (0,
                t.point)(b, g * r);
                return (0,
                t.curve)("c", [(0,
                t.point)(0, g * B), (0,
                t.point)(-b, m * G), W]) + (0,
                t.curve)("s", [(0,
                t.point)(b, 2.5 * m), r])
            }
            var b = this.TAB_WIDTH
              , c = this.TAB_HEIGHT
              , d = a(!0)
              , f = a(!1);
            return {
                type: this.SHAPES.PUZZLE,
                width: b,
                height: c,
                pathDown: f,
                pathUp: d
            }
        }
        ;
        va.prototype.makeNotch = function() {
            function a(m) {
                return (0,
                t.line)([(0,
                t.point)(m * d, c), (0,
                t.point)(3 * m, 0), (0,
                t.point)(m * d, -c)])
            }
            var b = this.NOTCH_WIDTH
              , c = this.NOTCH_HEIGHT
              , d = (b - 3) / 2
              , f = a(1)
              , g = a(-1);
            return {
                type: this.SHAPES.NOTCH,
                width: b,
                height: c,
                pathLeft: f,
                pathRight: g
            }
        }
        ;
        va.prototype.makeInsideCorners = function() {
            var a = this.CORNER_RADIUS
              , b = (0,
            t.arc)("a", "0 0,0", a, (0,
            t.point)(-a, a))
              , c = (0,
            t.arc)("a", "0 0,0", a, (0,
            t.point)(a, a));
            return {
                width: a,
                height: a,
                pathTop: b,
                pathBottom: c
            }
        }
        ;
        va.prototype.makeOutsideCorners = function() {
            var a = this.CORNER_RADIUS
              , b = (0,
            t.moveBy)(0, a) + (0,
            t.arc)("a", "0 0,1", a, (0,
            t.point)(a, -a))
              , c = (0,
            t.arc)("a", "0 0,1", a, (0,
            t.point)(a, a))
              , d = (0,
            t.arc)("a", "0 0,1", a, (0,
            t.point)(-a, -a))
              , f = (0,
            t.arc)("a", "0 0,1", a, (0,
            t.point)(-a, a));
            return {
                topLeft: b,
                topRight: c,
                bottomRight: f,
                bottomLeft: d,
                rightHeight: a
            }
        }
        ;
        va.prototype.shapeFor = function(a) {
            switch (a.type) {
            case e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE:
            case e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE:
                return this.PUZZLE_TAB;
            case e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT:
            case e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT:
                return this.NOTCH;
            default:
                throw Error("Unknown connection type");
            }
        }
        ;
        va.prototype.createDom = function(a, b, c) {
            this.injectCSS_(b, c);
            this.defs_ = (0,
            n.createSvgElement)(u.DEFS, {}, a);
            a = (0,
            n.createSvgElement)(u.FILTER, {
                id: "blocklyEmbossFilter" + this.randomIdentifier
            }, this.defs_);
            (0,
            n.createSvgElement)(u.FEGAUSSIANBLUR, {
                "in": "SourceAlpha",
                stdDeviation: 1,
                result: "blur"
            }, a);
            b = (0,
            n.createSvgElement)(u.FESPECULARLIGHTING, {
                "in": "blur",
                surfaceScale: 1,
                specularConstant: .5,
                specularExponent: 10,
                "lighting-color": "white",
                result: "specOut"
            }, a);
            (0,
            n.createSvgElement)(u.FEPOINTLIGHT, {
                x: -5E3,
                y: -1E4,
                z: 2E4
            }, b);
            (0,
            n.createSvgElement)(u.FECOMPOSITE, {
                "in": "specOut",
                in2: "SourceAlpha",
                operator: "in",
                result: "specOut"
            }, a);
            (0,
            n.createSvgElement)(u.FECOMPOSITE, {
                "in": "SourceGraphic",
                in2: "specOut",
                operator: "arithmetic",
                k1: 0,
                k2: 1,
                k3: 1,
                k4: 0
            }, a);
            this.embossFilterId = a.id;
            this.embossFilter_ = a;
            a = (0,
            n.createSvgElement)(u.PATTERN, {
                id: "blocklyDisabledPattern" + this.randomIdentifier,
                patternUnits: "userSpaceOnUse",
                width: 10,
                height: 10
            }, this.defs_);
            (0,
            n.createSvgElement)(u.RECT, {
                width: 10,
                height: 10,
                fill: "#aaa"
            }, a);
            (0,
            n.createSvgElement)(u.PATH, {
                d: "M 0 0 L 10 10 M 10 0 L 0 10",
                stroke: "#cc0"
            }, a);
            this.disabledPatternId = a.id;
            this.disabledPattern_ = a;
            this.createDebugFilter()
        }
        ;
        va.prototype.createDebugFilter = function() {
            if (!this.debugFilter_) {
                var a = (0,
                n.createSvgElement)(u.FILTER, {
                    id: "blocklyDebugFilter" + this.randomIdentifier,
                    height: "160%",
                    width: "180%",
                    y: "-30%",
                    x: "-40%"
                }, this.defs_)
                  , b = (0,
                n.createSvgElement)(u.FECOMPONENTTRANSFER, {
                    result: "outBlur"
                }, a);
                (0,
                n.createSvgElement)(u.FEFUNCA, {
                    type: "table",
                    tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
                }, b);
                (0,
                n.createSvgElement)(u.FEFLOOD, {
                    "flood-color": "#ff0000",
                    "flood-opacity": .5,
                    result: "outColor"
                }, a);
                (0,
                n.createSvgElement)(u.FECOMPOSITE, {
                    "in": "outColor",
                    in2: "outBlur",
                    operator: "in",
                    result: "outGlow"
                }, a);
                this.debugFilterId = a.id;
                this.debugFilter_ = a
            }
        }
        ;
        va.prototype.injectCSS_ = function(a, b) {
            b = this.getCSS_(b);
            a = "blockly-renderer-style-" + a;
            this.cssNode_ = document.getElementById(a);
            var c = b.join("\n");
            this.cssNode_ ? this.cssNode_.firstChild.textContent = c : (b = document.createElement("style"),
            b.id = a,
            a = document.createTextNode(c),
            b.appendChild(a),
            document.head.insertBefore(b, document.head.firstChild),
            this.cssNode_ = b)
        }
        ;
        va.prototype.getCSS_ = function(a) {
            return [a + " .blocklyText, ", a + " .blocklyFlyoutLabelText {", "font: " + this.FIELD_TEXT_FONTWEIGHT + " " + this.FIELD_TEXT_FONTSIZE + "pt " + this.FIELD_TEXT_FONTFAMILY + ";", "}", a + " .blocklyText {", "fill: #fff;", "}", a + " .blocklyNonEditableText>rect,", a + " .blocklyEditableText>rect {", "fill: " + this.FIELD_BORDER_RECT_COLOUR + ";", "fill-opacity: .6;", "stroke: none;", "}", a + " .blocklyNonEditableText>text,", a + " .blocklyEditableText>text {", "fill: #000;", "}", a + " .blocklyFlyoutLabelText {", "fill: #000;", "}", a + " .blocklyText.blocklyBubbleText {", "fill: #000;", "}", a + " .blocklyEditableText:not(.editing):hover>rect {", "stroke: #fff;", "stroke-width: 2;", "}", a + " .blocklyHtmlInput {", "font-family: " + this.FIELD_TEXT_FONTFAMILY + ";", "font-weight: " + this.FIELD_TEXT_FONTWEIGHT + ";", "}", a + " .blocklySelected>.blocklyPath {", "stroke: #fc3;", "stroke-width: 3px;", "}", a + " .blocklyHighlightedConnectionPath {", "stroke: #fc3;", "}", a + " .blocklyReplaceable .blocklyPath {", "fill-opacity: .5;", "}", a + " .blocklyReplaceable .blocklyPathLight,", a + " .blocklyReplaceable .blocklyPathDark {", "display: none;", "}", a + " .blocklyInsertionMarker>.blocklyPath {", "fill-opacity: " + this.INSERTION_MARKER_OPACITY + ";", "stroke: none;", "}"]
        }
        ;
        var tb = {
            register: function(a, b) {
                (0,
                w.register)(w.Type.FIELD, a, b)
            },
            unregister: function(a) {
                (0,
                w.unregister)(w.Type.FIELD, a)
            },
            fromJson: function(a) {
                var b = (0,
                w.getObject)(w.Type.FIELD, a.type);
                return b ? b.fromJson(a) : (console.warn("Blockly could not create a field of type " + a.type + ". The field is probably not being registered. This could be because the file is not loaded, the field does not register itself (Issue #1584), or the registration is not being reached."),
                null)
            }
        }
          , ub = function(a) {
            this.cursorSvg_ = this.cursor_ = null;
            this.markers_ = Object.create(null);
            this.workspace_ = a
        };
        ub.LOCAL_MARKER = "local_marker_1";
        ub.prototype.registerMarker = function(a, b) {
            this.markers_[a] && this.unregisterMarker(a);
            b.setDrawer(this.workspace_.getRenderer().makeMarkerDrawer(this.workspace_, b));
            this.setMarkerSvg(b.getDrawer().createDom());
            this.markers_[a] = b
        }
        ;
        ub.prototype.unregisterMarker = function(a) {
            var b = this.markers_[a];
            if (b)
                b.dispose(),
                delete this.markers_[a];
            else
                throw Error("Marker with ID " + a + " does not exist. Can only unregister markers that exist.");
        }
        ;
        ub.prototype.getCursor = function() {
            return this.cursor_
        }
        ;
        ub.prototype.getMarker = function(a) {
            return this.markers_[a] || null
        }
        ;
        ub.prototype.setCursor = function(a) {
            this.cursor_ && this.cursor_.getDrawer() && this.cursor_.getDrawer().dispose();
            if (this.cursor_ = a)
                a = this.workspace_.getRenderer().makeMarkerDrawer(this.workspace_, this.cursor_),
                this.cursor_.setDrawer(a),
                this.setCursorSvg(this.cursor_.getDrawer().createDom())
        }
        ;
        ub.prototype.setCursorSvg = function(a) {
            a ? (this.workspace_.getBlockCanvas().appendChild(a),
            this.cursorSvg_ = a) : this.cursorSvg_ = null
        }
        ;
        ub.prototype.setMarkerSvg = function(a) {
            a ? this.workspace_.getBlockCanvas() && (this.cursorSvg_ ? this.workspace_.getBlockCanvas().insertBefore(a, this.cursorSvg_) : this.workspace_.getBlockCanvas().appendChild(a)) : this.markerSvg_ = null
        }
        ;
        ub.prototype.updateMarkers = function() {
            this.workspace_.keyboardAccessibilityMode && this.cursorSvg_ && this.workspace_.getCursor().draw()
        }
        ;
        ub.prototype.dispose = function() {
            for (var a = Object.keys(this.markers_), b = 0, c; c = a[b]; b++)
                this.unregisterMarker(c);
            this.markers_ = null;
            this.cursor_ && (this.cursor_.dispose(),
            this.cursor_ = null)
        }
        ;
        var gb = {
            BlockChange: function(a, b, c, d, f) {
                gb.BlockChange.superClass_.constructor.call(this, a);
                a && (this.element = "undefined" === typeof b ? "" : b,
                this.name = "undefined" === typeof c ? "" : c,
                this.oldValue = "undefined" === typeof d ? "" : d,
                this.newValue = "undefined" === typeof f ? "" : f)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(gb.BlockChange, Mb.BlockBase);
        gb.BlockChange.prototype.type = k.CHANGE;
        gb.BlockChange.prototype.toJson = function() {
            var a = gb.BlockChange.superClass_.toJson.call(this);
            a.element = this.element;
            this.name && (a.name = this.name);
            a.oldValue = this.oldValue;
            a.newValue = this.newValue;
            return a
        }
        ;
        gb.BlockChange.prototype.fromJson = function(a) {
            gb.BlockChange.superClass_.fromJson.call(this, a);
            this.element = a.element;
            this.name = a.name;
            this.oldValue = a.oldValue;
            this.newValue = a.newValue
        }
        ;
        gb.BlockChange.prototype.isNull = function() {
            return this.oldValue === this.newValue
        }
        ;
        gb.BlockChange.prototype.run = function(a) {
            var b = this.getEventWorkspace_().getBlockById(this.blockId);
            if (b)
                switch (b.mutator && b.mutator.setVisible(!1),
                a = a ? this.newValue : this.oldValue,
                this.element) {
                case "field":
                    (b = b.getField(this.name)) ? b.setValue(a) : console.warn("Can't set non-existent field: " + this.name);
                    break;
                case "comment":
                    b.setCommentText(a || null);
                    break;
                case "collapsed":
                    b.setCollapsed(!!a);
                    break;
                case "disabled":
                    b.setEnabled(!a);
                    break;
                case "inline":
                    b.setInputsInline(!!a);
                    break;
                case "mutation":
                    var c = gb.BlockChange.getExtraBlockState_(b);
                    b.loadExtraState ? b.loadExtraState(JSON.parse(a || "{}")) : b.domToMutation && b.domToMutation((0,
                    e.module$exports$Blockly$Xml.textToDom)(a || "<mutation/>"));
                    (0,
                    k.fire)(new gb.BlockChange(b,"mutation",null,c,a));
                    break;
                default:
                    console.warn("Unknown change type: " + this.element)
                }
            else
                console.warn("Can't change non-existent block: " + this.blockId)
        }
        ;
        gb.BlockChange.getExtraBlockState_ = function(a) {
            return a.saveExtraState ? (a = a.saveExtraState()) ? JSON.stringify(a) : "" : a.mutationToDom ? (a = a.mutationToDom()) ? (0,
            e.module$exports$Blockly$Xml.domToText)(a) : "" : ""
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.CHANGE, gb.BlockChange);
        var Pb = {}
          , ce = 0
          , zd = null;
        Pb.disposeUiEffect = function(a) {
            var b = a.workspace
              , c = a.getSvgRoot();
            b.getAudioManager().play("delete");
            a = b.getSvgXY(c);
            c = c.cloneNode(!0);
            c.translateX_ = a.x;
            c.translateY_ = a.y;
            c.setAttribute("transform", "translate(" + a.x + "," + a.y + ")");
            b.getParentSvg().appendChild(c);
            c.bBox_ = c.getBBox();
            Ge(c, b.RTL, new Date, b.scale)
        }
        ;
        var Ge = function(a, b, c, d) {
            var f = (new Date - c) / 150;
            1 < f ? (0,
            n.removeNode)(a) : (a.setAttribute("transform", "translate(" + (a.translateX_ + (b ? -1 : 1) * a.bBox_.width * d / 2 * f) + "," + (a.translateY_ + a.bBox_.height * d * f) + ") scale(" + (1 - f) * d + ")"),
            setTimeout(Ge, 10, a, b, c, d))
        };
        Pb.connectionUiEffect = function(a) {
            var b = a.workspace
              , c = b.scale;
            b.getAudioManager().play("click");
            if (!(1 > c)) {
                var d = b.getSvgXY(a.getSvgRoot());
                a.outputConnection ? (d.x += (a.RTL ? 3 : -3) * c,
                d.y += 13 * c) : a.previousConnection && (d.x += (a.RTL ? -23 : 23) * c,
                d.y += 3 * c);
                a = (0,
                n.createSvgElement)(u.CIRCLE, {
                    cx: d.x,
                    cy: d.y,
                    r: 0,
                    fill: "none",
                    stroke: "#888",
                    "stroke-width": 10
                }, b.getParentSvg());
                He(a, new Date, c)
            }
        }
        ;
        var He = function(a, b, c) {
            var d = (new Date - b) / 150;
            1 < d ? (0,
            n.removeNode)(a) : (a.setAttribute("r", 25 * d * c),
            a.style.opacity = 1 - d,
            ce = setTimeout(He, 10, a, b, c))
        };
        Pb.disconnectUiEffect = function(a) {
            a.workspace.getAudioManager().play("disconnect");
            if (!(1 > a.workspace.scale)) {
                var b = a.getHeightWidth().height;
                b = Math.atan(10 / b) / Math.PI * 180;
                a.RTL || (b *= -1);
                Ie(a.getSvgRoot(), b, new Date)
            }
        }
        ;
        var Ie = function(a, b, c) {
            var d = (new Date - c) / 200;
            1 < d ? a.skew_ = "" : (a.skew_ = "skewX(" + Math.round(Math.sin(d * Math.PI * 3) * (1 - d) * b) + ")",
            zd = a,
            ce = setTimeout(Ie, 10, a, b, c));
            a.setAttribute("transform", a.translate_ + a.skew_)
        };
        Pb.disconnectUiStop = function() {
            if (zd) {
                clearTimeout(ce);
                var a = zd;
                a.skew_ = "";
                a.setAttribute("transform", a.translate_);
                zd = null
            }
        }
        ;
        var oa = function() {
            this.componentData_ = Object.create(null);
            this.capabilityToComponentIds_ = Object.create(null)
        };
        oa.prototype.addComponent = function(a, b) {
            var c = a.component.id;
            if (!b && this.componentData_[c])
                throw Error('Plugin "' + c + '" with capabilities "' + this.componentData_[c].capabilities + '" already added.');
            this.componentData_[c] = a;
            b = [];
            for (var d = 0; d < a.capabilities.length; d++) {
                var f = String(a.capabilities[d]).toLowerCase();
                b.push(f);
                void 0 === this.capabilityToComponentIds_[f] ? this.capabilityToComponentIds_[f] = [c] : this.capabilityToComponentIds_[f].push(c)
            }
            this.componentData_[c].capabilities = b
        }
        ;
        oa.prototype.removeComponent = function(a) {
            var b = this.componentData_[a];
            if (b) {
                for (var c = 0; c < b.capabilities.length; c++) {
                    var d = String(b.capabilities[c]).toLowerCase();
                    (0,
                    zb)(this.capabilityToComponentIds_[d], a)
                }
                delete this.componentData_[a]
            }
        }
        ;
        oa.prototype.addCapability = function(a, b) {
            if (!this.getComponent(a))
                throw Error('Cannot add capability, "' + b + '". Plugin "' + a + '" has not been added to the ComponentManager');
            this.hasCapability(a, b) ? console.warn('Plugin "' + a + 'already has capability "' + b + '"') : (b = String(b).toLowerCase(),
            this.componentData_[a].capabilities.push(b),
            this.capabilityToComponentIds_[b].push(a))
        }
        ;
        oa.prototype.removeCapability = function(a, b) {
            if (!this.getComponent(a))
                throw Error('Cannot remove capability, "' + b + '". Plugin "' + a + '" has not been added to the ComponentManager');
            this.hasCapability(a, b) ? (b = String(b).toLowerCase(),
            (0,
            zb)(this.componentData_[a].capabilities, b),
            (0,
            zb)(this.capabilityToComponentIds_[b], a)) : console.warn('Plugin "' + a + "doesn't have capability \"" + b + '" to remove')
        }
        ;
        oa.prototype.hasCapability = function(a, b) {
            b = String(b).toLowerCase();
            return -1 !== this.componentData_[a].capabilities.indexOf(b)
        }
        ;
        oa.prototype.getComponent = function(a) {
            return this.componentData_[a] && this.componentData_[a].component
        }
        ;
        oa.prototype.getComponents = function(a, b) {
            a = String(a).toLowerCase();
            a = this.capabilityToComponentIds_[a];
            if (!a)
                return [];
            var c = [];
            if (b) {
                var d = []
                  , f = this.componentData_;
                a.forEach(function(m) {
                    d.push(f[m])
                });
                d.sort(function(m, r) {
                    return m.weight - r.weight
                });
                d.forEach(function(m) {
                    c.push(m.component)
                })
            } else {
                var g = this.componentData_;
                a.forEach(function(m) {
                    c.push(g[m].component)
                })
            }
            return c
        }
        ;
        oa.Capability = function(a) {
            this.name_ = a
        }
        ;
        oa.Capability.prototype.toString = function() {
            return this.name_
        }
        ;
        oa.Capability.POSITIONABLE = new oa.Capability("positionable");
        oa.Capability.DRAG_TARGET = new oa.Capability("drag_target");
        oa.Capability.DELETE_AREA = new oa.Capability("delete_area");
        oa.Capability.AUTOHIDEABLE = new oa.Capability("autohideable");
        var Ua = {}
          , Je = function(a, b) {
            window.alert(a);
            b && b()
        }
          , Ke = function(a, b) {
            b(window.confirm(a))
        }
          , Le = function(a, b, c) {
            c(window.prompt(a, b))
        };
        Ua.alert = function(a, b) {
            Je(a, b)
        }
        ;
        Ua.setAlert = function(a) {
            Je = a
        }
        ;
        Ua.confirm = function(a, b) {
            Ke(a, b)
        }
        ;
        Ua.setConfirm = function(a) {
            Ke = a
        }
        ;
        Ua.prompt = function(a, b, c) {
            Le(a, b, c)
        }
        ;
        Ua.setPrompt = function(a) {
            Le = a
        }
        ;
        var $b = {
            VarBase: function(a) {
                $b.VarBase.superClass_.constructor.call(this);
                this.varId = (this.isBlank = "undefined" === typeof a) ? "" : a.getId();
                this.workspaceId = this.isBlank ? "" : a.workspace.id
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)($b.VarBase, Gb);
        $b.VarBase.prototype.toJson = function() {
            var a = $b.VarBase.superClass_.toJson.call(this);
            a.varId = this.varId;
            return a
        }
        ;
        $b.VarBase.prototype.fromJson = function(a) {
            $b.VarBase.superClass_.toJson.call(this);
            this.varId = a.varId
        }
        ;
        var ac = {
            VarCreate: function(a) {
                ac.VarCreate.superClass_.constructor.call(this, a);
                a && (this.varType = a.type,
                this.varName = a.name)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(ac.VarCreate, $b.VarBase);
        ac.VarCreate.prototype.type = k.VAR_CREATE;
        ac.VarCreate.prototype.toJson = function() {
            var a = ac.VarCreate.superClass_.toJson.call(this);
            a.varType = this.varType;
            a.varName = this.varName;
            return a
        }
        ;
        ac.VarCreate.prototype.fromJson = function(a) {
            ac.VarCreate.superClass_.fromJson.call(this, a);
            this.varType = a.varType;
            this.varName = a.varName
        }
        ;
        ac.VarCreate.prototype.run = function(a) {
            var b = this.getEventWorkspace_();
            a ? b.createVariable(this.varName, this.varType, this.varId) : b.deleteVariableById(this.varId)
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.VAR_CREATE, ac.VarCreate);
        var Hc = function(a, b, c, d) {
            this.workspace = a;
            this.name = b;
            this.type = c || "";
            this.id_ = d || (0,
            bb.genUid)();
            (0,
            k.fire)(new ((0,
            k.get)(k.VAR_CREATE))(this))
        };
        Hc.prototype.getId = function() {
            return this.id_
        }
        ;
        Hc.compareByName = function(a, b) {
            return a.name.localeCompare(b.name, void 0, {
                sensitivity: "base"
            })
        }
        ;
        e.module$exports$Blockly$Variables = {
            CATEGORY_NAME: "VARIABLE",
            allUsedVarModels: function(a) {
                var b = a.getAllBlocks(!1);
                a = Object.create(null);
                for (var c = 0; c < b.length; c++) {
                    var d = b[c].getVarModels();
                    if (d)
                        for (var f = 0; f < d.length; f++) {
                            var g = d[f]
                              , m = g.getId();
                            m && (a[m] = g)
                        }
                }
                b = [];
                for (var r in a)
                    b.push(a[r]);
                return b
            }
        };
        var Me = {};
        e.module$exports$Blockly$Variables.allDeveloperVariables = function(a) {
            a = a.getAllBlocks(!1);
            for (var b = Object.create(null), c = 0, d; d = a[c]; c++) {
                var f = d.getDeveloperVariables;
                !f && d.getDeveloperVars && (f = d.getDeveloperVars,
                Me[d.type] || (console.warn("Function getDeveloperVars() deprecated. Use getDeveloperVariables() (block type '" + d.type + "')"),
                Me[d.type] = !0));
                if (f)
                    for (d = f(),
                    f = 0; f < d.length; f++)
                        b[d[f]] = !0
            }
            return Object.keys(b)
        }
        ;
        e.module$exports$Blockly$Variables.flyoutCategory = function(a) {
            var b = []
              , c = document.createElement("button");
            c.setAttribute("text", "%{BKY_NEW_VARIABLE}");
            c.setAttribute("callbackKey", "CREATE_VARIABLE");
            a.registerButtonCallback("CREATE_VARIABLE", function(d) {
                (0,
                e.module$exports$Blockly$Variables.createVariableButtonHandler)(d.getTargetWorkspace())
            });
            b.push(c);
            a = (0,
            e.module$exports$Blockly$Variables.flyoutCategoryBlocks)(a);
            return b = b.concat(a)
        }
        ;
        e.module$exports$Blockly$Variables.flyoutCategoryBlocks = function(a) {
            a = a.getVariablesOfType("");
            var b = [];
            if (0 < a.length) {
                var c = a[a.length - 1];
                if (e.module$exports$Blockly$blocks.Blocks.variables_set) {
                    var d = (0,
                    e.module$exports$Blockly$utils$xml.createElement)("block");
                    d.setAttribute("type", "variables_set");
                    d.setAttribute("gap", e.module$exports$Blockly$blocks.Blocks.math_change ? 8 : 24);
                    d.appendChild((0,
                    e.module$exports$Blockly$Variables.generateVariableFieldDom)(c));
                    b.push(d)
                }
                e.module$exports$Blockly$blocks.Blocks.math_change && (d = (0,
                e.module$exports$Blockly$utils$xml.createElement)("block"),
                d.setAttribute("type", "math_change"),
                d.setAttribute("gap", e.module$exports$Blockly$blocks.Blocks.variables_get ? 20 : 8),
                d.appendChild((0,
                e.module$exports$Blockly$Variables.generateVariableFieldDom)(c)),
                c = (0,
                e.module$exports$Blockly$Xml.textToDom)('<value name="DELTA"><shadow type="math_number"><field name="NUM">1</field></shadow></value>'),
                d.appendChild(c),
                b.push(d));
                if (e.module$exports$Blockly$blocks.Blocks.variables_get)
                    for (a.sort(Hc.compareByName),
                    c = 0; d = a[c]; c++) {
                        var f = (0,
                        e.module$exports$Blockly$utils$xml.createElement)("block");
                        f.setAttribute("type", "variables_get");
                        f.setAttribute("gap", 8);
                        f.appendChild((0,
                        e.module$exports$Blockly$Variables.generateVariableFieldDom)(d));
                        b.push(f)
                    }
            }
            return b
        }
        ;
        e.module$exports$Blockly$Variables.VAR_LETTER_OPTIONS = "ijkmnopqrstuvwxyzabcdefgh";
        e.module$exports$Blockly$Variables.generateUniqueName = function(a) {
            return (0,
            e.module$exports$Blockly$Variables.generateUniqueNameFromOptions)(e.module$exports$Blockly$Variables.VAR_LETTER_OPTIONS.charAt(0), a.getAllVariableNames())
        }
        ;
        e.module$exports$Blockly$Variables.generateUniqueNameFromOptions = function(a, b) {
            if (!b.length)
                return a;
            for (var c = e.module$exports$Blockly$Variables.VAR_LETTER_OPTIONS, d = "", f = c.indexOf(a); ; ) {
                for (var g = !1, m = 0; m < b.length; m++)
                    if (b[m].toLowerCase() === a) {
                        g = !0;
                        break
                    }
                if (!g)
                    return a;
                f++;
                f === c.length && (f = 0,
                d = Number(d) + 1);
                a = c.charAt(f) + d
            }
        }
        ;
        e.module$exports$Blockly$Variables.createVariableButtonHandler = function(a, b, c) {
            var d = c || ""
              , f = function(g) {
                (0,
                e.module$exports$Blockly$Variables.promptName)(e.module$exports$Blockly$Msg.Msg.NEW_VARIABLE_TITLE, g, function(m) {
                    if (m) {
                        var r = (0,
                        e.module$exports$Blockly$Variables.nameUsedWithAnyType)(m, a);
                        if (r) {
                            if (r.type === d)
                                var B = e.module$exports$Blockly$Msg.Msg.VARIABLE_ALREADY_EXISTS.replace("%1", r.name);
                            else
                                B = e.module$exports$Blockly$Msg.Msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE,
                                B = B.replace("%1", r.name).replace("%2", r.type);
                            (0,
                            Ua.alert)(B, function() {
                                f(m)
                            })
                        } else
                            a.createVariable(m, d),
                            b && b(m)
                    } else
                        b && b(null)
                })
            };
            f("")
        }
        ;
        e.module$exports$Blockly$Variables.renameVariable = function(a, b, c) {
            var d = function(f) {
                var g = e.module$exports$Blockly$Msg.Msg.RENAME_VARIABLE_TITLE.replace("%1", b.name);
                (0,
                e.module$exports$Blockly$Variables.promptName)(g, f, function(m) {
                    if (m) {
                        var r = jf(m, b.type, a);
                        r ? (r = e.module$exports$Blockly$Msg.Msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE.replace("%1", r.name).replace("%2", r.type),
                        (0,
                        Ua.alert)(r, function() {
                            d(m)
                        })) : (a.renameVariableById(b.getId(), m),
                        c && c(m))
                    } else
                        c && c(null)
                })
            };
            d("")
        }
        ;
        e.module$exports$Blockly$Variables.promptName = function(a, b, c) {
            (0,
            Ua.prompt)(a, b, function(d) {
                d && (d = d.replace(/[\s\xa0]+/g, " ").trim(),
                d === e.module$exports$Blockly$Msg.Msg.RENAME_VARIABLE || d === e.module$exports$Blockly$Msg.Msg.NEW_VARIABLE) && (d = null);
                c(d)
            })
        }
        ;
        var jf = function(a, b, c) {
            c = c.getVariableMap().getAllVariables();
            a = a.toLowerCase();
            for (var d = 0, f; f = c[d]; d++)
                if (f.name.toLowerCase() === a && f.type !== b)
                    return f;
            return null
        };
        e.module$exports$Blockly$Variables.nameUsedWithAnyType = function(a, b) {
            b = b.getVariableMap().getAllVariables();
            a = a.toLowerCase();
            for (var c = 0, d; d = b[c]; c++)
                if (d.name.toLowerCase() === a)
                    return d;
            return null
        }
        ;
        e.module$exports$Blockly$Variables.generateVariableFieldDom = function(a) {
            var b = (0,
            e.module$exports$Blockly$utils$xml.createElement)("field");
            b.setAttribute("name", "VAR");
            b.setAttribute("id", a.getId());
            b.setAttribute("variabletype", a.type);
            a = (0,
            e.module$exports$Blockly$utils$xml.createTextNode)(a.name);
            b.appendChild(a);
            return b
        }
        ;
        e.module$exports$Blockly$Variables.getOrCreateVariablePackage = function(a, b, c, d) {
            var f = (0,
            e.module$exports$Blockly$Variables.getVariable)(a, b, c, d);
            f || (f = a.getPotentialVariableMap(),
            c || (c = e.module$exports$Blockly$Variables.generateUniqueName(a.isFlyout ? a.targetWorkspace : a)),
            f = f ? f.createVariable(c, d, b) : a.createVariable(c, d, b));
            return f
        }
        ;
        e.module$exports$Blockly$Variables.getVariable = function(a, b, c, d) {
            var f = a.getPotentialVariableMap()
              , g = null;
            if (b && (g = a.getVariableById(b),
            !g && f && (g = f.getVariableById(b)),
            g))
                return g;
            if (c) {
                if (void 0 === d)
                    throw Error("Tried to look up a variable by name without a type");
                g = a.getVariable(c, d);
                !g && f && (g = f.getVariable(c, d))
            }
            return g
        }
        ;
        e.module$exports$Blockly$Variables.getAddedVariables = function(a, b) {
            a = a.getAllVariables();
            var c = [];
            if (b.length !== a.length)
                for (var d = 0; d < a.length; d++) {
                    var f = a[d];
                    -1 === b.indexOf(f) && c.push(f)
                }
            return c
        }
        ;
        e.module$exports$Blockly$Names = {
            Names: function(a, b) {
                this.variablePrefix_ = b || "";
                this.reservedDict_ = Object.create(null);
                if (a)
                    for (a = a.split(","),
                    b = 0; b < a.length; b++)
                        this.reservedDict_[a[b]] = !0;
                this.reset()
            },
            NameType: {
                DEVELOPER_VARIABLE: "DEVELOPER_VARIABLE",
                VARIABLE: "VARIABLE",
                PROCEDURE: "PROCEDURE"
            }
        };
        e.module$exports$Blockly$Names.Names.DEVELOPER_VARIABLE_TYPE = e.module$exports$Blockly$Names.NameType.DEVELOPER_VARIABLE;
        e.module$exports$Blockly$Names.Names.prototype.reset = function() {
            this.db_ = Object.create(null);
            this.dbReverse_ = Object.create(null);
            this.variableMap_ = null
        }
        ;
        e.module$exports$Blockly$Names.Names.prototype.setVariableMap = function(a) {
            this.variableMap_ = a
        }
        ;
        e.module$exports$Blockly$Names.Names.prototype.getNameForUserVariable_ = function(a) {
            return this.variableMap_ ? (a = this.variableMap_.getVariableById(a)) ? a.name : null : (console.warn("Deprecated call to Names.prototype.getName without defining a variable map. To fix, add the following code in your generator's init() function:\nBlockly.YourGeneratorName.nameDB_.setVariableMap(workspace.getVariableMap());"),
            null)
        }
        ;
        e.module$exports$Blockly$Names.Names.prototype.populateVariables = function(a) {
            a = (0,
            e.module$exports$Blockly$Variables.allUsedVarModels)(a);
            for (var b = 0; b < a.length; b++)
                this.getName(a[b].getId(), e.module$exports$Blockly$Names.NameType.VARIABLE)
        }
        ;
        e.module$exports$Blockly$Names.Names.prototype.populateProcedures = function(a) {
            a = e.module$exports$Blockly$Procedures.allProcedures(a);
            a = a[0].concat(a[1]);
            for (var b = 0; b < a.length; b++)
                this.getName(a[b][0], e.module$exports$Blockly$Names.NameType.PROCEDURE)
        }
        ;
        e.module$exports$Blockly$Names.Names.prototype.getName = function(a, b) {
            var c = a;
            b === e.module$exports$Blockly$Names.NameType.VARIABLE && (a = this.getNameForUserVariable_(a)) && (c = a);
            a = c.toLowerCase();
            var d = b === e.module$exports$Blockly$Names.NameType.VARIABLE || b === e.module$exports$Blockly$Names.NameType.DEVELOPER_VARIABLE ? this.variablePrefix_ : "";
            b in this.db_ || (this.db_[b] = Object.create(null));
            var f = this.db_[b];
            if (a in f)
                return d + f[a];
            b = this.getDistinctName(c, b);
            f[a] = b.substr(d.length);
            return b
        }
        ;
        e.module$exports$Blockly$Names.Names.prototype.getUserNames = function(a) {
            return Object.keys(this.db_[a] || {})
        }
        ;
        e.module$exports$Blockly$Names.Names.prototype.getDistinctName = function(a, b) {
            a = this.safeName_(a);
            for (var c = ""; this.dbReverse_[a + c] || a + c in this.reservedDict_; )
                c = c ? c + 1 : 2;
            a += c;
            this.dbReverse_[a] = !0;
            return (b === e.module$exports$Blockly$Names.NameType.VARIABLE || b === e.module$exports$Blockly$Names.NameType.DEVELOPER_VARIABLE ? this.variablePrefix_ : "") + a
        }
        ;
        e.module$exports$Blockly$Names.Names.prototype.safeName_ = function(a) {
            a ? (a = encodeURI(a.replace(/ /g, "_")).replace(/[^\w]/g, "_"),
            -1 !== "0123456789".indexOf(a[0]) && (a = "my_" + a)) : a = e.module$exports$Blockly$Msg.Msg.UNNAMED_KEY || "unnamed";
            return a
        }
        ;
        e.module$exports$Blockly$Names.Names.equals = function(a, b) {
            return a.toLowerCase() === b.toLowerCase()
        }
        ;
        var bc = {
            VarDelete: function(a) {
                bc.VarDelete.superClass_.constructor.call(this, a);
                a && (this.varType = a.type,
                this.varName = a.name)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(bc.VarDelete, $b.VarBase);
        bc.VarDelete.prototype.type = k.VAR_DELETE;
        bc.VarDelete.prototype.toJson = function() {
            var a = bc.VarDelete.superClass_.toJson.call(this);
            a.varType = this.varType;
            a.varName = this.varName;
            return a
        }
        ;
        bc.VarDelete.prototype.fromJson = function(a) {
            bc.VarDelete.superClass_.fromJson.call(this, a);
            this.varType = a.varType;
            this.varName = a.varName
        }
        ;
        bc.VarDelete.prototype.run = function(a) {
            var b = this.getEventWorkspace_();
            a ? b.deleteVariableById(this.varId) : b.createVariable(this.varName, this.varType, this.varId)
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.VAR_DELETE, bc.VarDelete);
        var cc = {
            VarRename: function(a, b) {
                cc.VarRename.superClass_.constructor.call(this, a);
                a && (this.oldName = a.name,
                this.newName = "undefined" === typeof b ? "" : b)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(cc.VarRename, $b.VarBase);
        cc.VarRename.prototype.type = k.VAR_RENAME;
        cc.VarRename.prototype.toJson = function() {
            var a = cc.VarRename.superClass_.toJson.call(this);
            a.oldName = this.oldName;
            a.newName = this.newName;
            return a
        }
        ;
        cc.VarRename.prototype.fromJson = function(a) {
            cc.VarRename.superClass_.fromJson.call(this, a);
            this.oldName = a.oldName;
            this.newName = a.newName
        }
        ;
        cc.VarRename.prototype.run = function(a) {
            var b = this.getEventWorkspace_();
            a ? b.renameVariableById(this.varId, this.newName) : b.renameVariableById(this.varId, this.oldName)
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.VAR_RENAME, cc.VarRename);
        var Za = function(a) {
            this.variableMap_ = Object.create(null);
            this.workspace = a
        };
        Za.prototype.clear = function() {
            this.variableMap_ = Object.create(null)
        }
        ;
        Za.prototype.renameVariable = function(a, b) {
            var c = this.getVariable(b, a.type)
              , d = this.workspace.getAllBlocks(!1);
            (0,
            k.setGroup)(!0);
            try {
                c && c.getId() !== a.getId() ? this.renameVariableWithConflict_(a, b, c, d) : this.renameVariableAndUses_(a, b, d)
            } finally {
                (0,
                k.setGroup)(!1)
            }
        }
        ;
        Za.prototype.renameVariableById = function(a, b) {
            var c = this.getVariableById(a);
            if (!c)
                throw Error("Tried to rename a variable that didn't exist. ID: " + a);
            this.renameVariable(c, b)
        }
        ;
        Za.prototype.renameVariableAndUses_ = function(a, b, c) {
            (0,
            k.fire)(new ((0,
            k.get)(k.VAR_RENAME))(a,b));
            a.name = b;
            for (b = 0; b < c.length; b++)
                c[b].updateVarName(a)
        }
        ;
        Za.prototype.renameVariableWithConflict_ = function(a, b, c, d) {
            var f = a.type;
            b !== c.name && this.renameVariableAndUses_(c, b, d);
            for (b = 0; b < d.length; b++)
                d[b].renameVarById(a.getId(), c.getId());
            (0,
            k.fire)(new ((0,
            k.get)(k.VAR_DELETE))(a));
            (0,
            zb)(this.variableMap_[f], a)
        }
        ;
        Za.prototype.createVariable = function(a, b, c) {
            var d = this.getVariable(a, b);
            if (d) {
                if (c && d.getId() !== c)
                    throw Error('Variable "' + a + '" is already in use and its id is "' + d.getId() + '" which conflicts with the passed in id, "' + c + '".');
                return d
            }
            if (c && this.getVariableById(c))
                throw Error('Variable id, "' + c + '", is already in use.');
            d = c || (0,
            bb.genUid)();
            b = b || "";
            d = new Hc(this.workspace,a,b,d);
            a = this.variableMap_[b] || [];
            a.push(d);
            delete this.variableMap_[b];
            this.variableMap_[b] = a;
            return d
        }
        ;
        Za.prototype.deleteVariable = function(a) {
            for (var b = a.getId(), c = this.variableMap_[a.type], d = 0; d < c.length; d++)
                if (c[d].getId() === b) {
                    c.splice(d, 1);
                    (0,
                    k.fire)(new ((0,
                    k.get)(k.VAR_DELETE))(a));
                    break
                }
        }
        ;
        Za.prototype.deleteVariableById = function(a) {
            var b = this.getVariableById(a);
            if (b) {
                var c = b.name
                  , d = this.getVariableUsesById(a);
                a = 0;
                for (var f = void 0; f = d[a]; a++)
                    if ("procedures_defnoreturn" === f.type || "procedures_defreturn" === f.type) {
                        a = String(f.getFieldValue("NAME"));
                        c = e.module$exports$Blockly$Msg.Msg.CANNOT_DELETE_VARIABLE_PROCEDURE.replace("%1", c).replace("%2", a);
                        (0,
                        Ua.alert)(c);
                        return
                    }
                var g = this;
                1 < d.length ? (c = e.module$exports$Blockly$Msg.Msg.DELETE_VARIABLE_CONFIRMATION.replace("%1", String(d.length)).replace("%2", c),
                (0,
                Ua.confirm)(c, function(m) {
                    m && b && g.deleteVariableInternal(b, d)
                })) : g.deleteVariableInternal(b, d)
            } else
                console.warn("Can't delete non-existent variable: " + a)
        }
        ;
        Za.prototype.deleteVariableInternal = function(a, b) {
            var c = (0,
            k.getGroup)();
            c || (0,
            k.setGroup)(!0);
            try {
                for (var d = 0; d < b.length; d++)
                    b[d].dispose(!0);
                this.deleteVariable(a)
            } finally {
                c || (0,
                k.setGroup)(!1)
            }
        }
        ;
        Za.prototype.getVariable = function(a, b) {
            if (b = this.variableMap_[b || ""])
                for (var c = 0, d; d = b[c]; c++)
                    if (e.module$exports$Blockly$Names.Names.equals(d.name, a))
                        return d;
            return null
        }
        ;
        Za.prototype.getVariableById = function(a) {
            for (var b = Object.keys(this.variableMap_), c = 0; c < b.length; c++)
                for (var d = b[c], f = 0, g; g = this.variableMap_[d][f]; f++)
                    if (g.getId() === a)
                        return g;
            return null
        }
        ;
        Za.prototype.getVariablesOfType = function(a) {
            return (a = this.variableMap_[a || ""]) ? a.slice() : []
        }
        ;
        Za.prototype.getVariableTypes = function(a) {
            var b = {};
            (0,
            e.module$exports$Blockly$utils$object.mixin)(b, this.variableMap_);
            a && a.getPotentialVariableMap() && (0,
            e.module$exports$Blockly$utils$object.mixin)(b, a.getPotentialVariableMap().variableMap_);
            a = Object.keys(b);
            b = !1;
            for (var c = 0; c < a.length; c++)
                "" === a[c] && (b = !0);
            b || a.push("");
            return a
        }
        ;
        Za.prototype.getAllVariables = function() {
            var a = [], b;
            for (b in this.variableMap_)
                a = a.concat(this.variableMap_[b]);
            return a
        }
        ;
        Za.prototype.getAllVariableNames = function() {
            var a = [], b;
            for (b in this.variableMap_)
                for (var c = this.variableMap_[b], d = 0, f; f = c[d]; d++)
                    a.push(f.name);
            return a
        }
        ;
        Za.prototype.getVariableUsesById = function(a) {
            for (var b = [], c = this.workspace.getAllBlocks(!1), d = 0; d < c.length; d++) {
                var f = c[d].getVarModels();
                if (f)
                    for (var g = 0; g < f.length; g++)
                        f[g].getId() === a && b.push(c[d])
            }
            return b
        }
        ;
        var Ab = {
            BlockMove: function(a) {
                Ab.BlockMove.superClass_.constructor.call(this, a);
                a && (a.isShadow() && (this.recordUndo = !1),
                a = this.currentLocation_(),
                this.oldParentId = a.parentId,
                this.oldInputName = a.inputName,
                this.oldCoordinate = a.coordinate)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Ab.BlockMove, Mb.BlockBase);
        Ab.BlockMove.prototype.type = k.MOVE;
        Ab.BlockMove.prototype.toJson = function() {
            var a = Ab.BlockMove.superClass_.toJson.call(this);
            this.newParentId && (a.newParentId = this.newParentId);
            this.newInputName && (a.newInputName = this.newInputName);
            this.newCoordinate && (a.newCoordinate = Math.round(this.newCoordinate.x) + "," + Math.round(this.newCoordinate.y));
            this.recordUndo || (a.recordUndo = this.recordUndo);
            return a
        }
        ;
        Ab.BlockMove.prototype.fromJson = function(a) {
            Ab.BlockMove.superClass_.fromJson.call(this, a);
            this.newParentId = a.newParentId;
            this.newInputName = a.newInputName;
            if (a.newCoordinate) {
                var b = a.newCoordinate.split(",");
                this.newCoordinate = new J(Number(b[0]),Number(b[1]))
            }
            void 0 !== a.recordUndo && (this.recordUndo = a.recordUndo)
        }
        ;
        Ab.BlockMove.prototype.recordNew = function() {
            var a = this.currentLocation_();
            this.newParentId = a.parentId;
            this.newInputName = a.inputName;
            this.newCoordinate = a.coordinate
        }
        ;
        Ab.BlockMove.prototype.currentLocation_ = function() {
            var a = this.getEventWorkspace_().getBlockById(this.blockId)
              , b = {}
              , c = a.getParent();
            if (c) {
                if (b.parentId = c.id,
                a = c.getInputWithBlock(a))
                    b.inputName = a.name
            } else
                b.coordinate = a.getRelativeToSurfaceXY();
            return b
        }
        ;
        Ab.BlockMove.prototype.isNull = function() {
            return this.oldParentId === this.newParentId && this.oldInputName === this.newInputName && J.equals(this.oldCoordinate, this.newCoordinate)
        }
        ;
        Ab.BlockMove.prototype.run = function(a) {
            var b = this.getEventWorkspace_()
              , c = b.getBlockById(this.blockId);
            if (c) {
                var d = a ? this.newParentId : this.oldParentId
                  , f = a ? this.newInputName : this.oldInputName;
                a = a ? this.newCoordinate : this.oldCoordinate;
                if (d) {
                    var g = b.getBlockById(d);
                    if (!g) {
                        console.warn("Can't connect to non-existent block: " + d);
                        return
                    }
                }
                c.getParent() && c.unplug();
                if (a)
                    f = c.getRelativeToSurfaceXY(),
                    c.moveBy(a.x - f.x, a.y - f.y);
                else {
                    b = c.outputConnection;
                    if (!b || c.previousConnection && c.previousConnection.isConnected())
                        b = c.previousConnection;
                    c = b.type;
                    if (f) {
                        if (c = g.getInput(f))
                            var m = c.connection
                    } else
                        c === e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT && (m = g.nextConnection);
                    m ? b.connect(m) : console.warn("Can't connect to non-existent input: " + f)
                }
            } else
                console.warn("Can't move non-existent block: " + this.blockId)
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.MOVE, Ab.BlockMove);
        var lc = {
            COLLAPSED_INPUT_NAME: "_TEMP_COLLAPSED_INPUT",
            COLLAPSED_FIELD_NAME: "_TEMP_COLLAPSED_FIELD"
        }
          , K = function(a, b) {
            this.sourceBlock_ = a;
            this.type = b
        };
        K.CAN_CONNECT = 0;
        K.REASON_SELF_CONNECTION = 1;
        K.REASON_WRONG_TYPE = 2;
        K.REASON_TARGET_NULL = 3;
        K.REASON_CHECKS_FAILED = 4;
        K.REASON_DIFFERENT_WORKSPACES = 5;
        K.REASON_SHADOW_PARENT = 6;
        K.REASON_DRAG_CHECKS_FAILED = 7;
        K.REASON_PREVIOUS_AND_OUTPUT = 8;
        K.prototype.targetConnection = null;
        K.prototype.disposed = !1;
        K.prototype.check_ = null;
        K.prototype.shadowDom_ = null;
        K.prototype.x = 0;
        K.prototype.y = 0;
        K.prototype.connect_ = function(a) {
            var b = e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE
              , c = this.getSourceBlock()
              , d = a.getSourceBlock();
            a.isConnected() && a.disconnect();
            if (this.isConnected()) {
                var f = this.stashShadowState_()
                  , g = this.targetBlock();
                if (g.isShadow())
                    g.dispose(!1);
                else {
                    this.disconnect();
                    var m = g
                }
                this.applyShadowState_(f)
            }
            var r;
            (0,
            k.isEnabled)() && (r = new ((0,
            k.get)(k.MOVE))(d));
            f = a;
            if (!this || !f)
                throw Error("Cannot connect null connections.");
            this.targetConnection = f;
            f.targetConnection = this;
            d.setParent(c);
            r && (r.recordNew(),
            (0,
            k.fire)(r));
            if (m)
                if (a = this.type === b ? m.outputConnection : m.previousConnection,
                d = K.getConnectionForOrphanedConnection(d, a))
                    a.connect(d);
                else
                    a.onFailedConnect(this)
        }
        ;
        K.prototype.dispose = function() {
            if (this.isConnected()) {
                this.setShadowStateInternal_();
                var a = this.targetBlock();
                a && a.unplug()
            }
            this.disposed = !0
        }
        ;
        K.prototype.getSourceBlock = function() {
            return this.sourceBlock_
        }
        ;
        K.prototype.isSuperior = function() {
            return this.type === e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE || this.type === e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT
        }
        ;
        K.prototype.isConnected = function() {
            return !!this.targetConnection
        }
        ;
        K.prototype.getConnectionChecker = function() {
            return this.sourceBlock_.workspace.connectionChecker
        }
        ;
        K.prototype.onFailedConnect = function(a) {}
        ;
        K.prototype.connect = function(a) {
            if (this.targetConnection === a)
                return !0;
            if (this.getConnectionChecker().canConnect(this, a, !1)) {
                var b = (0,
                k.getGroup)();
                b || (0,
                k.setGroup)(!0);
                this.isSuperior() ? this.connect_(a) : a.connect_(this);
                b || (0,
                k.setGroup)(!1)
            }
            return this.isConnected()
        }
        ;
        var kf = function(a, b) {
            var c = null;
            b = b.outputConnection;
            for (var d = b.getConnectionChecker(), f = 0, g; g = a.inputList[f]; f++)
                if ((g = g.connection) && d.canConnect(b, g, !1)) {
                    if (c)
                        return null;
                    c = g
                }
            return c
        };
        K.getConnectionForOrphanedConnection = function(a, b) {
            if (b.type === e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE) {
                a: {
                    b = b.getSourceBlock();
                    for (var c; c = kf(a, b); )
                        if (a = c.targetBlock(),
                        !a || a.isShadow()) {
                            b = c;
                            break a
                        }
                    b = null
                }
                return b
            }
            a = a.lastConnectionInStack(!0);
            c = b.getConnectionChecker();
            return a && c.canConnect(b, a, !1) ? a : null
        }
        ;
        K.prototype.disconnect = function() {
            var a = this.targetConnection;
            if (!a)
                throw Error("Source connection not connected.");
            if (a.targetConnection !== this)
                throw Error("Target connection not connected to source connection.");
            if (this.isSuperior()) {
                var b = this.sourceBlock_
                  , c = a.getSourceBlock();
                a = this
            } else
                b = a.getSourceBlock(),
                c = this.sourceBlock_;
            var d = (0,
            k.getGroup)();
            d || (0,
            k.setGroup)(!0);
            this.disconnectInternal_(b, c);
            c.isShadow() || a.respawnShadow_();
            d || (0,
            k.setGroup)(!1)
        }
        ;
        K.prototype.disconnectInternal_ = function(a, b) {
            var c;
            (0,
            k.isEnabled)() && (c = new ((0,
            k.get)(k.MOVE))(b));
            this.targetConnection = this.targetConnection.targetConnection = null;
            b.setParent(null);
            c && (c.recordNew(),
            (0,
            k.fire)(c))
        }
        ;
        K.prototype.respawnShadow_ = function() {
            this.createShadowBlock_(!0)
        }
        ;
        K.prototype.targetBlock = function() {
            return this.isConnected() ? this.targetConnection.getSourceBlock() : null
        }
        ;
        K.prototype.onCheckChanged_ = function() {
            !this.isConnected() || this.targetConnection && this.getConnectionChecker().canConnect(this, this.targetConnection, !1) || (this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug()
        }
        ;
        K.prototype.setCheck = function(a) {
            a ? (Array.isArray(a) || (a = [a]),
            this.check_ = a,
            this.onCheckChanged_()) : this.check_ = null;
            return this
        }
        ;
        K.prototype.getCheck = function() {
            return this.check_
        }
        ;
        K.prototype.setShadowDom = function(a) {
            this.setShadowStateInternal_({
                shadowDom: a
            })
        }
        ;
        K.prototype.getShadowDom = function(a) {
            return a && this.targetBlock().isShadow() ? (0,
            e.module$exports$Blockly$Xml.blockToDom)(this.targetBlock()) : this.shadowDom_
        }
        ;
        K.prototype.setShadowState = function(a) {
            this.setShadowStateInternal_({
                shadowState: a
            })
        }
        ;
        K.prototype.getShadowState = function(a) {
            return a && this.targetBlock() && this.targetBlock().isShadow() ? (0,
            Ya.save)(this.targetBlock()) : this.shadowState_
        }
        ;
        K.prototype.neighbours = function(a) {
            return []
        }
        ;
        K.prototype.getParentInput = function() {
            for (var a = null, b = this.sourceBlock_.inputList, c = 0; c < b.length; c++)
                if (b[c].connection === this) {
                    a = b[c];
                    break
                }
            return a
        }
        ;
        K.prototype.toString = function() {
            var a = this.sourceBlock_;
            if (!a)
                return "Orphan Connection";
            if (a.outputConnection === this)
                var b = "Output Connection of ";
            else if (a.previousConnection === this)
                b = "Previous Connection of ";
            else if (a.nextConnection === this)
                b = "Next Connection of ";
            else {
                b = null;
                for (var c = 0, d; d = a.inputList[c]; c++)
                    if (d.connection === this) {
                        b = d;
                        break
                    }
                if (b)
                    b = 'Input "' + b.name + '" connection on ';
                else
                    return console.warn("Connection not actually connected to sourceBlock_"),
                    "Orphan Connection"
            }
            return b + a.toDevString()
        }
        ;
        K.prototype.stashShadowState_ = function() {
            var a = this.getShadowDom(!0)
              , b = this.getShadowState(!0);
            this.shadowState_ = this.shadowDom_ = null;
            return {
                shadowDom: a,
                shadowState: b
            }
        }
        ;
        K.prototype.applyShadowState_ = function(a) {
            var b = a.shadowState;
            this.shadowDom_ = a.shadowDom;
            this.shadowState_ = b
        }
        ;
        K.prototype.setShadowStateInternal_ = function(a) {
            a = void 0 === a ? {} : a;
            var b = void 0 === a.shadowState ? null : a.shadowState;
            this.shadowDom_ = void 0 === a.shadowDom ? null : a.shadowDom;
            this.shadowState_ = b;
            (a = this.targetBlock()) ? a.isShadow() ? (a.dispose(!1),
            this.respawnShadow_(),
            this.targetBlock() && this.targetBlock().isShadow() && this.serializeShadow_(this.targetBlock())) : (a = this.createShadowBlock_(!1),
            this.serializeShadow_(a),
            a && a.dispose(!1)) : (this.respawnShadow_(),
            this.targetBlock() && this.targetBlock().isShadow() && this.serializeShadow_(this.targetBlock()))
        }
        ;
        K.prototype.createShadowBlock_ = function(a) {
            var b = this.getSourceBlock()
              , c = this.getShadowState()
              , d = this.getShadowDom();
            if (!b.workspace || !c && !d)
                return null;
            if (c)
                return (0,
                Ya.appendInternal)(c, b.workspace, {
                    parentConnection: a ? this : void 0,
                    isShadow: !0,
                    recordUndo: !1
                });
            if (d) {
                b = (0,
                e.module$exports$Blockly$Xml.domToBlock)(d, b.workspace);
                if (a)
                    if (this.type === e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE) {
                        if (!b.outputConnection)
                            throw Error("Shadow block is missing an output connection");
                        if (!this.connect(b.outputConnection))
                            throw Error("Could not connect shadow block to connection");
                    } else if (this.type === e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT) {
                        if (!b.previousConnection)
                            throw Error("Shadow block is missing previous connection");
                        if (!this.connect(b.previousConnection))
                            throw Error("Could not connect shadow block to connection");
                    } else
                        throw Error("Cannot connect a shadow block to a previous/output connection");
                return b
            }
            return null
        }
        ;
        K.prototype.serializeShadow_ = function(a) {
            a && (this.shadowDom_ = (0,
            e.module$exports$Blockly$Xml.blockToDom)(a),
            this.shadowState_ = (0,
            Ya.save)(a))
        }
        ;
        var mc = function() {};
        mc.prototype.canConnect = function(a, b, c, d) {
            return this.canConnectWithReason(a, b, c, d) === K.CAN_CONNECT
        }
        ;
        mc.prototype.canConnectWithReason = function(a, b, c, d) {
            var f = this.doSafetyChecks(a, b);
            return f !== K.CAN_CONNECT ? f : this.doTypeChecks(a, b) ? c && !this.doDragChecks(a, b, d || 0) ? K.REASON_DRAG_CHECKS_FAILED : K.CAN_CONNECT : K.REASON_CHECKS_FAILED
        }
        ;
        mc.prototype.getErrorMessage = function(a, b, c) {
            switch (a) {
            case K.REASON_SELF_CONNECTION:
                return "Attempted to connect a block to itself.";
            case K.REASON_DIFFERENT_WORKSPACES:
                return "Blocks not on same workspace.";
            case K.REASON_WRONG_TYPE:
                return "Attempt to connect incompatible types.";
            case K.REASON_TARGET_NULL:
                return "Target connection is null.";
            case K.REASON_CHECKS_FAILED:
                return "Connection checks failed. " + (b + " expected " + b.getCheck() + ", found " + c.getCheck());
            case K.REASON_SHADOW_PARENT:
                return "Connecting non-shadow to shadow block.";
            case K.REASON_DRAG_CHECKS_FAILED:
                return "Drag checks failed.";
            case K.REASON_PREVIOUS_AND_OUTPUT:
                return "Block would have an output and a previous connection.";
            default:
                return "Unknown connection failure: this should never happen!"
            }
        }
        ;
        mc.prototype.doSafetyChecks = function(a, b) {
            if (!a || !b)
                return K.REASON_TARGET_NULL;
            if (a.isSuperior())
                var c = a.getSourceBlock()
                  , d = b.getSourceBlock()
                  , f = b;
            else
                d = a.getSourceBlock(),
                c = b.getSourceBlock(),
                f = a,
                a = b;
            return c === d ? K.REASON_SELF_CONNECTION : f.type !== e.module$exports$Blockly$internalConstants.OPPOSITE_TYPE[a.type] ? K.REASON_WRONG_TYPE : c.workspace !== d.workspace ? K.REASON_DIFFERENT_WORKSPACES : c.isShadow() && !d.isShadow() ? K.REASON_SHADOW_PARENT : f.type === e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE && d.previousConnection && d.previousConnection.isConnected() || f.type === e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT && d.outputConnection && d.outputConnection.isConnected() ? K.REASON_PREVIOUS_AND_OUTPUT : K.CAN_CONNECT
        }
        ;
        mc.prototype.doTypeChecks = function(a, b) {
            a = a.getCheck();
            b = b.getCheck();
            if (!a || !b)
                return !0;
            for (var c = 0; c < a.length; c++)
                if (-1 !== b.indexOf(a[c]))
                    return !0;
            return !1
        }
        ;
        mc.prototype.doDragChecks = function(a, b, c) {
            if (a.distanceFrom(b) > c || b.getSourceBlock().isInsertionMarker())
                return !1;
            switch (b.type) {
            case e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT:
                return this.canConnectToPrevious_(a, b);
            case e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE:
                if (b.isConnected() && !b.targetBlock().isInsertionMarker() || a.isConnected())
                    return !1;
                break;
            case e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE:
                if (b.isConnected() && !b.targetBlock().isMovable() && !b.targetBlock().isShadow())
                    return !1;
                break;
            case e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT:
                if (b.isConnected() && !a.getSourceBlock().nextConnection && !b.targetBlock().isShadow() && b.targetBlock().nextConnection)
                    return !1;
                break;
            default:
                return !1
            }
            return -1 !== e.module$exports$Blockly$common.draggingConnections.indexOf(b) ? !1 : !0
        }
        ;
        mc.prototype.canConnectToPrevious_ = function(a, b) {
            if (a.targetConnection || -1 !== e.module$exports$Blockly$common.draggingConnections.indexOf(b))
                return !1;
            if (!b.targetConnection)
                return !0;
            a = b.targetBlock();
            return a.isInsertionMarker() ? !a.getPreviousBlock() : !1
        }
        ;
        (0,
        w.register)(w.Type.CONNECTION_CHECKER, w.DEFAULT, mc);
        var N = {}
          , hd = Object.create(null);
        N.Workspace = function(a) {
            this.id = (0,
            bb.genUid)();
            hd[this.id] = this;
            this.options = a || new nb.Options({});
            this.RTL = !!this.options.RTL;
            this.horizontalLayout = !!this.options.horizontalLayout;
            this.toolboxPosition = this.options.toolboxPosition;
            this.connectionChecker = new ((0,
            w.getClassFromOptions)(w.Type.CONNECTION_CHECKER, this.options, !0))(this);
            this.topBlocks_ = [];
            this.topComments_ = [];
            this.commentDB_ = Object.create(null);
            this.listeners_ = [];
            this.undoStack_ = [];
            this.redoStack_ = [];
            this.blockDB_ = Object.create(null);
            this.typedBlocksDB_ = Object.create(null);
            this.variableMap_ = new Za(this);
            this.potentialVariableMap_ = null
        }
        ;
        N.Workspace.prototype.rendered = !1;
        N.Workspace.prototype.isClearing = !1;
        N.Workspace.prototype.MAX_UNDO = 1024;
        N.Workspace.prototype.connectionDBList = null;
        N.Workspace.prototype.dispose = function() {
            this.listeners_.length = 0;
            this.clear();
            delete hd[this.id]
        }
        ;
        N.Workspace.SCAN_ANGLE = 3;
        N.Workspace.prototype.sortObjects_ = function(a, b) {
            a = a.getRelativeToSurfaceXY();
            b = b.getRelativeToSurfaceXY();
            return a.y + N.Workspace.prototype.sortObjects_.offset * a.x - (b.y + N.Workspace.prototype.sortObjects_.offset * b.x)
        }
        ;
        N.Workspace.prototype.addTopBlock = function(a) {
            this.topBlocks_.push(a)
        }
        ;
        N.Workspace.prototype.removeTopBlock = function(a) {
            if (!(0,
            zb)(this.topBlocks_, a))
                throw Error("Block not present in workspace's list of top-most blocks.");
        }
        ;
        N.Workspace.prototype.getTopBlocks = function(a) {
            var b = [].concat(this.topBlocks_);
            a && 1 < b.length && (this.sortObjects_.offset = Math.sin((0,
            Eb.toRadians)(N.Workspace.SCAN_ANGLE)),
            this.RTL && (this.sortObjects_.offset *= -1),
            b.sort(this.sortObjects_));
            return b
        }
        ;
        N.Workspace.prototype.addTypedBlock = function(a) {
            this.typedBlocksDB_[a.type] || (this.typedBlocksDB_[a.type] = []);
            this.typedBlocksDB_[a.type].push(a)
        }
        ;
        N.Workspace.prototype.removeTypedBlock = function(a) {
            (0,
            zb)(this.typedBlocksDB_[a.type], a);
            this.typedBlocksDB_[a.type].length || delete this.typedBlocksDB_[a.type]
        }
        ;
        N.Workspace.prototype.getBlocksByType = function(a, b) {
            if (!this.typedBlocksDB_[a])
                return [];
            a = this.typedBlocksDB_[a].slice(0);
            b && 1 < a.length && (this.sortObjects_.offset = Math.sin((0,
            Eb.toRadians)(N.Workspace.SCAN_ANGLE)),
            this.RTL && (this.sortObjects_.offset *= -1),
            a.sort(this.sortObjects_));
            return a.filter(function(c) {
                return !c.isInsertionMarker()
            })
        }
        ;
        N.Workspace.prototype.addTopComment = function(a) {
            this.topComments_.push(a);
            this.commentDB_[a.id] && console.warn('Overriding an existing comment on this workspace, with id "' + a.id + '"');
            this.commentDB_[a.id] = a
        }
        ;
        N.Workspace.prototype.removeTopComment = function(a) {
            if (!(0,
            zb)(this.topComments_, a))
                throw Error("Comment not present in workspace's list of top-most comments.");
            delete this.commentDB_[a.id]
        }
        ;
        N.Workspace.prototype.getTopComments = function(a) {
            var b = [].concat(this.topComments_);
            a && 1 < b.length && (this.sortObjects_.offset = Math.sin((0,
            Eb.toRadians)(N.Workspace.SCAN_ANGLE)),
            this.RTL && (this.sortObjects_.offset *= -1),
            b.sort(this.sortObjects_));
            return b
        }
        ;
        N.Workspace.prototype.getAllBlocks = function(a) {
            if (a) {
                var b = this.getTopBlocks(!0);
                a = [];
                for (var c = 0; c < b.length; c++)
                    a.push.apply(a, b[c].getDescendants(!0))
            } else
                for (a = this.getTopBlocks(!1),
                b = 0; b < a.length; b++)
                    a.push.apply(a, a[b].getChildren(!1));
            return a.filter(function(d) {
                return !d.isInsertionMarker()
            })
        }
        ;
        N.Workspace.prototype.clear = function() {
            this.isClearing = !0;
            try {
                var a = (0,
                k.getGroup)();
                for (a || (0,
                k.setGroup)(!0); this.topBlocks_.length; )
                    this.topBlocks_[0].dispose(!1);
                for (; this.topComments_.length; )
                    this.topComments_[this.topComments_.length - 1].dispose();
                a || (0,
                k.setGroup)(!1);
                this.variableMap_.clear();
                this.potentialVariableMap_ && this.potentialVariableMap_.clear()
            } finally {
                this.isClearing = !1
            }
        }
        ;
        N.Workspace.prototype.renameVariableById = function(a, b) {
            this.variableMap_.renameVariableById(a, b)
        }
        ;
        N.Workspace.prototype.createVariable = function(a, b, c) {
            return this.variableMap_.createVariable(a, b, c)
        }
        ;
        N.Workspace.prototype.getVariableUsesById = function(a) {
            return this.variableMap_.getVariableUsesById(a)
        }
        ;
        N.Workspace.prototype.deleteVariableById = function(a) {
            this.variableMap_.deleteVariableById(a)
        }
        ;
        N.Workspace.prototype.getVariable = function(a, b) {
            return this.variableMap_.getVariable(a, b)
        }
        ;
        N.Workspace.prototype.getVariableById = function(a) {
            return this.variableMap_.getVariableById(a)
        }
        ;
        N.Workspace.prototype.getVariablesOfType = function(a) {
            return this.variableMap_.getVariablesOfType(a)
        }
        ;
        N.Workspace.prototype.getVariableTypes = function() {
            return this.variableMap_.getVariableTypes(this)
        }
        ;
        N.Workspace.prototype.getAllVariables = function() {
            return this.variableMap_.getAllVariables()
        }
        ;
        N.Workspace.prototype.getAllVariableNames = function() {
            return this.variableMap_.getAllVariableNames()
        }
        ;
        N.Workspace.prototype.getWidth = function() {
            return 0
        }
        ;
        N.Workspace.prototype.newBlock = function(a, b) {
            return new F.Block(this,a,b)
        }
        ;
        N.Workspace.prototype.remainingCapacity = function() {
            return isNaN(this.options.maxBlocks) ? Infinity : this.options.maxBlocks - this.getAllBlocks(!1).length
        }
        ;
        N.Workspace.prototype.remainingCapacityOfType = function(a) {
            return this.options.maxInstances ? (void 0 !== this.options.maxInstances[a] ? this.options.maxInstances[a] : Infinity) - this.getBlocksByType(a, !1).length : Infinity
        }
        ;
        N.Workspace.prototype.isCapacityAvailable = function(a) {
            if (!this.hasBlockLimits())
                return !0;
            var b = 0, c;
            for (c in a) {
                if (a[c] > this.remainingCapacityOfType(c))
                    return !1;
                b += a[c]
            }
            return b > this.remainingCapacity() ? !1 : !0
        }
        ;
        N.Workspace.prototype.hasBlockLimits = function() {
            return Infinity !== this.options.maxBlocks || !!this.options.maxInstances
        }
        ;
        N.Workspace.prototype.getUndoStack = function() {
            return this.undoStack_
        }
        ;
        N.Workspace.prototype.getRedoStack = function() {
            return this.redoStack_
        }
        ;
        N.Workspace.prototype.undo = function(a) {
            var b = a ? this.redoStack_ : this.undoStack_
              , c = a ? this.undoStack_ : this.redoStack_
              , d = b.pop();
            if (d) {
                for (var f = [d]; b.length && d.group && d.group === b[b.length - 1].group; )
                    f.push(b.pop());
                for (b = 0; b < f.length; b++)
                    c.push(f[b]);
                f = (0,
                k.filter)(f, a);
                (0,
                k.setRecordUndo)(!1);
                try {
                    for (c = 0; c < f.length; c++)
                        f[c].run(a)
                } finally {
                    (0,
                    k.setRecordUndo)(!0)
                }
            }
        }
        ;
        N.Workspace.prototype.clearUndo = function() {
            this.undoStack_.length = 0;
            this.redoStack_.length = 0;
            (0,
            k.clearPendingUndo)()
        }
        ;
        N.Workspace.prototype.addChangeListener = function(a) {
            this.listeners_.push(a);
            return a
        }
        ;
        N.Workspace.prototype.removeChangeListener = function(a) {
            (0,
            zb)(this.listeners_, a)
        }
        ;
        N.Workspace.prototype.fireChangeListener = function(a) {
            if (a.recordUndo)
                for (this.undoStack_.push(a),
                this.redoStack_.length = 0; this.undoStack_.length > this.MAX_UNDO && 0 <= this.MAX_UNDO; )
                    this.undoStack_.shift();
            for (var b = 0; b < this.listeners_.length; b++)
                (0,
                this.listeners_[b])(a)
        }
        ;
        N.Workspace.prototype.getBlockById = function(a) {
            return this.blockDB_[a] || null
        }
        ;
        N.Workspace.prototype.setBlockById = function(a, b) {
            this.blockDB_[a] = b
        }
        ;
        N.Workspace.prototype.removeBlockById = function(a) {
            delete this.blockDB_[a]
        }
        ;
        N.Workspace.prototype.getCommentById = function(a) {
            return this.commentDB_[a] || null
        }
        ;
        N.Workspace.prototype.allInputsFilled = function(a) {
            for (var b = this.getTopBlocks(!1), c = 0; c < b.length; c++)
                if (!b[c].allInputsFilled(a))
                    return !1;
            return !0
        }
        ;
        N.Workspace.prototype.getPotentialVariableMap = function() {
            return this.potentialVariableMap_
        }
        ;
        N.Workspace.prototype.createPotentialVariableMap = function() {
            this.potentialVariableMap_ = new Za(this)
        }
        ;
        N.Workspace.prototype.getVariableMap = function() {
            return this.variableMap_
        }
        ;
        N.Workspace.prototype.setVariableMap = function(a) {
            this.variableMap_ = a
        }
        ;
        N.Workspace.getById = function(a) {
            return hd[a] || null
        }
        ;
        N.Workspace.getAll = function() {
            var a = [], b;
            for (b in hd)
                a.push(hd[b]);
            return a
        }
        ;
        var H = {
            Bubble: function(a, b, c, d, f, g) {
                this.workspace_ = a;
                this.content_ = b;
                this.shape_ = c;
                this.onMouseDownResizeWrapper_ = this.onMouseDownBubbleWrapper_ = this.moveCallback_ = this.resizeCallback_ = null;
                this.disposed = !1;
                c = H.Bubble.ARROW_ANGLE;
                this.workspace_.RTL && (c = -c);
                this.arrow_radians_ = (0,
                Eb.toRadians)(c);
                a.getBubbleCanvas().appendChild(this.createDom_(b, !(!f || !g)));
                this.setAnchorLocation(d);
                f && g || (a = this.content_.getBBox(),
                f = a.width + 2 * H.Bubble.BORDER_WIDTH,
                g = a.height + 2 * H.Bubble.BORDER_WIDTH);
                this.setBubbleSize(f, g);
                this.positionBubble_();
                this.renderArrow_();
                this.rendered_ = !0
            }
        };
        H.Bubble.BORDER_WIDTH = 6;
        H.Bubble.ARROW_THICKNESS = 5;
        H.Bubble.ARROW_ANGLE = 20;
        H.Bubble.ARROW_BEND = 4;
        H.Bubble.ANCHOR_RADIUS = 8;
        H.Bubble.onMouseUpWrapper_ = null;
        H.Bubble.onMouseMoveWrapper_ = null;
        H.Bubble.unbindDragEvents_ = function() {
            H.Bubble.onMouseUpWrapper_ && ((0,
            y.unbind)(H.Bubble.onMouseUpWrapper_),
            H.Bubble.onMouseUpWrapper_ = null);
            H.Bubble.onMouseMoveWrapper_ && ((0,
            y.unbind)(H.Bubble.onMouseMoveWrapper_),
            H.Bubble.onMouseMoveWrapper_ = null)
        }
        ;
        H.Bubble.bubbleMouseUp_ = function(a) {
            (0,
            O.clearTouchIdentifier)();
            H.Bubble.unbindDragEvents_()
        }
        ;
        H.Bubble.prototype.rendered_ = !1;
        H.Bubble.prototype.anchorXY_ = null;
        H.Bubble.prototype.relativeLeft_ = 0;
        H.Bubble.prototype.relativeTop_ = 0;
        H.Bubble.prototype.width_ = 0;
        H.Bubble.prototype.height_ = 0;
        H.Bubble.prototype.autoLayout_ = !0;
        H.Bubble.prototype.createDom_ = function(a, b) {
            this.bubbleGroup_ = (0,
            n.createSvgElement)(u.G, {}, null);
            var c = {
                filter: "url(#" + this.workspace_.getRenderer().getConstants().embossFilterId + ")"
            };
            V.JAVA_FX && (c = {});
            c = (0,
            n.createSvgElement)(u.G, c, this.bubbleGroup_);
            this.bubbleArrow_ = (0,
            n.createSvgElement)(u.PATH, {}, c);
            this.bubbleBack_ = (0,
            n.createSvgElement)(u.RECT, {
                "class": "blocklyDraggable",
                x: 0,
                y: 0,
                rx: H.Bubble.BORDER_WIDTH,
                ry: H.Bubble.BORDER_WIDTH
            }, c);
            b ? (this.resizeGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": this.workspace_.RTL ? "blocklyResizeSW" : "blocklyResizeSE"
            }, this.bubbleGroup_),
            b = 2 * H.Bubble.BORDER_WIDTH,
            (0,
            n.createSvgElement)(u.POLYGON, {
                points: "0,x x,x x,0".replace(/x/g, b.toString())
            }, this.resizeGroup_),
            (0,
            n.createSvgElement)(u.LINE, {
                "class": "blocklyResizeLine",
                x1: b / 3,
                y1: b - 1,
                x2: b - 1,
                y2: b / 3
            }, this.resizeGroup_),
            (0,
            n.createSvgElement)(u.LINE, {
                "class": "blocklyResizeLine",
                x1: 2 * b / 3,
                y1: b - 1,
                x2: b - 1,
                y2: 2 * b / 3
            }, this.resizeGroup_)) : this.resizeGroup_ = null;
            this.workspace_.options.readOnly || (this.onMouseDownBubbleWrapper_ = (0,
            y.conditionalBind)(this.bubbleBack_, "mousedown", this, this.bubbleMouseDown_),
            this.resizeGroup_ && (this.onMouseDownResizeWrapper_ = (0,
            y.conditionalBind)(this.resizeGroup_, "mousedown", this, this.resizeMouseDown_)));
            this.bubbleGroup_.appendChild(a);
            return this.bubbleGroup_
        }
        ;
        H.Bubble.prototype.getSvgRoot = function() {
            return this.bubbleGroup_
        }
        ;
        H.Bubble.prototype.setSvgId = function(a) {
            this.bubbleGroup_.dataset && (this.bubbleGroup_.dataset.blockId = a)
        }
        ;
        H.Bubble.prototype.bubbleMouseDown_ = function(a) {
            var b = this.workspace_.getGesture(a);
            b && b.handleBubbleStart(a, this)
        }
        ;
        H.Bubble.prototype.showContextMenu = function(a) {}
        ;
        H.Bubble.prototype.isDeletable = function() {
            return !1
        }
        ;
        H.Bubble.prototype.setDeleteStyle = function(a) {}
        ;
        H.Bubble.prototype.resizeMouseDown_ = function(a) {
            this.promote();
            H.Bubble.unbindDragEvents_();
            (0,
            y.isRightButton)(a) || (this.workspace_.startDrag(a, new J(this.workspace_.RTL ? -this.width_ : this.width_,this.height_)),
            H.Bubble.onMouseUpWrapper_ = (0,
            y.conditionalBind)(document, "mouseup", this, H.Bubble.bubbleMouseUp_),
            H.Bubble.onMouseMoveWrapper_ = (0,
            y.conditionalBind)(document, "mousemove", this, this.resizeMouseMove_),
            this.workspace_.hideChaff());
            a.stopPropagation()
        }
        ;
        H.Bubble.prototype.resizeMouseMove_ = function(a) {
            this.autoLayout_ = !1;
            a = this.workspace_.moveDrag(a);
            this.setBubbleSize(this.workspace_.RTL ? -a.x : a.x, a.y);
            this.workspace_.RTL && this.positionBubble_()
        }
        ;
        H.Bubble.prototype.registerResizeEvent = function(a) {
            this.resizeCallback_ = a
        }
        ;
        H.Bubble.prototype.registerMoveEvent = function(a) {
            this.moveCallback_ = a
        }
        ;
        H.Bubble.prototype.promote = function() {
            var a = this.bubbleGroup_.parentNode;
            return a.lastChild !== this.bubbleGroup_ ? (a.appendChild(this.bubbleGroup_),
            !0) : !1
        }
        ;
        H.Bubble.prototype.setAnchorLocation = function(a) {
            this.anchorXY_ = a;
            this.rendered_ && this.positionBubble_()
        }
        ;
        H.Bubble.prototype.layoutBubble_ = function() {
            var a = this.workspace_.getMetricsManager().getViewMetrics(!0)
              , b = this.getOptimalRelativeLeft_(a)
              , c = this.getOptimalRelativeTop_(a)
              , d = this.shape_.getBBox()
              , f = {
                x: b,
                y: -this.height_ - this.workspace_.getRenderer().getConstants().MIN_BLOCK_HEIGHT
            }
              , g = {
                x: -this.width_ - 30,
                y: c
            };
            c = {
                x: d.width,
                y: c
            };
            var m = {
                x: b,
                y: d.height
            };
            b = d.width < d.height ? c : m;
            d = d.width < d.height ? m : c;
            c = this.getOverlap_(f, a);
            m = this.getOverlap_(g, a);
            var r = this.getOverlap_(b, a);
            a = this.getOverlap_(d, a);
            a = Math.max(c, m, r, a);
            c === a ? (this.relativeLeft_ = f.x,
            this.relativeTop_ = f.y) : m === a ? (this.relativeLeft_ = g.x,
            this.relativeTop_ = g.y) : r === a ? (this.relativeLeft_ = b.x,
            this.relativeTop_ = b.y) : (this.relativeLeft_ = d.x,
            this.relativeTop_ = d.y)
        }
        ;
        H.Bubble.prototype.getOverlap_ = function(a, b) {
            var c = this.workspace_.RTL ? this.anchorXY_.x - a.x - this.width_ : a.x + this.anchorXY_.x;
            a = a.y + this.anchorXY_.y;
            return Math.max(0, Math.min(1, (Math.min(c + this.width_, b.left + b.width) - Math.max(c, b.left)) * (Math.min(a + this.height_, b.top + b.height) - Math.max(a, b.top)) / (this.width_ * this.height_)))
        }
        ;
        H.Bubble.prototype.getOptimalRelativeLeft_ = function(a) {
            var b = -this.width_ / 4;
            if (this.width_ > a.width)
                return b;
            if (this.workspace_.RTL) {
                var c = this.anchorXY_.x - b
                  , d = a.left + a.width;
                a = a.left + L.Scrollbar.scrollbarThickness / this.workspace_.scale;
                c - this.width_ < a ? b = -(a - this.anchorXY_.x + this.width_) : c > d && (b = -(d - this.anchorXY_.x))
            } else {
                c = b + this.anchorXY_.x;
                d = c + this.width_;
                var f = a.left;
                a = a.left + a.width - L.Scrollbar.scrollbarThickness / this.workspace_.scale;
                c < f ? b = f - this.anchorXY_.x : d > a && (b = a - this.anchorXY_.x - this.width_)
            }
            return b
        }
        ;
        H.Bubble.prototype.getOptimalRelativeTop_ = function(a) {
            var b = -this.height_ / 4;
            if (this.height_ > a.height)
                return b;
            var c = this.anchorXY_.y + b
              , d = c + this.height_
              , f = a.top;
            a = a.top + a.height - L.Scrollbar.scrollbarThickness / this.workspace_.scale;
            var g = this.anchorXY_.y;
            c < f ? b = f - g : d > a && (b = a - g - this.height_);
            return b
        }
        ;
        H.Bubble.prototype.positionBubble_ = function() {
            var a = this.anchorXY_.x;
            a = this.workspace_.RTL ? a - (this.relativeLeft_ + this.width_) : a + this.relativeLeft_;
            this.moveTo(a, this.relativeTop_ + this.anchorXY_.y)
        }
        ;
        H.Bubble.prototype.moveTo = function(a, b) {
            this.bubbleGroup_.setAttribute("transform", "translate(" + a + "," + b + ")")
        }
        ;
        H.Bubble.prototype.setDragging = function(a) {
            !a && this.moveCallback_ && this.moveCallback_()
        }
        ;
        H.Bubble.prototype.getBubbleSize = function() {
            return new Pa(this.width_,this.height_)
        }
        ;
        H.Bubble.prototype.setBubbleSize = function(a, b) {
            var c = 2 * H.Bubble.BORDER_WIDTH;
            a = Math.max(a, c + 45);
            b = Math.max(b, c + 20);
            this.width_ = a;
            this.height_ = b;
            this.bubbleBack_.setAttribute("width", a);
            this.bubbleBack_.setAttribute("height", b);
            this.resizeGroup_ && (this.workspace_.RTL ? this.resizeGroup_.setAttribute("transform", "translate(" + 2 * H.Bubble.BORDER_WIDTH + "," + (b - c) + ") scale(-1 1)") : this.resizeGroup_.setAttribute("transform", "translate(" + (a - c) + "," + (b - c) + ")"));
            this.autoLayout_ && this.layoutBubble_();
            this.positionBubble_();
            this.renderArrow_();
            this.resizeCallback_ && this.resizeCallback_()
        }
        ;
        H.Bubble.prototype.renderArrow_ = function() {
            var a = []
              , b = this.width_ / 2
              , c = this.height_ / 2
              , d = -this.relativeLeft_
              , f = -this.relativeTop_;
            if (b === d && c === f)
                a.push("M " + b + "," + c);
            else {
                f -= c;
                d -= b;
                this.workspace_.RTL && (d *= -1);
                var g = Math.sqrt(f * f + d * d)
                  , m = Math.acos(d / g);
                0 > f && (m = 2 * Math.PI - m);
                var r = m + Math.PI / 2;
                r > 2 * Math.PI && (r -= 2 * Math.PI);
                var B = Math.sin(r)
                  , G = Math.cos(r)
                  , W = this.getBubbleSize();
                r = (W.width + W.height) / H.Bubble.ARROW_THICKNESS;
                r = Math.min(r, W.width, W.height) / 4;
                W = 1 - H.Bubble.ANCHOR_RADIUS / g;
                d = b + W * d;
                f = c + W * f;
                W = b + r * G;
                var ra = c + r * B;
                b -= r * G;
                c -= r * B;
                B = m + this.arrow_radians_;
                B > 2 * Math.PI && (B -= 2 * Math.PI);
                m = Math.sin(B) * g / H.Bubble.ARROW_BEND;
                g = Math.cos(B) * g / H.Bubble.ARROW_BEND;
                a.push("M" + W + "," + ra);
                a.push("C" + (W + g) + "," + (ra + m) + " " + d + "," + f + " " + d + "," + f);
                a.push("C" + d + "," + f + " " + (b + g) + "," + (c + m) + " " + b + "," + c)
            }
            a.push("z");
            this.bubbleArrow_.setAttribute("d", a.join(" "))
        }
        ;
        H.Bubble.prototype.setColour = function(a) {
            this.bubbleBack_.setAttribute("fill", a);
            this.bubbleArrow_.setAttribute("fill", a)
        }
        ;
        H.Bubble.prototype.dispose = function() {
            this.onMouseDownBubbleWrapper_ && (0,
            y.unbind)(this.onMouseDownBubbleWrapper_);
            this.onMouseDownResizeWrapper_ && (0,
            y.unbind)(this.onMouseDownResizeWrapper_);
            H.Bubble.unbindDragEvents_();
            (0,
            n.removeNode)(this.bubbleGroup_);
            this.disposed = !0
        }
        ;
        H.Bubble.prototype.moveDuringDrag = function(a, b) {
            a ? a.translateSurface(b.x, b.y) : this.moveTo(b.x, b.y);
            this.relativeLeft_ = this.workspace_.RTL ? this.anchorXY_.x - b.x - this.width_ : b.x - this.anchorXY_.x;
            this.relativeTop_ = b.y - this.anchorXY_.y;
            this.renderArrow_()
        }
        ;
        H.Bubble.prototype.getRelativeToSurfaceXY = function() {
            return new J(this.workspace_.RTL ? -this.relativeLeft_ + this.anchorXY_.x - this.width_ : this.anchorXY_.x + this.relativeLeft_,this.anchorXY_.y + this.relativeTop_)
        }
        ;
        H.Bubble.prototype.setAutoLayout = function(a) {
            this.autoLayout_ = a
        }
        ;
        H.Bubble.textToDom = function(a) {
            var b = (0,
            n.createSvgElement)(u.TEXT, {
                "class": "blocklyText blocklyBubbleText blocklyNoPointerEvents",
                y: H.Bubble.BORDER_WIDTH
            }, null);
            a = a.split("\n");
            for (var c = 0; c < a.length; c++) {
                var d = (0,
                n.createSvgElement)(u.TSPAN, {
                    dy: "1em",
                    x: H.Bubble.BORDER_WIDTH
                }, b)
                  , f = document.createTextNode(a[c]);
                d.appendChild(f)
            }
            return b
        }
        ;
        H.Bubble.createNonEditableBubble = function(a, b, c) {
            c = new H.Bubble(b.workspace,a,b.pathObject.svgPath,c,null,null);
            c.setSvgId(b.id);
            if (b.RTL) {
                b = a.getBBox().width;
                for (var d = 0, f; f = a.childNodes[d]; d++)
                    f.setAttribute("text-anchor", "end"),
                    f.setAttribute("x", b + H.Bubble.BORDER_WIDTH)
            }
            return c
        }
        ;
        var Bb = function(a) {
            this.commentId = (this.isBlank = "undefined" === typeof a) ? "" : a.id;
            this.workspaceId = this.isBlank ? "" : a.workspace.id;
            this.group = (0,
            k.getGroup)();
            this.recordUndo = (0,
            k.getRecordUndo)()
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Bb, Gb);
        Bb.prototype.toJson = function() {
            var a = Bb.superClass_.toJson.call(this);
            this.commentId && (a.commentId = this.commentId);
            return a
        }
        ;
        Bb.prototype.fromJson = function(a) {
            Bb.superClass_.fromJson.call(this, a);
            this.commentId = a.commentId
        }
        ;
        Bb.CommentCreateDeleteHelper = function(a, b) {
            var c = a.getEventWorkspace_();
            b ? (b = (0,
            e.module$exports$Blockly$utils$xml.createElement)("xml"),
            b.appendChild(a.xml),
            (0,
            e.module$exports$Blockly$Xml.domToWorkspace)(b, c)) : (c = c.getCommentById(a.commentId)) ? c.dispose() : console.warn("Can't uncreate non-existent comment: " + a.commentId)
        }
        ;
        var Cb = {
            CommentMove: function(a) {
                Cb.CommentMove.superClass_.constructor.call(this, a);
                a && (this.comment_ = a,
                this.oldCoordinate_ = a.getXY(),
                this.newCoordinate_ = null)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Cb.CommentMove, Bb);
        Cb.CommentMove.prototype.recordNew = function() {
            if (!this.comment_)
                throw Error("Tried to record the new position of a comment on the same event twice.");
            this.newCoordinate_ = this.comment_.getXY();
            this.comment_ = null
        }
        ;
        Cb.CommentMove.prototype.type = k.COMMENT_MOVE;
        Cb.CommentMove.prototype.setOldCoordinate = function(a) {
            this.oldCoordinate_ = a
        }
        ;
        Cb.CommentMove.prototype.toJson = function() {
            var a = Cb.CommentMove.superClass_.toJson.call(this);
            this.oldCoordinate_ && (a.oldCoordinate = Math.round(this.oldCoordinate_.x) + "," + Math.round(this.oldCoordinate_.y));
            this.newCoordinate_ && (a.newCoordinate = Math.round(this.newCoordinate_.x) + "," + Math.round(this.newCoordinate_.y));
            return a
        }
        ;
        Cb.CommentMove.prototype.fromJson = function(a) {
            Cb.CommentMove.superClass_.fromJson.call(this, a);
            if (a.oldCoordinate) {
                var b = a.oldCoordinate.split(",");
                this.oldCoordinate_ = new J(Number(b[0]),Number(b[1]))
            }
            a.newCoordinate && (a = a.newCoordinate.split(","),
            this.newCoordinate_ = new J(Number(a[0]),Number(a[1])))
        }
        ;
        Cb.CommentMove.prototype.isNull = function() {
            return J.equals(this.oldCoordinate_, this.newCoordinate_)
        }
        ;
        Cb.CommentMove.prototype.run = function(a) {
            var b = this.getEventWorkspace_().getCommentById(this.commentId);
            if (b) {
                a = a ? this.newCoordinate_ : this.oldCoordinate_;
                var c = b.getXY();
                b.moveBy(a.x - c.x, a.y - c.y)
            } else
                console.warn("Can't move non-existent comment: " + this.commentId)
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.COMMENT_MOVE, Cb.CommentMove);
        var Qb = function(a, b) {
            this.draggingBubble_ = a;
            this.workspace_ = b;
            this.dragTarget_ = null;
            this.wouldDeleteBubble_ = !1;
            this.startXY_ = this.draggingBubble_.getRelativeToSurfaceXY();
            this.dragSurface_ = (0,
            ja.is3dSupported)() && b.getBlockDragSurface() ? b.getBlockDragSurface() : null
        };
        Qb.prototype.dispose = function() {
            this.dragSurface_ = this.workspace_ = this.draggingBubble_ = null
        }
        ;
        Qb.prototype.startBubbleDrag = function() {
            (0,
            k.getGroup)() || (0,
            k.setGroup)(!0);
            this.workspace_.setResizesEnabled(!1);
            this.draggingBubble_.setAutoLayout(!1);
            this.dragSurface_ && this.moveToDragSurface_();
            this.draggingBubble_.setDragging && this.draggingBubble_.setDragging(!0)
        }
        ;
        Qb.prototype.dragBubble = function(a, b) {
            b = this.pixelsToWorkspaceUnits_(b);
            b = J.sum(this.startXY_, b);
            this.draggingBubble_.moveDuringDrag(this.dragSurface_, b);
            b = this.dragTarget_;
            this.dragTarget_ = this.workspace_.getDragTarget(a);
            a = this.wouldDeleteBubble_;
            this.wouldDeleteBubble_ = this.shouldDelete_(this.dragTarget_);
            a !== this.wouldDeleteBubble_ && this.updateCursorDuringBubbleDrag_();
            this.dragTarget_ !== b && (b && b.onDragExit(this.draggingBubble_),
            this.dragTarget_ && this.dragTarget_.onDragEnter(this.draggingBubble_));
            this.dragTarget_ && this.dragTarget_.onDragOver(this.draggingBubble_)
        }
        ;
        Qb.prototype.shouldDelete_ = function(a) {
            return a && this.workspace_.getComponentManager().hasCapability(a.id, oa.Capability.DELETE_AREA) ? a.wouldDelete(this.draggingBubble_, !1) : !1
        }
        ;
        Qb.prototype.updateCursorDuringBubbleDrag_ = function() {
            this.draggingBubble_.setDeleteStyle(this.wouldDeleteBubble_)
        }
        ;
        Qb.prototype.endBubbleDrag = function(a, b) {
            this.dragBubble(a, b);
            this.dragTarget_ && this.dragTarget_.shouldPreventMove(this.draggingBubble_) ? a = this.startXY_ : (a = this.pixelsToWorkspaceUnits_(b),
            a = J.sum(this.startXY_, a));
            this.draggingBubble_.moveTo(a.x, a.y);
            if (this.dragTarget_)
                this.dragTarget_.onDrop(this.draggingBubble_);
            this.wouldDeleteBubble_ ? (this.fireMoveEvent_(),
            this.draggingBubble_.dispose(!1, !0)) : (this.dragSurface_ && this.dragSurface_.clearAndHide(this.workspace_.getBubbleCanvas()),
            this.draggingBubble_.setDragging && this.draggingBubble_.setDragging(!1),
            this.fireMoveEvent_());
            this.workspace_.setResizesEnabled(!0);
            (0,
            k.setGroup)(!1)
        }
        ;
        Qb.prototype.fireMoveEvent_ = function() {
            if (this.draggingBubble_.isComment) {
                var a = new ((0,
                k.get)(k.COMMENT_MOVE))(this.draggingBubble_);
                a.setOldCoordinate(this.startXY_);
                a.recordNew();
                (0,
                k.fire)(a)
            }
        }
        ;
        Qb.prototype.pixelsToWorkspaceUnits_ = function(a) {
            a = new J(a.x / this.workspace_.scale,a.y / this.workspace_.scale);
            this.workspace_.isMutator && a.scale(1 / this.workspace_.options.parentWorkspace.scale);
            return a
        }
        ;
        Qb.prototype.moveToDragSurface_ = function() {
            this.draggingBubble_.moveTo(0, 0);
            this.dragSurface_.translateSurface(this.startXY_.x, this.startXY_.y);
            this.dragSurface_.setBlocksAndShow(this.draggingBubble_.getSvgRoot())
        }
        ;
        var Vc = function(a) {
            this.workspace_ = a;
            this.horizontalScrollEnabled_ = this.workspace_.isMovableHorizontally();
            this.verticalScrollEnabled_ = this.workspace_.isMovableVertically();
            this.startScrollXY_ = new J(a.scrollX,a.scrollY)
        };
        Vc.prototype.dispose = function() {
            this.workspace_ = null
        }
        ;
        Vc.prototype.startDrag = function() {
            (0,
            e.module$exports$Blockly$common.getSelected)() && (0,
            e.module$exports$Blockly$common.getSelected)().unselect();
            this.workspace_.setupDragSurface()
        }
        ;
        Vc.prototype.endDrag = function(a) {
            this.drag(a);
            this.workspace_.resetDragSurface()
        }
        ;
        Vc.prototype.drag = function(a) {
            a = J.sum(this.startScrollXY_, a);
            if (this.horizontalScrollEnabled_ && this.verticalScrollEnabled_)
                this.workspace_.scroll(a.x, a.y);
            else if (this.horizontalScrollEnabled_)
                this.workspace_.scroll(a.x, this.workspace_.scrollY);
            else if (this.verticalScrollEnabled_)
                this.workspace_.scroll(this.workspace_.scrollX, a.y);
            else
                throw new TypeError("Invalid state.");
        }
        ;
        var la = function(a) {
            (0,
            e.module$exports$Blockly$common.setSelected)(a);
            this.topBlock_ = a;
            this.workspace_ = a.workspace;
            this.lastMarker_ = this.lastOnStack_ = null;
            this.firstMarker_ = this.createMarkerBlock_(this.topBlock_);
            this.localConnection_ = this.closestConnection_ = null;
            this.wouldDeleteBlock_ = !1;
            this.fadedBlock_ = this.highlightedBlock_ = this.markerConnection_ = null;
            this.availableConnections_ = this.initAvailableConnections_()
        };
        la.PREVIEW_TYPE = {
            INSERTION_MARKER: 0,
            INPUT_OUTLINE: 1,
            REPLACEMENT_FADE: 2
        };
        la.DUPLICATE_BLOCK_ERROR = "The insertion marker manager tried to create a marker but the result is missing %1. If you are using a mutator, make sure your domToMutation method is properly defined.";
        la.prototype.dispose = function() {
            this.availableConnections_.length = 0;
            (0,
            k.disable)();
            try {
                this.firstMarker_ && this.firstMarker_.dispose(),
                this.lastMarker_ && this.lastMarker_.dispose()
            } finally {
                (0,
                k.enable)()
            }
        }
        ;
        la.prototype.updateAvailableConnections = function() {
            this.availableConnections_ = this.initAvailableConnections_()
        }
        ;
        la.prototype.wouldDeleteBlock = function() {
            return this.wouldDeleteBlock_
        }
        ;
        la.prototype.wouldConnectBlock = function() {
            return !!this.closestConnection_
        }
        ;
        la.prototype.applyConnections = function() {
            if (this.closestConnection_ && ((0,
            k.disable)(),
            this.hidePreview_(),
            (0,
            k.enable)(),
            this.localConnection_.connect(this.closestConnection_),
            this.topBlock_.rendered)) {
                var a = this.localConnection_.isSuperior() ? this.closestConnection_ : this.localConnection_;
                (0,
                Pb.connectionUiEffect)(a.getSourceBlock());
                this.topBlock_.getRootBlock().bringToFront()
            }
        }
        ;
        la.prototype.update = function(a, b) {
            var c = this.getCandidate_(a);
            if ((this.wouldDeleteBlock_ = this.shouldDelete_(c, b)) || this.shouldUpdatePreviews_(c, a))
                (0,
                k.disable)(),
                this.maybeHidePreview_(c),
                this.maybeShowPreview_(c),
                (0,
                k.enable)()
        }
        ;
        la.prototype.createMarkerBlock_ = function(a) {
            var b = a.type;
            (0,
            k.disable)();
            try {
                var c = this.workspace_.newBlock(b);
                c.setInsertionMarker(!0);
                if (a.saveExtraState) {
                    var d = a.saveExtraState();
                    d && c.loadExtraState(d)
                } else if (a.mutationToDom) {
                    var f = a.mutationToDom();
                    f && c.domToMutation(f)
                }
                for (b = 0; b < a.inputList.length; b++) {
                    var g = a.inputList[b];
                    if (g.name !== lc.COLLAPSED_INPUT_NAME) {
                        var m = c.inputList[b];
                        if (!m)
                            throw Error(la.DUPLICATE_BLOCK_ERROR.replace("%1", "an input"));
                        for (d = 0; d < g.fieldRow.length; d++) {
                            var r = g.fieldRow[d]
                              , B = m.fieldRow[d];
                            if (!B)
                                throw Error(la.DUPLICATE_BLOCK_ERROR.replace("%1", "a field"));
                            B.setValue(r.getValue())
                        }
                    }
                }
                c.setCollapsed(a.isCollapsed());
                c.setInputsInline(a.getInputsInline());
                c.initSvg();
                c.getSvgRoot().setAttribute("visibility", "hidden")
            } finally {
                (0,
                k.enable)()
            }
            return c
        }
        ;
        la.prototype.initAvailableConnections_ = function() {
            var a = this.topBlock_.getConnections_(!1)
              , b = this.topBlock_.lastConnectionInStack(!0);
            if (b && b !== this.topBlock_.nextConnection) {
                a.push(b);
                this.lastOnStack_ = b;
                if (this.lastMarker_) {
                    (0,
                    k.disable)();
                    try {
                        this.lastMarker_.dispose()
                    } finally {
                        (0,
                        k.enable)()
                    }
                }
                this.lastMarker_ = this.createMarkerBlock_(b.getSourceBlock())
            }
            return a
        }
        ;
        la.prototype.shouldUpdatePreviews_ = function(a, b) {
            var c = a.local
              , d = a.closest;
            a = a.radius;
            if (c && d) {
                if (this.localConnection_ && this.closestConnection_) {
                    if (this.closestConnection_ === d && this.localConnection_ === c)
                        return !1;
                    c = this.localConnection_.x + b.x - this.closestConnection_.x;
                    b = this.localConnection_.y + b.y - this.closestConnection_.y;
                    b = Math.sqrt(c * c + b * b);
                    return !(d && a > b - e.module$exports$Blockly$internalConstants.CURRENT_CONNECTION_PREFERENCE)
                }
                if (this.localConnection_ || this.closestConnection_)
                    console.error("Only one of localConnection_ and closestConnection_ was set.");
                else
                    return !0
            } else
                return !(!this.localConnection_ || !this.closestConnection_);
            console.error("Returning true from shouldUpdatePreviews, but it's not clear why.");
            return !0
        }
        ;
        la.prototype.getCandidate_ = function(a) {
            for (var b = this.getStartRadius_(), c = null, d = null, f = 0; f < this.availableConnections_.length; f++) {
                var g = this.availableConnections_[f]
                  , m = g.closest(b, a);
                m.connection && (c = m.connection,
                d = g,
                b = m.radius)
            }
            return {
                closest: c,
                local: d,
                radius: b
            }
        }
        ;
        la.prototype.getStartRadius_ = function() {
            return e.module$exports$Blockly$internalConstants.SNAP_RADIUS
        }
        ;
        la.prototype.shouldDelete_ = function(a, b) {
            return b && this.workspace_.getComponentManager().hasCapability(b.id, oa.Capability.DELETE_AREA) ? b.wouldDelete(this.topBlock_, a && !!a.closest) : !1
        }
        ;
        la.prototype.maybeShowPreview_ = function(a) {
            if (!this.wouldDeleteBlock_) {
                var b = a.closest;
                a = a.local;
                b && (b === this.closestConnection_ || b.getSourceBlock().isInsertionMarker() ? console.log("Trying to connect to an insertion marker") : (this.closestConnection_ = b,
                this.localConnection_ = a,
                this.showPreview_()))
            }
        }
        ;
        la.prototype.showPreview_ = function() {
            var a = this.closestConnection_
              , b = this.workspace_.getRenderer();
            switch (b.getConnectionPreviewMethod(a, this.localConnection_, this.topBlock_)) {
            case la.PREVIEW_TYPE.INPUT_OUTLINE:
                this.showInsertionInputOutline_();
                break;
            case la.PREVIEW_TYPE.INSERTION_MARKER:
                this.showInsertionMarker_();
                break;
            case la.PREVIEW_TYPE.REPLACEMENT_FADE:
                this.showReplacementFade_()
            }
            a && b.shouldHighlightConnection(a) && a.highlight()
        }
        ;
        la.prototype.maybeHidePreview_ = function(a) {
            if (a.closest) {
                var b = this.closestConnection_ !== a.closest;
                a = this.localConnection_ !== a.local;
                this.closestConnection_ && this.localConnection_ && (b || a || this.wouldDeleteBlock_) && this.hidePreview_()
            } else
                this.hidePreview_();
            this.localConnection_ = this.closestConnection_ = this.markerConnection_ = null
        }
        ;
        la.prototype.hidePreview_ = function() {
            this.closestConnection_ && this.closestConnection_.targetBlock() && this.workspace_.getRenderer().shouldHighlightConnection(this.closestConnection_) && this.closestConnection_.unhighlight();
            this.fadedBlock_ ? this.hideReplacementFade_() : this.highlightedBlock_ ? this.hideInsertionInputOutline_() : this.markerConnection_ && this.hideInsertionMarker_()
        }
        ;
        la.prototype.showInsertionMarker_ = function() {
            var a = this.localConnection_
              , b = this.closestConnection_
              , c = this.lastOnStack_ && a === this.lastOnStack_ ? this.lastMarker_ : this.firstMarker_;
            a = c.getMatchingConnection(a.getSourceBlock(), a);
            if (a === this.markerConnection_)
                throw Error("Made it to showInsertionMarker_ even though the marker isn't changing");
            c.render();
            c.rendered = !0;
            c.getSvgRoot().setAttribute("visibility", "visible");
            a && b && c.positionNearConnection(a, b);
            b && a.connect(b);
            this.markerConnection_ = a
        }
        ;
        la.prototype.hideInsertionMarker_ = function() {
            if (this.markerConnection_) {
                var a = this.markerConnection_
                  , b = a.getSourceBlock()
                  , c = b.nextConnection
                  , d = b.previousConnection
                  , f = b.outputConnection;
                f = a.type === e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE && !(f && f.targetConnection);
                !(a !== c || d && d.targetConnection) || f ? a.targetBlock().unplug(!1) : a.type === e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT && a !== c ? (c = a.targetConnection,
                c.getSourceBlock().unplug(!1),
                d = d ? d.targetConnection : null,
                b.unplug(!0),
                d && d.connect(c)) : b.unplug(!0);
                if (a.targetConnection)
                    throw Error("markerConnection_ still connected at the end of disconnectInsertionMarker");
                this.markerConnection_ = null;
                (a = b.getSvgRoot()) && a.setAttribute("visibility", "hidden")
            } else
                console.log("No insertion marker connection to disconnect")
        }
        ;
        la.prototype.showInsertionInputOutline_ = function() {
            var a = this.closestConnection_;
            this.highlightedBlock_ = a.getSourceBlock();
            this.highlightedBlock_.highlightShapeForInput(a, !0)
        }
        ;
        la.prototype.hideInsertionInputOutline_ = function() {
            this.highlightedBlock_.highlightShapeForInput(this.closestConnection_, !1);
            this.highlightedBlock_ = null
        }
        ;
        la.prototype.showReplacementFade_ = function() {
            this.fadedBlock_ = this.closestConnection_.targetBlock();
            this.fadedBlock_.fadeForReplacement(!0)
        }
        ;
        la.prototype.hideReplacementFade_ = function() {
            this.fadedBlock_.fadeForReplacement(!1);
            this.fadedBlock_ = null
        }
        ;
        la.prototype.getInsertionMarkers = function() {
            var a = [];
            this.firstMarker_ && a.push(this.firstMarker_);
            this.lastMarker_ && a.push(this.lastMarker_);
            return a
        }
        ;
        var vb = {
            UiBase: function(a) {
                vb.UiBase.superClass_.constructor.call(this);
                this.isBlank = "undefined" === typeof a;
                this.workspaceId = a ? a : "";
                this.recordUndo = !1
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(vb.UiBase, Gb);
        vb.UiBase.prototype.isUiEvent = !0;
        var nc = {
            BlockDrag: function(a, b, c) {
                nc.BlockDrag.superClass_.constructor.call(this, a ? a.workspace.id : void 0);
                this.blockId = a ? a.id : null;
                this.isStart = b;
                this.blocks = c
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(nc.BlockDrag, vb.UiBase);
        nc.BlockDrag.prototype.type = k.BLOCK_DRAG;
        nc.BlockDrag.prototype.toJson = function() {
            var a = nc.BlockDrag.superClass_.toJson.call(this);
            a.isStart = this.isStart;
            a.blockId = this.blockId;
            a.blocks = this.blocks;
            return a
        }
        ;
        nc.BlockDrag.prototype.fromJson = function(a) {
            nc.BlockDrag.superClass_.fromJson.call(this, a);
            this.isStart = a.isStart;
            this.blockId = a.blockId;
            this.blocks = a.blocks
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.BLOCK_DRAG, nc.BlockDrag);
        var $a = function(a, b) {
            this.draggingBlock_ = a;
            this.workspace_ = b;
            this.draggedConnectionManager_ = new la(this.draggingBlock_);
            this.dragTarget_ = null;
            this.wouldDeleteBlock_ = !1;
            this.startXY_ = this.draggingBlock_.getRelativeToSurfaceXY();
            b = [];
            a = a.getDescendants(!1);
            for (var c = 0, d; d = a[c]; c++) {
                d = d.getIcons();
                for (var f = 0; f < d.length; f++) {
                    var g = {
                        location: d[f].getIconLocation(),
                        icon: d[f]
                    };
                    b.push(g)
                }
            }
            this.dragIconData_ = b
        };
        $a.prototype.dispose = function() {
            this.dragIconData_.length = 0;
            this.draggedConnectionManager_ && this.draggedConnectionManager_.dispose()
        }
        ;
        $a.prototype.startDrag = function(a, b) {
            (0,
            k.getGroup)() || (0,
            k.setGroup)(!0);
            this.fireDragStartEvent_();
            this.workspace_.isMutator && this.draggingBlock_.bringToFront();
            (0,
            n.startTextWidthCache)();
            this.workspace_.setResizesEnabled(!1);
            (0,
            Pb.disconnectUiStop)();
            this.shouldDisconnect_(b) && this.disconnectBlock_(b, a);
            this.draggingBlock_.setDragging(!0);
            this.draggingBlock_.moveToDragSurface()
        }
        ;
        $a.prototype.shouldDisconnect_ = function(a) {
            return !!(this.draggingBlock_.getParent() || a && this.draggingBlock_.nextConnection && this.draggingBlock_.nextConnection.targetBlock())
        }
        ;
        $a.prototype.disconnectBlock_ = function(a, b) {
            this.draggingBlock_.unplug(a);
            a = this.pixelsToWorkspaceUnits_(b);
            a = J.sum(this.startXY_, a);
            this.draggingBlock_.translate(a.x, a.y);
            (0,
            Pb.disconnectUiEffect)(this.draggingBlock_);
            this.draggedConnectionManager_.updateAvailableConnections()
        }
        ;
        $a.prototype.fireDragStartEvent_ = function() {
            var a = new ((0,
            k.get)(k.BLOCK_DRAG))(this.draggingBlock_,!0,this.draggingBlock_.getDescendants(!1));
            (0,
            k.fire)(a)
        }
        ;
        $a.prototype.drag = function(a, b) {
            b = this.pixelsToWorkspaceUnits_(b);
            var c = J.sum(this.startXY_, b);
            this.draggingBlock_.moveDuringDrag(c);
            this.dragIcons_(b);
            c = this.dragTarget_;
            this.dragTarget_ = this.workspace_.getDragTarget(a);
            this.draggedConnectionManager_.update(b, this.dragTarget_);
            a = this.wouldDeleteBlock_;
            this.wouldDeleteBlock_ = this.draggedConnectionManager_.wouldDeleteBlock();
            a !== this.wouldDeleteBlock_ && this.updateCursorDuringBlockDrag_();
            this.dragTarget_ !== c && (c && c.onDragExit(this.draggingBlock_),
            this.dragTarget_ && this.dragTarget_.onDragEnter(this.draggingBlock_));
            this.dragTarget_ && this.dragTarget_.onDragOver(this.draggingBlock_)
        }
        ;
        $a.prototype.endDrag = function(a, b) {
            this.drag(a, b);
            this.dragIconData_ = [];
            this.fireDragEndEvent_();
            (0,
            n.stopTextWidthCache)();
            (0,
            Pb.disconnectUiStop)();
            if (this.dragTarget_ && this.dragTarget_.shouldPreventMove(this.draggingBlock_))
                a = this.startXY_;
            else {
                a = this.getNewLocationAfterDrag_(b);
                var c = a.delta;
                a = a.newLocation
            }
            this.draggingBlock_.moveOffDragSurface(a);
            if (this.dragTarget_)
                this.dragTarget_.onDrop(this.draggingBlock_);
            this.maybeDeleteBlock_() || (this.draggingBlock_.setDragging(!1),
            c ? this.updateBlockAfterMove_(c) : (0,
            Fc.bumpIntoBounds)(this.draggingBlock_.workspace, this.workspace_.getMetricsManager().getScrollMetrics(!0), this.draggingBlock_));
            this.workspace_.setResizesEnabled(!0);
            (0,
            k.setGroup)(!1)
        }
        ;
        $a.prototype.getNewLocationAfterDrag_ = function(a) {
            var b = {};
            b.delta = this.pixelsToWorkspaceUnits_(a);
            b.newLocation = J.sum(this.startXY_, b.delta);
            return b
        }
        ;
        $a.prototype.maybeDeleteBlock_ = function() {
            return this.wouldDeleteBlock_ ? (this.fireMoveEvent_(),
            this.draggingBlock_.dispose(!1, !0),
            e.module$exports$Blockly$common.draggingConnections.length = 0,
            !0) : !1
        }
        ;
        $a.prototype.updateBlockAfterMove_ = function(a) {
            this.draggingBlock_.moveConnections(a.x, a.y);
            this.fireMoveEvent_();
            this.draggedConnectionManager_.wouldConnectBlock() ? this.draggedConnectionManager_.applyConnections() : this.draggingBlock_.render();
            this.draggingBlock_.scheduleSnapAndBump()
        }
        ;
        $a.prototype.fireDragEndEvent_ = function() {
            var a = new ((0,
            k.get)(k.BLOCK_DRAG))(this.draggingBlock_,!1,this.draggingBlock_.getDescendants(!1));
            (0,
            k.fire)(a)
        }
        ;
        $a.prototype.updateToolboxStyle_ = function(a) {
            var b = this.workspace_.getToolbox();
            if (b) {
                var c = this.draggingBlock_.isDeletable() ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
                a && "function" === typeof b.removeStyle ? b.removeStyle(c) : a || "function" !== typeof b.addStyle || b.addStyle(c)
            }
        }
        ;
        $a.prototype.fireMoveEvent_ = function() {
            var a = new ((0,
            k.get)(k.MOVE))(this.draggingBlock_);
            a.oldCoordinate = this.startXY_;
            a.recordNew();
            (0,
            k.fire)(a)
        }
        ;
        $a.prototype.updateCursorDuringBlockDrag_ = function() {
            this.draggingBlock_.setDeleteStyle(this.wouldDeleteBlock_)
        }
        ;
        $a.prototype.pixelsToWorkspaceUnits_ = function(a) {
            a = new J(a.x / this.workspace_.scale,a.y / this.workspace_.scale);
            this.workspace_.isMutator && a.scale(1 / this.workspace_.options.parentWorkspace.scale);
            return a
        }
        ;
        $a.prototype.dragIcons_ = function(a) {
            for (var b = 0; b < this.dragIconData_.length; b++) {
                var c = this.dragIconData_[b];
                c.icon.setIconLocation(J.sum(c.location, a))
            }
        }
        ;
        $a.prototype.getInsertionMarkers = function() {
            return this.draggedConnectionManager_ && this.draggedConnectionManager_.getInsertionMarkers ? this.draggedConnectionManager_.getInsertionMarkers() : []
        }
        ;
        (0,
        w.register)(w.Type.BLOCK_DRAGGER, w.DEFAULT, $a);
        var oc = {
            Click: function(a, b, c) {
                oc.Click.superClass_.constructor.call(this, a ? a.workspace.id : b);
                this.blockId = a ? a.id : null;
                this.targetType = c
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(oc.Click, vb.UiBase);
        oc.Click.prototype.type = k.CLICK;
        oc.Click.prototype.toJson = function() {
            var a = oc.Click.superClass_.toJson.call(this);
            a.targetType = this.targetType;
            this.blockId && (a.blockId = this.blockId);
            return a
        }
        ;
        oc.Click.prototype.fromJson = function(a) {
            oc.Click.superClass_.fromJson.call(this, a);
            this.targetType = a.targetType;
            this.blockId = a.blockId
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.CLICK, oc.Click);
        var ba = function(a, b) {
            this.mouseDownXY_ = null;
            this.currentDragDeltaXY_ = new J(0,0);
            this.startWorkspace_ = this.targetBlock_ = this.startBlock_ = this.startField_ = this.startBubble_ = null;
            this.creatorWorkspace_ = b;
            this.isDraggingBubble_ = this.isDraggingBlock_ = this.isDraggingWorkspace_ = this.hasExceededDragRadius_ = !1;
            this.mostRecentEvent_ = a;
            this.flyout_ = this.workspaceDragger_ = this.blockDragger_ = this.bubbleDragger_ = this.onUpWrapper_ = this.onMoveWrapper_ = null;
            this.isEnding_ = this.hasStarted_ = this.calledUpdateIsDragging_ = !1;
            this.healStack_ = !e.module$exports$Blockly$internalConstants.DRAG_STACK
        };
        ba.prototype.dispose = function() {
            (0,
            O.clearTouchIdentifier)();
            (0,
            aa.unblock)();
            this.creatorWorkspace_.clearGesture();
            this.onMoveWrapper_ && (0,
            y.unbind)(this.onMoveWrapper_);
            this.onUpWrapper_ && (0,
            y.unbind)(this.onUpWrapper_);
            this.blockDragger_ && this.blockDragger_.dispose();
            this.workspaceDragger_ && this.workspaceDragger_.dispose();
            this.bubbleDragger_ && this.bubbleDragger_.dispose()
        }
        ;
        ba.prototype.updateFromEvent_ = function(a) {
            var b = new J(a.clientX,a.clientY);
            this.updateDragDelta_(b) && (this.updateIsDragging_(),
            (0,
            O.longStop)());
            this.mostRecentEvent_ = a
        }
        ;
        ba.prototype.updateDragDelta_ = function(a) {
            this.currentDragDeltaXY_ = J.difference(a, this.mouseDownXY_);
            return this.hasExceededDragRadius_ ? !1 : this.hasExceededDragRadius_ = J.magnitude(this.currentDragDeltaXY_) > (this.flyout_ ? e.module$exports$Blockly$internalConstants.FLYOUT_DRAG_RADIUS : e.module$exports$Blockly$internalConstants.DRAG_RADIUS)
        }
        ;
        ba.prototype.updateIsDraggingFromFlyout_ = function() {
            return this.targetBlock_ && this.flyout_.isBlockCreatable_(this.targetBlock_) ? !this.flyout_.isScrollable() || this.flyout_.isDragTowardWorkspace(this.currentDragDeltaXY_) ? (this.startWorkspace_ = this.flyout_.targetWorkspace,
            this.startWorkspace_.updateScreenCalculationsIfScrolled(),
            (0,
            k.getGroup)() || (0,
            k.setGroup)(!0),
            this.startBlock_ = null,
            this.targetBlock_ = this.flyout_.createBlock(this.targetBlock_),
            this.targetBlock_.select(),
            !0) : !1 : !1
        }
        ;
        ba.prototype.updateIsDraggingBubble_ = function() {
            if (!this.startBubble_)
                return !1;
            this.isDraggingBubble_ = !0;
            this.startDraggingBubble_();
            return !0
        }
        ;
        ba.prototype.updateIsDraggingBlock_ = function() {
            if (!this.targetBlock_)
                return !1;
            this.flyout_ ? this.isDraggingBlock_ = this.updateIsDraggingFromFlyout_() : this.targetBlock_.isMovable() && (this.isDraggingBlock_ = !0);
            return this.isDraggingBlock_ ? (this.startDraggingBlock_(),
            !0) : !1
        }
        ;
        ba.prototype.updateIsDraggingWorkspace_ = function() {
            if (this.flyout_ ? this.flyout_.isScrollable() : this.startWorkspace_ && this.startWorkspace_.isDraggable())
                this.workspaceDragger_ = new Vc(this.startWorkspace_),
                this.isDraggingWorkspace_ = !0,
                this.workspaceDragger_.startDrag()
        }
        ;
        ba.prototype.updateIsDragging_ = function() {
            if (this.calledUpdateIsDragging_)
                throw Error("updateIsDragging_ should only be called once per gesture.");
            this.calledUpdateIsDragging_ = !0;
            this.updateIsDraggingBubble_() || this.updateIsDraggingBlock_() || this.updateIsDraggingWorkspace_()
        }
        ;
        ba.prototype.startDraggingBlock_ = function() {
            this.blockDragger_ = new ((0,
            w.getClassFromOptions)(w.Type.BLOCK_DRAGGER, this.creatorWorkspace_.options, !0))(this.targetBlock_,this.startWorkspace_);
            this.blockDragger_.startDrag(this.currentDragDeltaXY_, this.healStack_);
            this.blockDragger_.drag(this.mostRecentEvent_, this.currentDragDeltaXY_)
        }
        ;
        ba.prototype.startDraggingBubble_ = function() {
            this.bubbleDragger_ = new Qb(this.startBubble_,this.startWorkspace_);
            this.bubbleDragger_.startBubbleDrag();
            this.bubbleDragger_.dragBubble(this.mostRecentEvent_, this.currentDragDeltaXY_)
        }
        ;
        ba.prototype.doStart = function(a) {
            (0,
            y.isTargetInput)(a) ? this.cancel() : (this.hasStarted_ = !0,
            (0,
            Pb.disconnectUiStop)(),
            this.startWorkspace_.updateScreenCalculationsIfScrolled(),
            this.startWorkspace_.isMutator && this.startWorkspace_.resize(),
            this.startWorkspace_.hideChaff(!!this.flyout_),
            this.startWorkspace_.markFocused(),
            this.mostRecentEvent_ = a,
            (0,
            aa.block)(),
            this.targetBlock_ && this.targetBlock_.select(),
            (0,
            y.isRightButton)(a) ? this.handleRightClick(a) : ("touchstart" !== a.type.toLowerCase() && "pointerdown" !== a.type.toLowerCase() || "mouse" === a.pointerType || (0,
            O.longStart)(a, this),
            this.mouseDownXY_ = new J(a.clientX,a.clientY),
            this.healStack_ = a.altKey || a.ctrlKey || a.metaKey,
            this.bindMouseEvents(a)))
        }
        ;
        ba.prototype.bindMouseEvents = function(a) {
            this.onMoveWrapper_ = (0,
            y.conditionalBind)(document, "mousemove", null, this.handleMove.bind(this));
            this.onUpWrapper_ = (0,
            y.conditionalBind)(document, "mouseup", null, this.handleUp.bind(this));
            a.preventDefault();
            a.stopPropagation()
        }
        ;
        ba.prototype.handleMove = function(a) {
            this.updateFromEvent_(a);
            this.isDraggingWorkspace_ ? this.workspaceDragger_.drag(this.currentDragDeltaXY_) : this.isDraggingBlock_ ? this.blockDragger_.drag(this.mostRecentEvent_, this.currentDragDeltaXY_) : this.isDraggingBubble_ && this.bubbleDragger_.dragBubble(this.mostRecentEvent_, this.currentDragDeltaXY_);
            a.preventDefault();
            a.stopPropagation()
        }
        ;
        ba.prototype.handleUp = function(a) {
            this.updateFromEvent_(a);
            (0,
            O.longStop)();
            this.isEnding_ ? console.log("Trying to end a gesture recursively.") : (this.isEnding_ = !0,
            this.isDraggingBubble_ ? this.bubbleDragger_.endBubbleDrag(a, this.currentDragDeltaXY_) : this.isDraggingBlock_ ? this.blockDragger_.endDrag(a, this.currentDragDeltaXY_) : this.isDraggingWorkspace_ ? this.workspaceDragger_.endDrag(this.currentDragDeltaXY_) : this.isBubbleClick_() ? this.doBubbleClick_() : this.isFieldClick_() ? this.doFieldClick_() : this.isBlockClick_() ? this.doBlockClick_() : this.isWorkspaceClick_() && this.doWorkspaceClick_(a),
            a.preventDefault(),
            a.stopPropagation(),
            this.dispose())
        }
        ;
        ba.prototype.cancel = function() {
            this.isEnding_ || ((0,
            O.longStop)(),
            this.isDraggingBubble_ ? this.bubbleDragger_.endBubbleDrag(this.mostRecentEvent_, this.currentDragDeltaXY_) : this.isDraggingBlock_ ? this.blockDragger_.endDrag(this.mostRecentEvent_, this.currentDragDeltaXY_) : this.isDraggingWorkspace_ && this.workspaceDragger_.endDrag(this.currentDragDeltaXY_),
            this.dispose())
        }
        ;
        ba.prototype.handleRightClick = function(a) {
            this.targetBlock_ ? (this.bringBlockToFront_(),
            this.targetBlock_.workspace.hideChaff(!!this.flyout_),
            this.targetBlock_.showContextMenu(a)) : this.startBubble_ ? this.startBubble_.showContextMenu(a) : this.startWorkspace_ && !this.flyout_ && (this.startWorkspace_.hideChaff(),
            this.startWorkspace_.showContextMenu(a));
            a.preventDefault();
            a.stopPropagation();
            this.dispose()
        }
        ;
        ba.prototype.handleWsStart = function(a, b) {
            if (this.hasStarted_)
                throw Error("Tried to call gesture.handleWsStart, but the gesture had already been started.");
            this.setStartWorkspace_(b);
            this.mostRecentEvent_ = a;
            this.doStart(a)
        }
        ;
        ba.prototype.fireWorkspaceClick_ = function(a) {
            (0,
            k.fire)(new ((0,
            k.get)(k.CLICK))(null,a.id,"workspace"))
        }
        ;
        ba.prototype.handleFlyoutStart = function(a, b) {
            if (this.hasStarted_)
                throw Error("Tried to call gesture.handleFlyoutStart, but the gesture had already been started.");
            this.setStartFlyout_(b);
            this.handleWsStart(a, b.getWorkspace())
        }
        ;
        ba.prototype.handleBlockStart = function(a, b) {
            if (this.hasStarted_)
                throw Error("Tried to call gesture.handleBlockStart, but the gesture had already been started.");
            this.setStartBlock(b);
            this.mostRecentEvent_ = a
        }
        ;
        ba.prototype.handleBubbleStart = function(a, b) {
            if (this.hasStarted_)
                throw Error("Tried to call gesture.handleBubbleStart, but the gesture had already been started.");
            this.setStartBubble(b);
            this.mostRecentEvent_ = a
        }
        ;
        ba.prototype.doBubbleClick_ = function() {
            this.startBubble_.setFocus && this.startBubble_.setFocus();
            this.startBubble_.select && this.startBubble_.select()
        }
        ;
        ba.prototype.doFieldClick_ = function() {
            this.startField_.showEditor(this.mostRecentEvent_);
            this.bringBlockToFront_()
        }
        ;
        ba.prototype.doBlockClick_ = function() {
            if (this.flyout_ && this.flyout_.autoClose)
                this.targetBlock_.isEnabled() && ((0,
                k.getGroup)() || (0,
                k.setGroup)(!0),
                this.flyout_.createBlock(this.targetBlock_).scheduleSnapAndBump());
            else {
                var a = new ((0,
                k.get)(k.CLICK))(this.startBlock_,this.startWorkspace_.id,"block");
                (0,
                k.fire)(a)
            }
            this.bringBlockToFront_();
            (0,
            k.setGroup)(!1)
        }
        ;
        ba.prototype.doWorkspaceClick_ = function(a) {
            a = this.creatorWorkspace_;
            (0,
            e.module$exports$Blockly$common.getSelected)() && (0,
            e.module$exports$Blockly$common.getSelected)().unselect();
            this.fireWorkspaceClick_(this.startWorkspace_ || a)
        }
        ;
        ba.prototype.bringBlockToFront_ = function() {
            this.targetBlock_ && !this.flyout_ && this.targetBlock_.bringToFront()
        }
        ;
        ba.prototype.setStartField = function(a) {
            if (this.hasStarted_)
                throw Error("Tried to call gesture.setStartField, but the gesture had already been started.");
            this.startField_ || (this.startField_ = a)
        }
        ;
        ba.prototype.setStartBubble = function(a) {
            this.startBubble_ || (this.startBubble_ = a)
        }
        ;
        ba.prototype.setStartBlock = function(a) {
            this.startBlock_ || this.startBubble_ || (this.startBlock_ = a,
            a.isInFlyout && a !== a.getRootBlock() ? this.setTargetBlock_(a.getRootBlock()) : this.setTargetBlock_(a))
        }
        ;
        ba.prototype.setTargetBlock_ = function(a) {
            a.isShadow() ? this.setTargetBlock_(a.getParent()) : this.targetBlock_ = a
        }
        ;
        ba.prototype.setStartWorkspace_ = function(a) {
            this.startWorkspace_ || (this.startWorkspace_ = a)
        }
        ;
        ba.prototype.setStartFlyout_ = function(a) {
            this.flyout_ || (this.flyout_ = a)
        }
        ;
        ba.prototype.isBubbleClick_ = function() {
            return !!this.startBubble_ && !this.hasExceededDragRadius_
        }
        ;
        ba.prototype.isBlockClick_ = function() {
            return !!this.startBlock_ && !this.hasExceededDragRadius_ && !this.isFieldClick_()
        }
        ;
        ba.prototype.isFieldClick_ = function() {
            return (this.startField_ ? this.startField_.isClickable() : !1) && !this.hasExceededDragRadius_ && (!this.flyout_ || !this.flyout_.autoClose)
        }
        ;
        ba.prototype.isWorkspaceClick_ = function() {
            return !this.startBlock_ && !this.startBubble_ && !this.startField_ && !this.hasExceededDragRadius_
        }
        ;
        ba.prototype.isDragging = function() {
            return this.isDraggingWorkspace_ || this.isDraggingBlock_ || this.isDraggingBubble_
        }
        ;
        ba.prototype.hasStarted = function() {
            return this.hasStarted_
        }
        ;
        ba.prototype.getInsertionMarkers = function() {
            return this.blockDragger_ ? this.blockDragger_.getInsertionMarkers() : []
        }
        ;
        ba.prototype.getCurrentDragger = function() {
            return this.isDraggingBlock_ ? this.blockDragger_ : this.isDraggingWorkspace_ ? this.workspaceDragger_ : this.isDraggingBubble_ ? this.bubbleDragger_ : null
        }
        ;
        ba.inProgress = function() {
            for (var a = N.Workspace.getAll(), b = 0, c; c = a[b]; b++)
                if (c.currentGesture_)
                    return !0;
            return !1
        }
        ;
        var I = function(a, b, c) {
            this.value_ = this.DEFAULT_VALUE;
            this.tooltip_ = this.validator_ = null;
            this.size_ = new Pa(0,0);
            this.constants_ = this.mouseDownWrapper_ = this.textContent_ = this.textElement_ = this.borderRect_ = this.fieldGroup_ = this.markerSvg_ = this.cursorSvg_ = null;
            c && this.configure_(c);
            this.setValue(a);
            b && this.setValidator(b)
        };
        I.prototype.DEFAULT_VALUE = null;
        I.prototype.name = void 0;
        I.prototype.disposed = !1;
        I.prototype.maxDisplayLength = 50;
        I.prototype.sourceBlock_ = null;
        I.prototype.isDirty_ = !0;
        I.prototype.visible_ = !0;
        I.prototype.enabled_ = !0;
        I.prototype.clickTarget_ = null;
        I.NBSP = "\u00a0";
        I.prototype.EDITABLE = !0;
        I.prototype.SERIALIZABLE = !1;
        I.prototype.configure_ = function(a) {
            var b = a.tooltip;
            "string" === typeof b && (b = (0,
            ka.replaceMessageReferences)(a.tooltip));
            b && this.setTooltip(b)
        }
        ;
        I.prototype.setSourceBlock = function(a) {
            if (this.sourceBlock_)
                throw Error("Field already bound to a block");
            this.sourceBlock_ = a
        }
        ;
        I.prototype.getConstants = function() {
            !this.constants_ && this.sourceBlock_ && this.sourceBlock_.workspace && this.sourceBlock_.workspace.rendered && (this.constants_ = this.sourceBlock_.workspace.getRenderer().getConstants());
            return this.constants_
        }
        ;
        I.prototype.getSourceBlock = function() {
            return this.sourceBlock_
        }
        ;
        I.prototype.init = function() {
            this.fieldGroup_ || (this.fieldGroup_ = (0,
            n.createSvgElement)(u.G, {}, null),
            this.isVisible() || (this.fieldGroup_.style.display = "none"),
            this.sourceBlock_.getSvgRoot().appendChild(this.fieldGroup_),
            this.initView(),
            this.updateEditable(),
            this.setTooltip(this.tooltip_),
            this.bindEvents_(),
            this.initModel())
        }
        ;
        I.prototype.initView = function() {
            this.createBorderRect_();
            this.createTextElement_()
        }
        ;
        I.prototype.initModel = function() {}
        ;
        I.prototype.createBorderRect_ = function() {
            this.borderRect_ = (0,
            n.createSvgElement)(u.RECT, {
                rx: this.getConstants().FIELD_BORDER_RECT_RADIUS,
                ry: this.getConstants().FIELD_BORDER_RECT_RADIUS,
                x: 0,
                y: 0,
                height: this.size_.height,
                width: this.size_.width,
                "class": "blocklyFieldRect"
            }, this.fieldGroup_)
        }
        ;
        I.prototype.createTextElement_ = function() {
            this.textElement_ = (0,
            n.createSvgElement)(u.TEXT, {
                "class": "blocklyText"
            }, this.fieldGroup_);
            this.getConstants().FIELD_TEXT_BASELINE_CENTER && this.textElement_.setAttribute("dominant-baseline", "central");
            this.textContent_ = document.createTextNode("");
            this.textElement_.appendChild(this.textContent_)
        }
        ;
        I.prototype.bindEvents_ = function() {
            (0,
            aa.bindMouseEvents)(this.getClickTarget_());
            this.mouseDownWrapper_ = (0,
            y.conditionalBind)(this.getClickTarget_(), "mousedown", this, this.onMouseDown_)
        }
        ;
        I.prototype.fromXml = function(a) {
            this.setValue(a.textContent)
        }
        ;
        I.prototype.toXml = function(a) {
            a.textContent = this.getValue();
            return a
        }
        ;
        I.prototype.saveState = function(a) {
            a = this.saveLegacyState(I);
            return null !== a ? a : this.getValue()
        }
        ;
        I.prototype.loadState = function(a) {
            this.loadLegacyState(I, a) || this.setValue(a)
        }
        ;
        I.prototype.saveLegacyState = function(a) {
            return a.prototype.saveState === this.saveState && a.prototype.toXml !== this.toXml ? (a = (0,
            e.module$exports$Blockly$utils$xml.createElement)("field"),
            a.setAttribute("name", this.name || ""),
            (0,
            e.module$exports$Blockly$Xml.domToText)(this.toXml(a)).replace(' xmlns="https://developers.google.com/blockly/xml"', "")) : null
        }
        ;
        I.prototype.loadLegacyState = function(a, b) {
            return a.prototype.loadState === this.loadState && a.prototype.fromXml !== this.fromXml ? (this.fromXml((0,
            e.module$exports$Blockly$Xml.textToDom)(b)),
            !0) : !1
        }
        ;
        I.prototype.dispose = function() {
            C.hideIfOwner(this);
            (0,
            sa.hideIfOwner)(this);
            (0,
            aa.unbindMouseEvents)(this.getClickTarget_());
            this.mouseDownWrapper_ && (0,
            y.unbind)(this.mouseDownWrapper_);
            (0,
            n.removeNode)(this.fieldGroup_);
            this.disposed = !0
        }
        ;
        I.prototype.updateEditable = function() {
            var a = this.fieldGroup_;
            this.EDITABLE && a && (this.enabled_ && this.sourceBlock_.isEditable() ? ((0,
            n.addClass)(a, "blocklyEditableText"),
            (0,
            n.removeClass)(a, "blocklyNonEditableText"),
            a.style.cursor = this.CURSOR) : ((0,
            n.addClass)(a, "blocklyNonEditableText"),
            (0,
            n.removeClass)(a, "blocklyEditableText"),
            a.style.cursor = ""))
        }
        ;
        I.prototype.setEnabled = function(a) {
            this.enabled_ = a;
            this.updateEditable()
        }
        ;
        I.prototype.isEnabled = function() {
            return this.enabled_
        }
        ;
        I.prototype.isClickable = function() {
            return this.enabled_ && !!this.sourceBlock_ && this.sourceBlock_.isEditable() && !!this.showEditor_ && "function" === typeof this.showEditor_
        }
        ;
        I.prototype.isCurrentlyEditable = function() {
            return this.enabled_ && this.EDITABLE && !!this.sourceBlock_ && this.sourceBlock_.isEditable()
        }
        ;
        I.prototype.isSerializable = function() {
            var a = !1;
            this.name && (this.SERIALIZABLE ? a = !0 : this.EDITABLE && (console.warn("Detected an editable field that was not serializable. Please define SERIALIZABLE property as true on all editable custom fields. Proceeding with serialization."),
            a = !0));
            return a
        }
        ;
        I.prototype.isVisible = function() {
            return this.visible_
        }
        ;
        I.prototype.setVisible = function(a) {
            if (this.visible_ !== a) {
                this.visible_ = a;
                var b = this.getSvgRoot();
                b && (b.style.display = a ? "block" : "none")
            }
        }
        ;
        I.prototype.setValidator = function(a) {
            this.validator_ = a
        }
        ;
        I.prototype.getValidator = function() {
            return this.validator_
        }
        ;
        I.prototype.getSvgRoot = function() {
            return this.fieldGroup_
        }
        ;
        I.prototype.applyColour = function() {}
        ;
        I.prototype.render_ = function() {
            this.textContent_ && (this.textContent_.nodeValue = this.getDisplayText_());
            this.updateSize_()
        }
        ;
        I.prototype.showEditor = function(a) {
            this.isClickable() && this.showEditor_(a)
        }
        ;
        I.prototype.updateSize_ = function(a) {
            var b = this.getConstants();
            a = void 0 !== a ? a : this.borderRect_ ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;
            var c = 2 * a
              , d = b.FIELD_TEXT_HEIGHT
              , f = 0;
            this.textElement_ && (f = (0,
            n.getFastTextWidth)(this.textElement_, b.FIELD_TEXT_FONTSIZE, b.FIELD_TEXT_FONTWEIGHT, b.FIELD_TEXT_FONTFAMILY),
            c += f);
            this.borderRect_ && (d = Math.max(d, b.FIELD_BORDER_RECT_HEIGHT));
            this.size_.height = d;
            this.size_.width = c;
            this.positionTextElement_(a, f);
            this.positionBorderRect_()
        }
        ;
        I.prototype.positionTextElement_ = function(a, b) {
            if (this.textElement_) {
                var c = this.getConstants()
                  , d = this.size_.height / 2;
                this.textElement_.setAttribute("x", this.sourceBlock_.RTL ? this.size_.width - b - a : a);
                this.textElement_.setAttribute("y", c.FIELD_TEXT_BASELINE_CENTER ? d : d - c.FIELD_TEXT_HEIGHT / 2 + c.FIELD_TEXT_BASELINE)
            }
        }
        ;
        I.prototype.positionBorderRect_ = function() {
            this.borderRect_ && (this.borderRect_.setAttribute("width", this.size_.width),
            this.borderRect_.setAttribute("height", this.size_.height),
            this.borderRect_.setAttribute("rx", this.getConstants().FIELD_BORDER_RECT_RADIUS),
            this.borderRect_.setAttribute("ry", this.getConstants().FIELD_BORDER_RECT_RADIUS))
        }
        ;
        I.prototype.getSize = function() {
            if (!this.isVisible())
                return new Pa(0,0);
            this.isDirty_ ? (this.render_(),
            this.isDirty_ = !1) : this.visible_ && 0 === this.size_.width && (console.warn("Deprecated use of setting size_.width to 0 to rerender a field. Set field.isDirty_ to true instead."),
            this.render_());
            return this.size_
        }
        ;
        I.prototype.getScaledBBox = function() {
            if (this.borderRect_)
                var a = this.borderRect_.getBoundingClientRect()
                  , b = (0,
                ta.getPageOffset)(this.borderRect_)
                  , c = a.width
                  , d = a.height;
            else
                d = this.sourceBlock_.getHeightWidth(),
                a = this.sourceBlock_.workspace.scale,
                b = this.getAbsoluteXY_(),
                c = d.width * a,
                d = d.height * a,
                V.GECKO ? (b.x += 1.5 * a,
                b.y += 1.5 * a) : V.EDGE || V.IE || (b.x -= .5 * a,
                b.y -= .5 * a),
                c += 1 * a,
                d += 1 * a;
            return new Ha(b.y,b.y + d,b.x,b.x + c)
        }
        ;
        I.prototype.getDisplayText_ = function() {
            var a = this.getText();
            if (!a)
                return I.NBSP;
            a.length > this.maxDisplayLength && (a = a.substring(0, this.maxDisplayLength - 2) + "\u2026");
            a = a.replace(/\s/g, I.NBSP);
            this.sourceBlock_ && this.sourceBlock_.RTL && (a += "\u200f");
            return a
        }
        ;
        I.prototype.getText = function() {
            if (this.getText_) {
                var a = this.getText_.call(this);
                if (null !== a)
                    return String(a)
            }
            return String(this.getValue())
        }
        ;
        I.prototype.markDirty = function() {
            this.isDirty_ = !0;
            this.constants_ = null
        }
        ;
        I.prototype.forceRerender = function() {
            this.isDirty_ = !0;
            this.sourceBlock_ && this.sourceBlock_.rendered && (this.sourceBlock_.render(),
            this.sourceBlock_.bumpNeighbours(),
            this.updateMarkers_())
        }
        ;
        I.prototype.setValue = function(a) {
            if (null !== a) {
                var b = this.doClassValidation_(a);
                a = this.processValidation_(a, b);
                if (!(a instanceof Error)) {
                    if (b = this.getValidator())
                        if (b = b.call(this, a),
                        a = this.processValidation_(a, b),
                        a instanceof Error)
                            return;
                    b = this.sourceBlock_;
                    if (!b || !b.disposed) {
                        var c = this.getValue();
                        c === a ? this.doValueUpdate_(a) : (this.doValueUpdate_(a),
                        b && (0,
                        k.isEnabled)() && (0,
                        k.fire)(new ((0,
                        k.get)(k.CHANGE))(b,"field",this.name || null,c,a)),
                        this.isDirty_ && this.forceRerender())
                    }
                }
            }
        }
        ;
        I.prototype.processValidation_ = function(a, b) {
            if (null === b)
                return this.doValueInvalid_(a),
                this.isDirty_ && this.forceRerender(),
                Error();
            void 0 !== b && (a = b);
            return a
        }
        ;
        I.prototype.getValue = function() {
            return this.value_
        }
        ;
        I.prototype.doClassValidation_ = function(a) {
            return null === a || void 0 === a ? null : a
        }
        ;
        I.prototype.doValueUpdate_ = function(a) {
            this.value_ = a;
            this.isDirty_ = !0
        }
        ;
        I.prototype.doValueInvalid_ = function(a) {}
        ;
        I.prototype.onMouseDown_ = function(a) {
            this.sourceBlock_ && this.sourceBlock_.workspace && (a = this.sourceBlock_.workspace.getGesture(a)) && a.setStartField(this)
        }
        ;
        I.prototype.setTooltip = function(a) {
            a || "" === a || (a = this.sourceBlock_);
            var b = this.getClickTarget_();
            b ? b.tooltip = a : this.tooltip_ = a
        }
        ;
        I.prototype.getTooltip = function() {
            var a = this.getClickTarget_();
            return a ? (0,
            aa.getTooltipOfObject)(a) : (0,
            aa.getTooltipOfObject)({
                tooltip: this.tooltip_
            })
        }
        ;
        I.prototype.getClickTarget_ = function() {
            return this.clickTarget_ || this.getSvgRoot()
        }
        ;
        I.prototype.getAbsoluteXY_ = function() {
            return (0,
            ta.getPageOffset)(this.getClickTarget_())
        }
        ;
        I.prototype.referencesVariables = function() {
            return !1
        }
        ;
        I.prototype.getParentInput = function() {
            for (var a = null, b = this.sourceBlock_, c = b.inputList, d = 0; d < b.inputList.length; d++)
                for (var f = c[d], g = f.fieldRow, m = 0; m < g.length; m++)
                    if (g[m] === this) {
                        a = f;
                        break
                    }
            return a
        }
        ;
        I.prototype.getFlipRtl = function() {
            return !1
        }
        ;
        I.prototype.isTabNavigable = function() {
            return !1
        }
        ;
        I.prototype.onShortcut = function(a) {
            return !1
        }
        ;
        I.prototype.setCursorSvg = function(a) {
            a ? (this.fieldGroup_.appendChild(a),
            this.cursorSvg_ = a) : this.cursorSvg_ = null
        }
        ;
        I.prototype.setMarkerSvg = function(a) {
            a ? (this.fieldGroup_.appendChild(a),
            this.markerSvg_ = a) : this.markerSvg_ = null
        }
        ;
        I.prototype.updateMarkers_ = function() {
            var a = this.sourceBlock_.workspace;
            a.keyboardAccessibilityMode && this.cursorSvg_ && a.getCursor().draw();
            a.keyboardAccessibilityMode && this.markerSvg_ && a.getMarker(ub.LOCAL_MARKER).draw()
        }
        ;
        e.module$exports$Blockly$FieldLabel = {
            FieldLabel: function(a, b, c) {
                this.class_ = null;
                e.module$exports$Blockly$FieldLabel.FieldLabel.superClass_.constructor.call(this, a, null, c);
                c || (this.class_ = b || null)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(e.module$exports$Blockly$FieldLabel.FieldLabel, I);
        e.module$exports$Blockly$FieldLabel.FieldLabel.prototype.DEFAULT_VALUE = "";
        e.module$exports$Blockly$FieldLabel.FieldLabel.fromJson = function(a) {
            return new this((0,
            ka.replaceMessageReferences)(a.text),void 0,a)
        }
        ;
        e.module$exports$Blockly$FieldLabel.FieldLabel.prototype.EDITABLE = !1;
        e.module$exports$Blockly$FieldLabel.FieldLabel.prototype.configure_ = function(a) {
            e.module$exports$Blockly$FieldLabel.FieldLabel.superClass_.configure_.call(this, a);
            this.class_ = a["class"]
        }
        ;
        e.module$exports$Blockly$FieldLabel.FieldLabel.prototype.initView = function() {
            this.createTextElement_();
            this.class_ && (0,
            n.addClass)(this.textElement_, this.class_)
        }
        ;
        e.module$exports$Blockly$FieldLabel.FieldLabel.prototype.doClassValidation_ = function(a) {
            return null === a || void 0 === a ? null : String(a)
        }
        ;
        e.module$exports$Blockly$FieldLabel.FieldLabel.prototype.setClass = function(a) {
            this.textElement_ && (this.class_ && (0,
            n.removeClass)(this.textElement_, this.class_),
            a && (0,
            n.addClass)(this.textElement_, a));
            this.class_ = a
        }
        ;
        (0,
        tb.register)("field_label", e.module$exports$Blockly$FieldLabel.FieldLabel);
        var Ia = function(a) {
            this.debugElements_ = [];
            this.svgRoot_ = null;
            this.constants_ = a
        };
        Ia.config = {
            rowSpacers: !0,
            elemSpacers: !0,
            rows: !0,
            elems: !0,
            connections: !0,
            blockBounds: !0,
            connectedBlockBounds: !0,
            render: !0
        };
        Ia.prototype.clearElems = function() {
            for (var a = 0; a < this.debugElements_.length; a++)
                (0,
                n.removeNode)(this.debugElements_[a]);
            this.debugElements_ = []
        }
        ;
        Ia.prototype.drawSpacerRow = function(a, b, c) {
            if (Ia.config.rowSpacers) {
                var d = Math.abs(a.height)
                  , f = 0 > a.height;
                f && (b -= d);
                this.debugElements_.push((0,
                n.createSvgElement)(u.RECT, {
                    "class": "rowSpacerRect blockRenderDebug",
                    x: c ? -(a.xPos + a.width) : a.xPos,
                    y: b,
                    width: a.width,
                    height: d,
                    stroke: f ? "black" : "blue",
                    fill: "blue",
                    "fill-opacity": "0.5",
                    "stroke-width": "1px"
                }, this.svgRoot_))
            }
        }
        ;
        Ia.prototype.drawSpacerElem = function(a, b, c) {
            if (Ia.config.elemSpacers) {
                b = Math.abs(a.width);
                var d = 0 > a.width
                  , f = d ? a.xPos - b : a.xPos;
                c && (f = -(f + b));
                this.debugElements_.push((0,
                n.createSvgElement)(u.RECT, {
                    "class": "elemSpacerRect blockRenderDebug",
                    x: f,
                    y: a.centerline - a.height / 2,
                    width: b,
                    height: a.height,
                    stroke: "pink",
                    fill: d ? "black" : "pink",
                    "fill-opacity": "0.5",
                    "stroke-width": "1px"
                }, this.svgRoot_))
            }
        }
        ;
        Ia.prototype.drawRenderedElem = function(a, b) {
            if (Ia.config.elems) {
                var c = a.xPos;
                b && (c = -(c + a.width));
                b = a.centerline - a.height / 2;
                this.debugElements_.push((0,
                n.createSvgElement)(u.RECT, {
                    "class": "rowRenderingRect blockRenderDebug",
                    x: c,
                    y: b,
                    width: a.width,
                    height: a.height,
                    stroke: "black",
                    fill: "none",
                    "stroke-width": "1px"
                }, this.svgRoot_));
                p.isField(a) && a.field instanceof e.module$exports$Blockly$FieldLabel.FieldLabel && this.debugElements_.push((0,
                n.createSvgElement)(u.RECT, {
                    "class": "rowRenderingRect blockRenderDebug",
                    x: c,
                    y: b + this.constants_.FIELD_TEXT_BASELINE,
                    width: a.width,
                    height: "0.1px",
                    stroke: "red",
                    fill: "none",
                    "stroke-width": "0.5px"
                }, this.svgRoot_))
            }
            p.isInput(a) && Ia.config.connections && this.drawConnection(a.connectionModel)
        }
        ;
        Ia.prototype.drawConnection = function(a) {
            if (Ia.config.connections) {
                if (a.type === e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE)
                    var b = 4
                      , c = "magenta"
                      , d = "none";
                else
                    a.type === e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE ? (b = 2,
                    d = c = "magenta") : a.type === e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT ? (b = 4,
                    c = "goldenrod",
                    d = "none") : a.type === e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT && (b = 2,
                    d = c = "goldenrod");
                this.debugElements_.push((0,
                n.createSvgElement)(u.CIRCLE, {
                    "class": "blockRenderDebug",
                    cx: a.offsetInBlock_.x,
                    cy: a.offsetInBlock_.y,
                    r: b,
                    fill: d,
                    stroke: c
                }, this.svgRoot_))
            }
        }
        ;
        Ia.prototype.drawRenderedRow = function(a, b, c) {
            Ia.config.rows && (this.debugElements_.push((0,
            n.createSvgElement)(u.RECT, {
                "class": "elemRenderingRect blockRenderDebug",
                x: c ? -(a.xPos + a.width) : a.xPos,
                y: a.yPos,
                width: a.width,
                height: a.height,
                stroke: "red",
                fill: "none",
                "stroke-width": "1px"
            }, this.svgRoot_)),
            p.isTopOrBottomRow(a) || Ia.config.connectedBlockBounds && this.debugElements_.push((0,
            n.createSvgElement)(u.RECT, {
                "class": "connectedBlockWidth blockRenderDebug",
                x: c ? -(a.xPos + a.widthWithConnectedBlocks) : a.xPos,
                y: a.yPos,
                width: a.widthWithConnectedBlocks,
                height: a.height,
                stroke: this.randomColour_,
                fill: "none",
                "stroke-width": "1px",
                "stroke-dasharray": "3,3"
            }, this.svgRoot_)))
        }
        ;
        Ia.prototype.drawRowWithElements = function(a, b, c) {
            for (var d = 0; d < a.elements.length; d++) {
                var f = a.elements[d];
                f ? p.isSpacer(f) ? this.drawSpacerElem(f, a.height, c) : this.drawRenderedElem(f, c) : console.warn("A row has an undefined or null element.", a, f)
            }
            this.drawRenderedRow(a, b, c)
        }
        ;
        Ia.prototype.drawBoundingBox = function(a) {
            if (Ia.config.blockBounds) {
                var b = a.RTL ? -a.width : 0;
                this.debugElements_.push((0,
                n.createSvgElement)(u.RECT, {
                    "class": "blockBoundingBox blockRenderDebug",
                    x: b,
                    y: 0,
                    width: a.width,
                    height: a.height,
                    stroke: "black",
                    fill: "none",
                    "stroke-width": "1px",
                    "stroke-dasharray": "5,5"
                }, this.svgRoot_));
                Ia.config.connectedBlockBounds && (b = a.RTL ? -a.widthWithChildren : 0,
                this.debugElements_.push((0,
                n.createSvgElement)(u.RECT, {
                    "class": "blockRenderDebug",
                    x: b,
                    y: 0,
                    width: a.widthWithChildren,
                    height: a.height,
                    stroke: "#DF57BC",
                    fill: "none",
                    "stroke-width": "1px",
                    "stroke-dasharray": "3,3"
                }, this.svgRoot_)))
            }
        }
        ;
        Ia.prototype.drawDebug = function(a, b) {
            this.clearElems();
            this.svgRoot_ = a.getSvgRoot();
            this.randomColour_ = "#" + Math.floor(16777215 * Math.random()).toString(16);
            for (var c = 0, d = 0; d < b.rows.length; d++) {
                var f = b.rows[d];
                p.isBetweenRowSpacer(f) ? this.drawSpacerRow(f, c, b.RTL) : this.drawRowWithElements(f, c, b.RTL);
                c += f.height
            }
            a.previousConnection && this.drawConnection(a.previousConnection);
            a.nextConnection && this.drawConnection(a.nextConnection);
            a.outputConnection && this.drawConnection(a.outputConnection);
            b.rightSide && this.drawRenderedElem(b.rightSide, b.RTL);
            this.drawBoundingBox(b);
            this.drawRender(a.pathObject.svgPath)
        }
        ;
        Ia.prototype.drawRender = function(a) {
            Ia.config.render && (a.setAttribute("filter", "url(#" + this.constants_.debugFilterId + ")"),
            setTimeout(function() {
                a.setAttribute("filter", "")
            }, 100))
        }
        ;
        var Ca = function(a, b) {
            this.block_ = a;
            this.info_ = b;
            this.topLeft_ = a.getRelativeToSurfaceXY();
            this.inlinePath_ = this.outlinePath_ = "";
            this.constants_ = b.getRenderer().getConstants()
        };
        Ca.prototype.draw = function() {
            this.hideHiddenIcons_();
            this.drawOutline_();
            this.drawInternals_();
            this.block_.pathObject.setPath(this.outlinePath_ + "\n" + this.inlinePath_);
            this.info_.RTL && this.block_.pathObject.flipRTL();
            (0,
            Nb.isDebuggerEnabled)() && this.block_.renderingDebugger.drawDebug(this.block_, this.info_);
            this.recordSizeOnBlock_()
        }
        ;
        Ca.prototype.recordSizeOnBlock_ = function() {
            this.block_.height = this.info_.height;
            this.block_.width = this.info_.widthWithChildren
        }
        ;
        Ca.prototype.hideHiddenIcons_ = function() {
            for (var a = 0, b; b = this.info_.hiddenIcons[a]; a++)
                b.icon.iconGroup_.setAttribute("display", "none")
        }
        ;
        Ca.prototype.drawOutline_ = function() {
            this.drawTop_();
            for (var a = 1; a < this.info_.rows.length - 1; a++) {
                var b = this.info_.rows[a];
                b.hasJaggedEdge ? this.drawJaggedEdge_(b) : b.hasStatement ? this.drawStatementInput_(b) : b.hasExternalInput ? this.drawValueInput_(b) : this.drawRightSideRow_(b)
            }
            this.drawBottom_();
            this.drawLeft_()
        }
        ;
        Ca.prototype.drawTop_ = function() {
            var a = this.info_.topRow
              , b = a.elements;
            this.positionPreviousConnection_();
            this.outlinePath_ += (0,
            t.moveBy)(a.xPos, this.info_.startY);
            for (var c = 0, d; d = b[c]; c++)
                p.isLeftRoundedCorner(d) ? this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topLeft : p.isRightRoundedCorner(d) ? this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topRight : p.isPreviousConnection(d) ? this.outlinePath_ += d.shape.pathLeft : p.isHat(d) ? this.outlinePath_ += this.constants_.START_HAT.path : p.isSpacer(d) && (this.outlinePath_ += (0,
                t.lineOnAxis)("h", d.width));
            this.outlinePath_ += (0,
            t.lineOnAxis)("v", a.height)
        }
        ;
        Ca.prototype.drawJaggedEdge_ = function(a) {
            this.outlinePath_ += this.constants_.JAGGED_TEETH.path + (0,
            t.lineOnAxis)("v", a.height - this.constants_.JAGGED_TEETH.height)
        }
        ;
        Ca.prototype.drawValueInput_ = function(a) {
            var b = a.getLastInput();
            this.positionExternalValueConnection_(a);
            var c = "function" === typeof b.shape.pathDown ? b.shape.pathDown(b.height) : b.shape.pathDown;
            this.outlinePath_ += (0,
            t.lineOnAxis)("H", b.xPos + b.width) + c + (0,
            t.lineOnAxis)("v", a.height - b.connectionHeight)
        }
        ;
        Ca.prototype.drawStatementInput_ = function(a) {
            var b = a.getLastInput()
              , c = b.xPos + b.notchOffset + b.shape.width;
            b = b.shape.pathRight + (0,
            t.lineOnAxis)("h", -(b.notchOffset - this.constants_.INSIDE_CORNERS.width)) + this.constants_.INSIDE_CORNERS.pathTop;
            var d = a.height - 2 * this.constants_.INSIDE_CORNERS.height;
            this.outlinePath_ += (0,
            t.lineOnAxis)("H", c) + b + (0,
            t.lineOnAxis)("v", d) + this.constants_.INSIDE_CORNERS.pathBottom + (0,
            t.lineOnAxis)("H", a.xPos + a.width);
            this.positionStatementInputConnection_(a)
        }
        ;
        Ca.prototype.drawRightSideRow_ = function(a) {
            this.outlinePath_ += (0,
            t.lineOnAxis)("V", a.yPos + a.height)
        }
        ;
        Ca.prototype.drawBottom_ = function() {
            var a = this.info_.bottomRow
              , b = a.elements;
            this.positionNextConnection_();
            for (var c = 0, d = "", f = b.length - 1, g; g = b[f]; f--)
                p.isNextConnection(g) ? d += g.shape.pathRight : p.isLeftSquareCorner(g) ? d += (0,
                t.lineOnAxis)("H", a.xPos) : p.isLeftRoundedCorner(g) ? d += this.constants_.OUTSIDE_CORNERS.bottomLeft : p.isRightRoundedCorner(g) ? (d += this.constants_.OUTSIDE_CORNERS.bottomRight,
                c = this.constants_.OUTSIDE_CORNERS.rightHeight) : p.isSpacer(g) && (d += (0,
                t.lineOnAxis)("h", -1 * g.width));
            this.outlinePath_ += (0,
            t.lineOnAxis)("V", a.baseline - c);
            this.outlinePath_ += d
        }
        ;
        Ca.prototype.drawLeft_ = function() {
            var a = this.info_.outputConnection;
            this.positionOutputConnection_();
            if (a) {
                var b = a.connectionOffsetY + a.height;
                a = "function" === typeof a.shape.pathUp ? a.shape.pathUp(a.height) : a.shape.pathUp;
                this.outlinePath_ += (0,
                t.lineOnAxis)("V", b) + a
            }
            this.outlinePath_ += "z"
        }
        ;
        Ca.prototype.drawInternals_ = function() {
            for (var a = 0, b; b = this.info_.rows[a]; a++)
                for (var c = 0, d; d = b.elements[c]; c++)
                    p.isInlineInput(d) ? this.drawInlineInput_(d) : (p.isIcon(d) || p.isField(d)) && this.layoutField_(d)
        }
        ;
        Ca.prototype.layoutField_ = function(a) {
            if (p.isField(a))
                var b = a.field.getSvgRoot();
            else
                p.isIcon(a) && (b = a.icon.iconGroup_);
            var c = a.centerline - a.height / 2
              , d = a.xPos
              , f = "";
            this.info_.RTL && (d = -(d + a.width),
            a.flipRtl && (d += a.width,
            f = "scale(-1 1)"));
            p.isIcon(a) ? (b.setAttribute("display", "block"),
            b.setAttribute("transform", "translate(" + d + "," + c + ")"),
            a.icon.computeIconLocation()) : b.setAttribute("transform", "translate(" + d + "," + c + ")" + f);
            this.info_.isInsertionMarker && b.setAttribute("display", "none")
        }
        ;
        Ca.prototype.drawInlineInput_ = function(a) {
            var b = a.width
              , c = a.height
              , d = a.connectionOffsetY
              , f = a.connectionHeight + d;
            this.inlinePath_ += (0,
            t.moveTo)(a.xPos + a.connectionWidth, a.centerline - c / 2) + (0,
            t.lineOnAxis)("v", d) + a.shape.pathDown + (0,
            t.lineOnAxis)("v", c - f) + (0,
            t.lineOnAxis)("h", b - a.connectionWidth) + (0,
            t.lineOnAxis)("v", -c) + "z";
            this.positionInlineInputConnection_(a)
        }
        ;
        Ca.prototype.positionInlineInputConnection_ = function(a) {
            var b = a.centerline - a.height / 2;
            if (a.connectionModel) {
                var c = a.xPos + a.connectionWidth + a.connectionOffsetX;
                this.info_.RTL && (c *= -1);
                a.connectionModel.setOffsetInBlock(c, b + a.connectionOffsetY)
            }
        }
        ;
        Ca.prototype.positionStatementInputConnection_ = function(a) {
            var b = a.getLastInput();
            if (b.connectionModel) {
                var c = a.xPos + a.statementEdge + b.notchOffset;
                this.info_.RTL && (c *= -1);
                b.connectionModel.setOffsetInBlock(c, a.yPos)
            }
        }
        ;
        Ca.prototype.positionExternalValueConnection_ = function(a) {
            var b = a.getLastInput();
            if (b.connectionModel) {
                var c = a.xPos + a.width;
                this.info_.RTL && (c *= -1);
                b.connectionModel.setOffsetInBlock(c, a.yPos)
            }
        }
        ;
        Ca.prototype.positionPreviousConnection_ = function() {
            var a = this.info_.topRow;
            if (a.connection) {
                var b = a.xPos + a.notchOffset;
                a.connection.connectionModel.setOffsetInBlock(this.info_.RTL ? -b : b, 0)
            }
        }
        ;
        Ca.prototype.positionNextConnection_ = function() {
            var a = this.info_.bottomRow;
            if (a.connection) {
                var b = a.connection
                  , c = b.xPos;
                b.connectionModel.setOffsetInBlock(this.info_.RTL ? -c : c, a.baseline)
            }
        }
        ;
        Ca.prototype.positionOutputConnection_ = function() {
            if (this.info_.outputConnection) {
                var a = this.info_.startX + this.info_.outputConnection.connectionOffsetX;
                this.block_.outputConnection.setOffsetInBlock(this.info_.RTL ? -a : a, this.info_.outputConnection.connectionOffsetY)
            }
        }
        ;
        var Wc = {
            InputConnection: function(a, b) {
                Wc.InputConnection.superClass_.constructor.call(this, a, b.connection);
                this.type |= p.INPUT;
                this.input = b;
                this.align = b.align;
                (this.connectedBlock = b.connection && b.connection.targetBlock() ? b.connection.targetBlock() : null) ? (a = this.connectedBlock.getHeightWidth(),
                this.connectedBlockWidth = a.width,
                this.connectedBlockHeight = a.height) : this.connectedBlockHeight = this.connectedBlockWidth = 0;
                this.connectionOffsetY = this.connectionOffsetX = 0
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Wc.InputConnection, Gc.Connection);
        var id = {
            ExternalValueInput: function(a, b) {
                id.ExternalValueInput.superClass_.constructor.call(this, a, b);
                this.type |= p.EXTERNAL_VALUE_INPUT;
                this.height = this.connectedBlock ? this.connectedBlockHeight - this.constants_.TAB_OFFSET_FROM_TOP - this.constants_.MEDIUM_PADDING : this.shape.height;
                this.width = this.shape.width + this.constants_.EXTERNAL_VALUE_INPUT_PADDING;
                this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;
                this.connectionHeight = this.shape.height;
                this.connectionWidth = this.shape.width
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(id.ExternalValueInput, Wc.InputConnection);
        var Ad = {
            Field: function(a, b, c) {
                Ad.Field.superClass_.constructor.call(this, a);
                this.field = b;
                this.isEditable = b.EDITABLE;
                this.flipRtl = b.getFlipRtl();
                this.type |= p.FIELD;
                a = this.field.getSize();
                this.height = a.height;
                this.width = a.width;
                this.parentInput = c
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Ad.Field, Zb);
        var Bd = {
            Hat: function(a) {
                Bd.Hat.superClass_.constructor.call(this, a);
                this.type |= p.HAT;
                this.height = this.constants_.START_HAT.height;
                this.width = this.constants_.START_HAT.width;
                this.ascenderHeight = this.height
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Bd.Hat, Zb);
        var Cd = {
            Icon: function(a, b) {
                Cd.Icon.superClass_.constructor.call(this, a);
                this.icon = b;
                this.isVisible = b.isVisible();
                this.type |= p.ICON;
                a = b.getCorrectedSize();
                this.height = a.height;
                this.width = a.width
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Cd.Icon, Zb);
        var pb = {
            InRowSpacer: function(a, b) {
                pb.InRowSpacer.superClass_.constructor.call(this, a);
                this.type = this.type | p.SPACER | p.IN_ROW_SPACER;
                this.width = b;
                this.height = this.constants_.SPACER_DEFAULT_HEIGHT
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(pb.InRowSpacer, Zb);
        var jd = {
            InlineInput: function(a, b) {
                jd.InlineInput.superClass_.constructor.call(this, a, b);
                this.type |= p.INLINE_INPUT;
                this.connectedBlock ? (this.width = this.connectedBlockWidth,
                this.height = this.connectedBlockHeight) : (this.height = this.constants_.EMPTY_INLINE_INPUT_HEIGHT,
                this.width = this.constants_.EMPTY_INLINE_INPUT_PADDING);
                this.connectionHeight = this.isDynamicShape ? this.shape.height(this.height) : this.shape.height;
                this.connectionWidth = this.isDynamicShape ? this.shape.width(this.height) : this.shape.width;
                this.connectedBlock || (this.width += this.connectionWidth * (this.isDynamicShape ? 2 : 1));
                this.connectionOffsetY = this.isDynamicShape ? this.shape.connectionOffsetY(this.connectionHeight) : this.constants_.TAB_OFFSET_FROM_TOP;
                this.connectionOffsetX = this.isDynamicShape ? this.shape.connectionOffsetX(this.connectionWidth) : 0
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(jd.InlineInput, Wc.InputConnection);
        var Ic = {
            InputRow: function(a) {
                Ic.InputRow.superClass_.constructor.call(this, a);
                this.type |= p.INPUT_ROW;
                this.connectedBlockWidths = 0
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Ic.InputRow, Ob);
        Ic.InputRow.prototype.measure = function() {
            this.width = this.minWidth;
            this.height = this.minHeight;
            for (var a = 0, b = 0; b < this.elements.length; b++) {
                var c = this.elements[b];
                this.width += c.width;
                p.isInput(c) && (p.isStatementInput(c) ? a += c.connectedBlockWidth : p.isExternalInput(c) && 0 !== c.connectedBlockWidth && (a += c.connectedBlockWidth - c.connectionWidth));
                p.isSpacer(c) || (this.height = Math.max(this.height, c.height))
            }
            this.connectedBlockWidths = a;
            this.widthWithConnectedBlocks = this.width + a
        }
        ;
        Ic.InputRow.prototype.endsWithElemSpacer = function() {
            return !this.hasExternalInput && !this.hasStatement
        }
        ;
        var Dd = {
            JaggedEdge: function(a) {
                Dd.JaggedEdge.superClass_.constructor.call(this, a);
                this.type |= p.JAGGED_EDGE;
                this.height = this.constants_.JAGGED_TEETH.height;
                this.width = this.constants_.JAGGED_TEETH.width
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Dd.JaggedEdge, Zb);
        var A = {
            ASTNode: function(a, b, c) {
                if (!b)
                    throw Error("Cannot create a node without a location.");
                this.type_ = a;
                this.isConnection_ = A.ASTNode.isConnectionType_(a);
                this.location_ = b;
                this.wsCoordinate_ = null;
                this.processParams_(c || null)
            }
        };
        A.ASTNode.types = {
            FIELD: "field",
            BLOCK: "block",
            INPUT: "input",
            OUTPUT: "output",
            NEXT: "next",
            PREVIOUS: "previous",
            STACK: "stack",
            WORKSPACE: "workspace"
        };
        A.ASTNode.NAVIGATE_ALL_FIELDS = !1;
        A.ASTNode.DEFAULT_OFFSET_Y = -20;
        A.ASTNode.isConnectionType_ = function(a) {
            switch (a) {
            case A.ASTNode.types.PREVIOUS:
            case A.ASTNode.types.NEXT:
            case A.ASTNode.types.INPUT:
            case A.ASTNode.types.OUTPUT:
                return !0
            }
            return !1
        }
        ;
        A.ASTNode.createFieldNode = function(a) {
            return a ? new A.ASTNode(A.ASTNode.types.FIELD,a) : null
        }
        ;
        A.ASTNode.createConnectionNode = function(a) {
            if (!a)
                return null;
            var b = a.type;
            return b === e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE || b === e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT && a.getParentInput() ? A.ASTNode.createInputNode(a.getParentInput()) : b === e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT ? new A.ASTNode(A.ASTNode.types.NEXT,a) : b === e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE ? new A.ASTNode(A.ASTNode.types.OUTPUT,a) : b === e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT ? new A.ASTNode(A.ASTNode.types.PREVIOUS,a) : null
        }
        ;
        A.ASTNode.createInputNode = function(a) {
            return a && a.connection ? new A.ASTNode(A.ASTNode.types.INPUT,a.connection) : null
        }
        ;
        A.ASTNode.createBlockNode = function(a) {
            return a ? new A.ASTNode(A.ASTNode.types.BLOCK,a) : null
        }
        ;
        A.ASTNode.createStackNode = function(a) {
            return a ? new A.ASTNode(A.ASTNode.types.STACK,a) : null
        }
        ;
        A.ASTNode.createWorkspaceNode = function(a, b) {
            return b && a ? new A.ASTNode(A.ASTNode.types.WORKSPACE,a,{
                wsCoordinate: b
            }) : null
        }
        ;
        var Ed = function(a) {
            var b = a.outputConnection;
            if (!b || a.previousConnection && a.previousConnection.isConnected())
                b = a.previousConnection;
            return b
        };
        A.ASTNode.createTopNode = function(a) {
            var b = Ed(a);
            return b ? A.ASTNode.createConnectionNode(b) : A.ASTNode.createBlockNode(a)
        }
        ;
        A.ASTNode.prototype.processParams_ = function(a) {
            a && a.wsCoordinate && (this.wsCoordinate_ = a.wsCoordinate)
        }
        ;
        A.ASTNode.prototype.getLocation = function() {
            return this.location_
        }
        ;
        A.ASTNode.prototype.getType = function() {
            return this.type_
        }
        ;
        A.ASTNode.prototype.getWsCoordinate = function() {
            return this.wsCoordinate_
        }
        ;
        A.ASTNode.prototype.isConnection = function() {
            return this.isConnection_
        }
        ;
        A.ASTNode.prototype.findNextForInput_ = function() {
            var a = this.location_.getParentInput()
              , b = a.getSourceBlock();
            for (a = b.inputList.indexOf(a) + 1; a < b.inputList.length; a++) {
                for (var c = b.inputList[a], d = c.fieldRow, f = 0; f < d.length; f++) {
                    var g = d[f];
                    if (g.isClickable() || A.ASTNode.NAVIGATE_ALL_FIELDS)
                        return A.ASTNode.createFieldNode(g)
                }
                if (c.connection)
                    return A.ASTNode.createInputNode(c)
            }
            return null
        }
        ;
        A.ASTNode.prototype.findNextForField_ = function() {
            var a = this.location_
              , b = a.getParentInput()
              , c = a.getSourceBlock()
              , d = c.inputList.indexOf(b);
            for (a = b.fieldRow.indexOf(a) + 1; d < c.inputList.length; d++) {
                b = c.inputList[d];
                for (var f = b.fieldRow; a < f.length; ) {
                    if (f[a].isClickable() || A.ASTNode.NAVIGATE_ALL_FIELDS)
                        return A.ASTNode.createFieldNode(f[a]);
                    a++
                }
                a = 0;
                if (b.connection)
                    return A.ASTNode.createInputNode(b)
            }
            return null
        }
        ;
        A.ASTNode.prototype.findPrevForInput_ = function() {
            for (var a = this.location_.getParentInput(), b = a.getSourceBlock(), c = b.inputList.indexOf(a); 0 <= c; c--) {
                var d = b.inputList[c];
                if (d.connection && d !== a)
                    return A.ASTNode.createInputNode(d);
                d = d.fieldRow;
                for (var f = d.length - 1; 0 <= f; f--) {
                    var g = d[f];
                    if (g.isClickable() || A.ASTNode.NAVIGATE_ALL_FIELDS)
                        return A.ASTNode.createFieldNode(g)
                }
            }
            return null
        }
        ;
        A.ASTNode.prototype.findPrevForField_ = function() {
            var a = this.location_
              , b = a.getParentInput()
              , c = a.getSourceBlock()
              , d = c.inputList.indexOf(b);
            for (a = b.fieldRow.indexOf(a) - 1; 0 <= d; d--) {
                var f = c.inputList[d];
                if (f.connection && f !== b)
                    return A.ASTNode.createInputNode(f);
                for (f = f.fieldRow; -1 < a; ) {
                    if (f[a].isClickable() || A.ASTNode.NAVIGATE_ALL_FIELDS)
                        return A.ASTNode.createFieldNode(f[a]);
                    a--
                }
                0 <= d - 1 && (a = c.inputList[d - 1].fieldRow.length - 1)
            }
            return null
        }
        ;
        A.ASTNode.prototype.navigateBetweenStacks_ = function(a) {
            var b = this.getLocation();
            b.getSourceBlock && (b = b.getSourceBlock());
            if (!b || !b.workspace)
                return null;
            var c = b.getRootBlock();
            b = c.workspace.getTopBlocks(!0);
            for (var d = 0; d < b.length; d++)
                if (c.id === b[d].id)
                    return a = d + (a ? 1 : -1),
                    -1 === a || a === b.length ? null : A.ASTNode.createStackNode(b[a]);
            throw Error("Couldn't find " + (a ? "next" : "previous") + " stack?!");
        }
        ;
        A.ASTNode.prototype.findTopASTNodeForBlock_ = function(a) {
            var b = Ed(a);
            return b ? A.ASTNode.createConnectionNode(b) : A.ASTNode.createBlockNode(a)
        }
        ;
        A.ASTNode.prototype.getOutAstNodeForBlock_ = function(a) {
            if (!a)
                return null;
            a = a.getTopStackBlock();
            var b = Ed(a);
            return b && b.targetConnection && b.targetConnection.getParentInput() ? A.ASTNode.createInputNode(b.targetConnection.getParentInput()) : A.ASTNode.createStackNode(a)
        }
        ;
        A.ASTNode.prototype.findFirstFieldOrInput_ = function(a) {
            a = a.inputList;
            for (var b = 0; b < a.length; b++) {
                for (var c = a[b], d = c.fieldRow, f = 0; f < d.length; f++) {
                    var g = d[f];
                    if (g.isClickable() || A.ASTNode.NAVIGATE_ALL_FIELDS)
                        return A.ASTNode.createFieldNode(g)
                }
                if (c.connection)
                    return A.ASTNode.createInputNode(c)
            }
            return null
        }
        ;
        A.ASTNode.prototype.getSourceBlock = function() {
            return this.getType() === A.ASTNode.types.BLOCK ? this.getLocation() : this.getType() === A.ASTNode.types.STACK ? this.getLocation() : this.getType() === A.ASTNode.types.WORKSPACE ? null : this.getLocation().getSourceBlock()
        }
        ;
        A.ASTNode.prototype.next = function() {
            switch (this.type_) {
            case A.ASTNode.types.STACK:
                return this.navigateBetweenStacks_(!0);
            case A.ASTNode.types.OUTPUT:
                return A.ASTNode.createBlockNode(this.location_.getSourceBlock());
            case A.ASTNode.types.FIELD:
                return this.findNextForField_();
            case A.ASTNode.types.INPUT:
                return this.findNextForInput_();
            case A.ASTNode.types.BLOCK:
                return A.ASTNode.createConnectionNode(this.location_.nextConnection);
            case A.ASTNode.types.PREVIOUS:
                return A.ASTNode.createBlockNode(this.location_.getSourceBlock());
            case A.ASTNode.types.NEXT:
                return A.ASTNode.createConnectionNode(this.location_.targetConnection)
            }
            return null
        }
        ;
        A.ASTNode.prototype.in = function() {
            switch (this.type_) {
            case A.ASTNode.types.WORKSPACE:
                var a = this.location_.getTopBlocks(!0);
                if (0 < a.length)
                    return A.ASTNode.createStackNode(a[0]);
                break;
            case A.ASTNode.types.STACK:
                return this.findTopASTNodeForBlock_(this.location_);
            case A.ASTNode.types.BLOCK:
                return this.findFirstFieldOrInput_(this.location_);
            case A.ASTNode.types.INPUT:
                return A.ASTNode.createConnectionNode(this.location_.targetConnection)
            }
            return null
        }
        ;
        A.ASTNode.prototype.prev = function() {
            switch (this.type_) {
            case A.ASTNode.types.STACK:
                return this.navigateBetweenStacks_(!1);
            case A.ASTNode.types.FIELD:
                return this.findPrevForField_();
            case A.ASTNode.types.INPUT:
                return this.findPrevForInput_();
            case A.ASTNode.types.BLOCK:
                var a = Ed(this.location_);
                return A.ASTNode.createConnectionNode(a);
            case A.ASTNode.types.PREVIOUS:
                if ((a = this.location_.targetConnection) && !a.getParentInput())
                    return A.ASTNode.createConnectionNode(a);
                break;
            case A.ASTNode.types.NEXT:
                return A.ASTNode.createBlockNode(this.location_.getSourceBlock())
            }
            return null
        }
        ;
        A.ASTNode.prototype.out = function() {
            switch (this.type_) {
            case A.ASTNode.types.STACK:
                var a = this.location_
                  , b = a.getRelativeToSurfaceXY();
                b = new J(b.x,b.y + A.ASTNode.DEFAULT_OFFSET_Y);
                return A.ASTNode.createWorkspaceNode(a.workspace, b);
            case A.ASTNode.types.OUTPUT:
                return a = this.location_,
                (b = a.targetConnection) ? A.ASTNode.createConnectionNode(b) : A.ASTNode.createStackNode(a.getSourceBlock());
            case A.ASTNode.types.FIELD:
                return A.ASTNode.createBlockNode(this.location_.getSourceBlock());
            case A.ASTNode.types.INPUT:
                return A.ASTNode.createBlockNode(this.location_.getSourceBlock());
            case A.ASTNode.types.BLOCK:
                return this.getOutAstNodeForBlock_(this.location_);
            case A.ASTNode.types.PREVIOUS:
                return this.getOutAstNodeForBlock_(this.location_.getSourceBlock());
            case A.ASTNode.types.NEXT:
                return this.getOutAstNodeForBlock_(this.location_.getSourceBlock())
            }
            return null
        }
        ;
        var pc = {
            MarkerMove: function(a, b, c, d) {
                var f = a ? a.workspace.id : void 0;
                d && d.getType() === A.ASTNode.types.WORKSPACE && (f = d.getLocation().id);
                pc.MarkerMove.superClass_.constructor.call(this, f);
                this.blockId = a ? a.id : null;
                this.oldNode = c;
                this.newNode = d;
                this.isCursor = b
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(pc.MarkerMove, vb.UiBase);
        pc.MarkerMove.prototype.type = k.MARKER_MOVE;
        pc.MarkerMove.prototype.toJson = function() {
            var a = pc.MarkerMove.superClass_.toJson.call(this);
            a.isCursor = this.isCursor;
            a.blockId = this.blockId;
            a.oldNode = this.oldNode;
            a.newNode = this.newNode;
            return a
        }
        ;
        pc.MarkerMove.prototype.fromJson = function(a) {
            pc.MarkerMove.superClass_.fromJson.call(this, a);
            this.isCursor = a.isCursor;
            this.blockId = a.blockId;
            this.oldNode = a.oldNode;
            this.newNode = a.newNode
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.MARKER_MOVE, pc.MarkerMove);
        var pa = function(a, b, c) {
            this.workspace_ = a;
            this.marker_ = c;
            this.parent_ = null;
            this.constants_ = b;
            this.currentMarkerSvg = null;
            a = this.isCursor() ? this.constants_.CURSOR_COLOUR : this.constants_.MARKER_COLOUR;
            this.colour_ = c.colour || a
        };
        pa.prototype.getSvgRoot = function() {
            return this.svgGroup_
        }
        ;
        pa.prototype.getMarker = function() {
            return this.marker_
        }
        ;
        pa.prototype.isCursor = function() {
            return "cursor" === this.marker_.type
        }
        ;
        pa.prototype.createDom = function() {
            var a = this.isCursor() ? "blocklyCursor" : "blocklyMarker";
            this.svgGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": a
            }, null);
            this.createDomInternal_();
            return this.svgGroup_
        }
        ;
        pa.prototype.setParent_ = function(a) {
            this.isCursor() ? (this.parent_ && this.parent_.setCursorSvg(null),
            a.setCursorSvg(this.getSvgRoot())) : (this.parent_ && this.parent_.setMarkerSvg(null),
            a.setMarkerSvg(this.getSvgRoot()));
            this.parent_ = a
        }
        ;
        pa.prototype.draw = function(a, b) {
            if (b) {
                this.constants_ = this.workspace_.getRenderer().getConstants();
                var c = this.isCursor() ? this.constants_.CURSOR_COLOUR : this.constants_.MARKER_COLOUR;
                this.colour_ = this.marker_.colour || c;
                this.applyColour_(b);
                this.showAtLocation_(b);
                this.fireMarkerEvent_(a, b);
                a = this.currentMarkerSvg.childNodes[0];
                void 0 !== a && a.beginElement && a.beginElement()
            } else
                this.hide()
        }
        ;
        pa.prototype.showAtLocation_ = function(a) {
            var b = a.getLocation().type;
            a.getType() === A.ASTNode.types.BLOCK ? this.showWithBlock_(a) : a.getType() === A.ASTNode.types.OUTPUT ? this.showWithOutput_(a) : b === e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE ? this.showWithInput_(a) : b === e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT ? this.showWithNext_(a) : a.getType() === A.ASTNode.types.PREVIOUS ? this.showWithPrevious_(a) : a.getType() === A.ASTNode.types.FIELD ? this.showWithField_(a) : a.getType() === A.ASTNode.types.WORKSPACE ? this.showWithCoordinates_(a) : a.getType() === A.ASTNode.types.STACK && this.showWithStack_(a)
        }
        ;
        pa.prototype.showWithBlockPrevOutput_ = function(a) {
            a = a.getSourceBlock();
            var b = a.width
              , c = a.height
              , d = .75 * c
              , f = this.constants_.CURSOR_BLOCK_PADDING;
            a.previousConnection ? (c = this.constants_.shapeFor(a.previousConnection),
            this.positionPrevious_(b, f, d, c)) : a.outputConnection ? (d = this.constants_.shapeFor(a.outputConnection),
            this.positionOutput_(b, c, d)) : this.positionBlock_(b, f, d);
            this.setParent_(a);
            this.showCurrent_()
        }
        ;
        pa.prototype.showWithBlock_ = function(a) {
            this.showWithBlockPrevOutput_(a)
        }
        ;
        pa.prototype.showWithPrevious_ = function(a) {
            this.showWithBlockPrevOutput_(a)
        }
        ;
        pa.prototype.showWithOutput_ = function(a) {
            this.showWithBlockPrevOutput_(a)
        }
        ;
        pa.prototype.showWithCoordinates_ = function(a) {
            var b = a.getWsCoordinate();
            a = b.x;
            b = b.y;
            this.workspace_.RTL && (a -= this.constants_.CURSOR_WS_WIDTH);
            this.positionLine_(a, b, this.constants_.CURSOR_WS_WIDTH);
            this.setParent_(this.workspace_);
            this.showCurrent_()
        }
        ;
        pa.prototype.showWithField_ = function(a) {
            a = a.getLocation();
            var b = a.getSize().width
              , c = a.getSize().height;
            this.positionRect_(0, 0, b, c);
            this.setParent_(a);
            this.showCurrent_()
        }
        ;
        pa.prototype.showWithInput_ = function(a) {
            a = a.getLocation();
            var b = a.getSourceBlock();
            this.positionInput_(a);
            this.setParent_(b);
            this.showCurrent_()
        }
        ;
        pa.prototype.showWithNext_ = function(a) {
            var b = a.getLocation();
            a = b.getSourceBlock();
            var c = 0;
            b = b.getOffsetInBlock().y;
            var d = a.getHeightWidth().width;
            this.workspace_.RTL && (c = -d);
            this.positionLine_(c, b, d);
            this.setParent_(a);
            this.showCurrent_()
        }
        ;
        pa.prototype.showWithStack_ = function(a) {
            a = a.getLocation();
            var b = a.getHeightWidth()
              , c = b.width + this.constants_.CURSOR_STACK_PADDING;
            b = b.height + this.constants_.CURSOR_STACK_PADDING;
            var d = -this.constants_.CURSOR_STACK_PADDING / 2
              , f = -this.constants_.CURSOR_STACK_PADDING / 2
              , g = d;
            this.workspace_.RTL && (g = -(c + d));
            this.positionRect_(g, f, c, b);
            this.setParent_(a);
            this.showCurrent_()
        }
        ;
        pa.prototype.showCurrent_ = function() {
            this.hide();
            this.currentMarkerSvg.style.display = ""
        }
        ;
        pa.prototype.positionBlock_ = function(a, b, c) {
            a = (0,
            t.moveBy)(-b, c) + (0,
            t.lineOnAxis)("V", -b) + (0,
            t.lineOnAxis)("H", a + 2 * b) + (0,
            t.lineOnAxis)("V", c);
            this.markerBlock_.setAttribute("d", a);
            this.workspace_.RTL && this.flipRtl_(this.markerBlock_);
            this.currentMarkerSvg = this.markerBlock_
        }
        ;
        pa.prototype.positionInput_ = function(a) {
            var b = a.getOffsetInBlock().x
              , c = a.getOffsetInBlock().y;
            a = (0,
            t.moveTo)(0, 0) + this.constants_.shapeFor(a).pathDown;
            this.markerInput_.setAttribute("d", a);
            this.markerInput_.setAttribute("transform", "translate(" + b + "," + c + ")" + (this.workspace_.RTL ? " scale(-1 1)" : ""));
            this.currentMarkerSvg = this.markerInput_
        }
        ;
        pa.prototype.positionLine_ = function(a, b, c) {
            this.markerSvgLine_.setAttribute("x", a);
            this.markerSvgLine_.setAttribute("y", b);
            this.markerSvgLine_.setAttribute("width", c);
            this.currentMarkerSvg = this.markerSvgLine_
        }
        ;
        pa.prototype.positionOutput_ = function(a, b, c) {
            a = (0,
            t.moveBy)(a, 0) + (0,
            t.lineOnAxis)("h", -(a - c.width)) + (0,
            t.lineOnAxis)("v", this.constants_.TAB_OFFSET_FROM_TOP) + c.pathDown + (0,
            t.lineOnAxis)("V", b) + (0,
            t.lineOnAxis)("H", a);
            this.markerBlock_.setAttribute("d", a);
            this.workspace_.RTL && this.flipRtl_(this.markerBlock_);
            this.currentMarkerSvg = this.markerBlock_
        }
        ;
        pa.prototype.positionPrevious_ = function(a, b, c, d) {
            a = (0,
            t.moveBy)(-b, c) + (0,
            t.lineOnAxis)("V", -b) + (0,
            t.lineOnAxis)("H", this.constants_.NOTCH_OFFSET_LEFT) + d.pathLeft + (0,
            t.lineOnAxis)("H", a + 2 * b) + (0,
            t.lineOnAxis)("V", c);
            this.markerBlock_.setAttribute("d", a);
            this.workspace_.RTL && this.flipRtl_(this.markerBlock_);
            this.currentMarkerSvg = this.markerBlock_
        }
        ;
        pa.prototype.positionRect_ = function(a, b, c, d) {
            this.markerSvgRect_.setAttribute("x", a);
            this.markerSvgRect_.setAttribute("y", b);
            this.markerSvgRect_.setAttribute("width", c);
            this.markerSvgRect_.setAttribute("height", d);
            this.currentMarkerSvg = this.markerSvgRect_
        }
        ;
        pa.prototype.flipRtl_ = function(a) {
            a.setAttribute("transform", "scale(-1 1)")
        }
        ;
        pa.prototype.hide = function() {
            this.markerSvgLine_.style.display = "none";
            this.markerSvgRect_.style.display = "none";
            this.markerInput_.style.display = "none";
            this.markerBlock_.style.display = "none"
        }
        ;
        pa.prototype.fireMarkerEvent_ = function(a, b) {
            var c = b.getSourceBlock();
            a = new ((0,
            k.get)(k.MARKER_MOVE))(c,this.isCursor(),a,b);
            (0,
            k.fire)(a)
        }
        ;
        pa.prototype.getBlinkProperties_ = function() {
            return {
                attributeType: "XML",
                attributeName: "fill",
                dur: "1s",
                values: this.colour_ + ";transparent;transparent;",
                repeatCount: "indefinite"
            }
        }
        ;
        pa.prototype.createDomInternal_ = function() {
            this.markerSvg_ = (0,
            n.createSvgElement)(u.G, {
                width: this.constants_.CURSOR_WS_WIDTH,
                height: this.constants_.WS_CURSOR_HEIGHT
            }, this.svgGroup_);
            this.markerSvgLine_ = (0,
            n.createSvgElement)(u.RECT, {
                width: this.constants_.CURSOR_WS_WIDTH,
                height: this.constants_.WS_CURSOR_HEIGHT,
                style: "display: none"
            }, this.markerSvg_);
            this.markerSvgRect_ = (0,
            n.createSvgElement)(u.RECT, {
                "class": "blocklyVerticalMarker",
                rx: 10,
                ry: 10,
                style: "display: none"
            }, this.markerSvg_);
            this.markerInput_ = (0,
            n.createSvgElement)(u.PATH, {
                transform: "",
                style: "display: none"
            }, this.markerSvg_);
            this.markerBlock_ = (0,
            n.createSvgElement)(u.PATH, {
                transform: "",
                style: "display: none",
                fill: "none",
                "stroke-width": this.constants_.CURSOR_STROKE_WIDTH
            }, this.markerSvg_);
            if (this.isCursor()) {
                var a = this.getBlinkProperties_();
                (0,
                n.createSvgElement)(u.ANIMATE, a, this.markerSvgLine_);
                (0,
                n.createSvgElement)(u.ANIMATE, a, this.markerInput_);
                a.attributeName = "stroke";
                (0,
                n.createSvgElement)(u.ANIMATE, a, this.markerBlock_)
            }
            return this.markerSvg_
        }
        ;
        pa.prototype.applyColour_ = function(a) {
            this.markerSvgLine_.setAttribute("fill", this.colour_);
            this.markerSvgRect_.setAttribute("stroke", this.colour_);
            this.markerInput_.setAttribute("fill", this.colour_);
            this.markerBlock_.setAttribute("stroke", this.colour_);
            this.isCursor() && (a = this.colour_ + ";transparent;transparent;",
            this.markerSvgLine_.firstChild.setAttribute("values", a),
            this.markerInput_.firstChild.setAttribute("values", a),
            this.markerBlock_.firstChild.setAttribute("values", a))
        }
        ;
        pa.prototype.dispose = function() {
            this.svgGroup_ && (0,
            n.removeNode)(this.svgGroup_)
        }
        ;
        var Fd = {
            NextConnection: function(a, b) {
                Fd.NextConnection.superClass_.constructor.call(this, a, b);
                this.type |= p.NEXT_CONNECTION;
                this.height = this.shape.height;
                this.width = this.shape.width
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Fd.NextConnection, Gc.Connection);
        var Gd = {
            OutputConnection: function(a, b) {
                Gd.OutputConnection.superClass_.constructor.call(this, a, b);
                this.type |= p.OUTPUT_CONNECTION;
                this.height = this.isDynamicShape ? 0 : this.shape.height;
                this.startX = this.width = this.isDynamicShape ? 0 : this.shape.width;
                this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP;
                this.connectionOffsetX = 0
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Gd.OutputConnection, Gc.Connection);
        var Va = function(a, b, c) {
            this.constants = c;
            this.svgRoot = a;
            this.svgPath = (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyPath"
            }, this.svgRoot);
            this.style = b;
            this.markerSvg = this.cursorSvg = null
        };
        Va.prototype.setPath = function(a) {
            this.svgPath.setAttribute("d", a)
        }
        ;
        Va.prototype.flipRTL = function() {
            this.svgPath.setAttribute("transform", "scale(-1 1)")
        }
        ;
        Va.prototype.setCursorSvg = function(a) {
            a ? (this.svgRoot.appendChild(a),
            this.cursorSvg = a) : this.cursorSvg = null
        }
        ;
        Va.prototype.setMarkerSvg = function(a) {
            a ? (this.cursorSvg ? this.svgRoot.insertBefore(a, this.cursorSvg) : this.svgRoot.appendChild(a),
            this.markerSvg = a) : this.markerSvg = null
        }
        ;
        Va.prototype.applyColour = function(a) {
            this.svgPath.setAttribute("stroke", this.style.colourTertiary);
            this.svgPath.setAttribute("fill", this.style.colourPrimary);
            this.updateShadow_(a.isShadow());
            this.updateDisabled_(!a.isEnabled() || a.getInheritedDisabled())
        }
        ;
        Va.prototype.setStyle = function(a) {
            this.style = a
        }
        ;
        Va.prototype.setClass_ = function(a, b) {
            b ? (0,
            n.addClass)(this.svgRoot, a) : (0,
            n.removeClass)(this.svgRoot, a)
        }
        ;
        Va.prototype.updateHighlighted = function(a) {
            a ? this.svgPath.setAttribute("filter", "url(#" + this.constants.embossFilterId + ")") : this.svgPath.setAttribute("filter", "none")
        }
        ;
        Va.prototype.updateShadow_ = function(a) {
            a && (this.svgPath.setAttribute("stroke", "none"),
            this.svgPath.setAttribute("fill", this.style.colourSecondary))
        }
        ;
        Va.prototype.updateDisabled_ = function(a) {
            this.setClass_("blocklyDisabled", a);
            a && this.svgPath.setAttribute("fill", "url(#" + this.constants.disabledPatternId + ")")
        }
        ;
        Va.prototype.updateSelected = function(a) {
            this.setClass_("blocklySelected", a)
        }
        ;
        Va.prototype.updateDraggingDelete = function(a) {
            this.setClass_("blocklyDraggingDelete", a)
        }
        ;
        Va.prototype.updateInsertionMarker = function(a) {
            this.setClass_("blocklyInsertionMarker", a)
        }
        ;
        Va.prototype.updateMovable = function(a) {
            this.setClass_("blocklyDraggable", a)
        }
        ;
        Va.prototype.updateReplacementFade = function(a) {
            this.setClass_("blocklyReplaceable", a)
        }
        ;
        Va.prototype.updateShapeForInputHighlight = function(a, b) {}
        ;
        var Hd = {
            PreviousConnection: function(a, b) {
                Hd.PreviousConnection.superClass_.constructor.call(this, a, b);
                this.type |= p.PREVIOUS_CONNECTION;
                this.height = this.shape.height;
                this.width = this.shape.width
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Hd.PreviousConnection, Gc.Connection);
        e.module$exports$Blockly$Input = {
            Align: {
                LEFT: -1,
                CENTRE: 0,
                RIGHT: 1
            },
            Input: function(a, b, c, d) {
                if (a !== e.module$exports$Blockly$inputTypes.inputTypes.DUMMY && !b)
                    throw Error("Value inputs and statement inputs must have non-empty name.");
                this.type = a;
                this.name = b;
                this.sourceBlock_ = c;
                this.connection = d;
                this.fieldRow = []
            }
        };
        e.module$exports$Blockly$Input.Input.prototype.align = e.module$exports$Blockly$Input.Align.LEFT;
        e.module$exports$Blockly$Input.Input.prototype.visible_ = !0;
        e.module$exports$Blockly$Input.Input.prototype.getSourceBlock = function() {
            return this.sourceBlock_
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.appendField = function(a, b) {
            this.insertFieldAt(this.fieldRow.length, a, b);
            return this
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.insertFieldAt = function(a, b, c) {
            if (0 > a || a > this.fieldRow.length)
                throw Error("index " + a + " out of bounds.");
            if (!(b || "" === b && c))
                return a;
            "string" === typeof b && (b = (0,
            tb.fromJson)({
                type: "field_label",
                text: b
            }));
            b.setSourceBlock(this.sourceBlock_);
            this.sourceBlock_.rendered && (b.init(),
            b.applyColour());
            b.name = c;
            b.setVisible(this.isVisible());
            b.prefixField && (a = this.insertFieldAt(a, b.prefixField));
            this.fieldRow.splice(a, 0, b);
            a++;
            b.suffixField && (a = this.insertFieldAt(a, b.suffixField));
            this.sourceBlock_.rendered && (this.sourceBlock_ = this.sourceBlock_,
            this.sourceBlock_.render(),
            this.sourceBlock_.bumpNeighbours());
            return a
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.removeField = function(a, b) {
            for (var c = 0, d; d = this.fieldRow[c]; c++)
                if (d.name === a)
                    return d.dispose(),
                    this.fieldRow.splice(c, 1),
                    this.sourceBlock_.rendered && (this.sourceBlock_ = this.sourceBlock_,
                    this.sourceBlock_.render(),
                    this.sourceBlock_.bumpNeighbours()),
                    !0;
            if (b)
                return !1;
            throw Error('Field "' + a + '" not found.');
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.isVisible = function() {
            return this.visible_
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.setVisible = function(a) {
            var b = [];
            if (this.visible_ === a)
                return b;
            this.visible_ = a;
            for (var c = 0, d; d = this.fieldRow[c]; c++)
                d.setVisible(a);
            this.connection && (this.connection = this.connection,
            a ? b = this.connection.startTrackingAll() : this.connection.stopTrackingAll(),
            c = this.connection.targetBlock()) && (c.getSvgRoot().style.display = a ? "block" : "none");
            return b
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.markDirty = function() {
            for (var a = 0, b; b = this.fieldRow[a]; a++)
                b.markDirty()
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.setCheck = function(a) {
            if (!this.connection)
                throw Error("This input does not have a connection.");
            this.connection.setCheck(a);
            return this
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.setAlign = function(a) {
            this.align = a;
            this.sourceBlock_.rendered && (this.sourceBlock_ = this.sourceBlock_,
            this.sourceBlock_.render());
            return this
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.setShadowDom = function(a) {
            if (!this.connection)
                throw Error("This input does not have a connection.");
            this.connection.setShadowDom(a);
            return this
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.getShadowDom = function() {
            if (!this.connection)
                throw Error("This input does not have a connection.");
            return this.connection.getShadowDom()
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.init = function() {
            if (this.sourceBlock_.workspace.rendered)
                for (var a = 0; a < this.fieldRow.length; a++)
                    this.fieldRow[a].init()
        }
        ;
        e.module$exports$Blockly$Input.Input.prototype.dispose = function() {
            for (var a = 0, b; b = this.fieldRow[a]; a++)
                b.dispose();
            this.connection && this.connection.dispose();
            this.sourceBlock_ = null
        }
        ;
        var Jc = {
            RoundCorner: function(a, b) {
                Jc.RoundCorner.superClass_.constructor.call(this, a);
                this.type = (b && "left" !== b ? p.RIGHT_ROUND_CORNER : p.LEFT_ROUND_CORNER) | p.CORNER;
                this.width = this.constants_.CORNER_RADIUS;
                this.height = this.constants_.CORNER_RADIUS / 2
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Jc.RoundCorner, Zb);
        var kd = {
            SpacerRow: function(a, b, c) {
                kd.SpacerRow.superClass_.constructor.call(this, a);
                this.type = this.type | p.SPACER | p.BETWEEN_ROW_SPACER;
                this.width = c;
                this.height = b;
                this.followsStatement = !1;
                this.widthWithConnectedBlocks = 0;
                this.elements = [new pb.InRowSpacer(this.constants_,c)]
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(kd.SpacerRow, Ob);
        kd.SpacerRow.prototype.measure = function() {}
        ;
        var Kc = {
            SquareCorner: function(a, b) {
                Kc.SquareCorner.superClass_.constructor.call(this, a);
                this.type = (b && "left" !== b ? p.RIGHT_SQUARE_CORNER : p.LEFT_SQUARE_CORNER) | p.CORNER;
                this.width = this.height = this.constants_.NO_PADDING
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Kc.SquareCorner, Zb);
        var Xc = {
            StatementInput: function(a, b) {
                Xc.StatementInput.superClass_.constructor.call(this, a, b);
                this.type |= p.STATEMENT_INPUT;
                this.height = this.connectedBlock ? this.connectedBlockHeight + this.constants_.STATEMENT_BOTTOM_SPACER : this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT;
                this.width = this.constants_.STATEMENT_INPUT_NOTCH_OFFSET + this.shape.width
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Xc.StatementInput, Wc.InputConnection);
        var dc = {
            TopRow: function(a) {
                dc.TopRow.superClass_.constructor.call(this, a);
                this.type |= p.TOP_ROW;
                this.ascenderHeight = this.capline = 0;
                this.hasPreviousConnection = !1;
                this.connection = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(dc.TopRow, Ob);
        dc.TopRow.prototype.hasLeftSquareCorner = function(a) {
            var b = (a.hat ? "cap" === a.hat : this.constants_.ADD_START_HATS) && !a.outputConnection && !a.previousConnection
              , c = a.getPreviousBlock();
            return !!a.outputConnection || b || (c ? c.getNextBlock() === a : !1)
        }
        ;
        dc.TopRow.prototype.hasRightSquareCorner = function(a) {
            return !0
        }
        ;
        dc.TopRow.prototype.measure = function() {
            for (var a = 0, b = 0, c = 0, d = 0; d < this.elements.length; d++) {
                var f = this.elements[d];
                b += f.width;
                p.isSpacer(f) || (p.isHat(f) ? c = Math.max(c, f.ascenderHeight) : a = Math.max(a, f.height))
            }
            this.width = Math.max(this.minWidth, b);
            this.height = Math.max(this.minHeight, a) + c;
            this.capline = this.ascenderHeight = c;
            this.widthWithConnectedBlocks = this.width
        }
        ;
        dc.TopRow.prototype.startsWithElemSpacer = function() {
            return !1
        }
        ;
        dc.TopRow.prototype.endsWithElemSpacer = function() {
            return !1
        }
        ;
        var wa = function(a, b) {
            this.block_ = b;
            this.renderer_ = a;
            this.constants_ = this.renderer_.getConstants();
            this.outputConnection = b.outputConnection ? new Gd.OutputConnection(this.constants_,b.outputConnection) : null;
            this.isInline = b.getInputsInline() && !b.isCollapsed();
            this.isCollapsed = b.isCollapsed();
            this.isInsertionMarker = b.isInsertionMarker();
            this.RTL = b.RTL;
            this.statementEdge = this.width = this.widthWithChildren = this.height = 0;
            this.rows = [];
            this.inputRows = [];
            this.hiddenIcons = [];
            this.topRow = new dc.TopRow(this.constants_);
            this.bottomRow = new Yb.BottomRow(this.constants_);
            this.startY = this.startX = 0
        };
        wa.prototype.getRenderer = function() {
            return this.renderer_
        }
        ;
        wa.prototype.measure = function() {
            this.createRows_();
            this.addElemSpacing_();
            this.addRowSpacing_();
            this.computeBounds_();
            this.alignRowElements_();
            this.finalize_()
        }
        ;
        wa.prototype.createRows_ = function() {
            this.populateTopRow_();
            this.rows.push(this.topRow);
            var a = new Ic.InputRow(this.constants_);
            this.inputRows.push(a);
            for (var b = this.block_.getIcons(), c = 0, d; d = b[c]; c++) {
                var f = new Cd.Icon(this.constants_,d);
                this.isCollapsed && d.collapseHidden ? this.hiddenIcons.push(f) : a.elements.push(f)
            }
            d = null;
            for (b = 0; c = this.block_.inputList[b]; b++)
                if (c.isVisible()) {
                    this.shouldStartNewRow_(c, d) && (this.rows.push(a),
                    a = new Ic.InputRow(this.constants_),
                    this.inputRows.push(a));
                    for (d = 0; f = c.fieldRow[d]; d++)
                        a.elements.push(new Ad.Field(this.constants_,f,c));
                    this.addInput_(c, a);
                    d = c
                }
            this.isCollapsed && (a.hasJaggedEdge = !0,
            a.elements.push(new Dd.JaggedEdge(this.constants_)));
            (a.elements.length || a.hasDummyInput) && this.rows.push(a);
            this.populateBottomRow_();
            this.rows.push(this.bottomRow)
        }
        ;
        wa.prototype.populateTopRow_ = function() {
            var a = !!this.block_.previousConnection
              , b = (this.block_.hat ? "cap" === this.block_.hat : this.constants_.ADD_START_HATS) && !this.outputConnection && !a
              , c = this.topRow.hasLeftSquareCorner(this.block_) ? Kc.SquareCorner : Jc.RoundCorner;
            this.topRow.elements.push(new c(this.constants_));
            b ? (a = new Bd.Hat(this.constants_),
            this.topRow.elements.push(a),
            this.topRow.capline = a.ascenderHeight) : a && (this.topRow.hasPreviousConnection = !0,
            this.topRow.connection = new Hd.PreviousConnection(this.constants_,this.block_.previousConnection),
            this.topRow.elements.push(this.topRow.connection));
            this.block_.inputList.length && this.block_.inputList[0].type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT && !this.block_.isCollapsed() ? this.topRow.minHeight = this.constants_.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT : this.topRow.minHeight = this.constants_.TOP_ROW_MIN_HEIGHT;
            c = this.topRow.hasRightSquareCorner(this.block_) ? Kc.SquareCorner : Jc.RoundCorner;
            this.topRow.elements.push(new c(this.constants_,"right"))
        }
        ;
        wa.prototype.populateBottomRow_ = function() {
            this.bottomRow.hasNextConnection = !!this.block_.nextConnection;
            this.bottomRow.minHeight = this.block_.inputList.length && this.block_.inputList[this.block_.inputList.length - 1].type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT ? this.constants_.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT : this.constants_.BOTTOM_ROW_MIN_HEIGHT;
            this.bottomRow.hasLeftSquareCorner(this.block_) ? this.bottomRow.elements.push(new Kc.SquareCorner(this.constants_)) : this.bottomRow.elements.push(new Jc.RoundCorner(this.constants_));
            this.bottomRow.hasNextConnection && (this.bottomRow.connection = new Fd.NextConnection(this.constants_,this.block_.nextConnection),
            this.bottomRow.elements.push(this.bottomRow.connection));
            this.bottomRow.hasRightSquareCorner(this.block_) ? this.bottomRow.elements.push(new Kc.SquareCorner(this.constants_,"right")) : this.bottomRow.elements.push(new Jc.RoundCorner(this.constants_,"right"))
        }
        ;
        wa.prototype.addInput_ = function(a, b) {
            this.isInline && a.type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE ? (b.elements.push(new jd.InlineInput(this.constants_,a)),
            b.hasInlineInput = !0) : a.type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT ? (b.elements.push(new Xc.StatementInput(this.constants_,a)),
            b.hasStatement = !0) : a.type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE ? (b.elements.push(new id.ExternalValueInput(this.constants_,a)),
            b.hasExternalInput = !0) : a.type === e.module$exports$Blockly$inputTypes.inputTypes.DUMMY && (b.minHeight = Math.max(b.minHeight, a.getSourceBlock() && a.getSourceBlock().isShadow() ? this.constants_.DUMMY_INPUT_SHADOW_MIN_HEIGHT : this.constants_.DUMMY_INPUT_MIN_HEIGHT),
            b.hasDummyInput = !0);
            null === b.align && (b.align = a.align)
        }
        ;
        wa.prototype.shouldStartNewRow_ = function(a, b) {
            return b ? a.type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT || b.type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT ? !0 : a.type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE || a.type === e.module$exports$Blockly$inputTypes.inputTypes.DUMMY ? !this.isInline : !1 : !1
        }
        ;
        wa.prototype.addElemSpacing_ = function() {
            for (var a = 0, b; b = this.rows[a]; a++) {
                var c = b.elements;
                b.elements = [];
                b.startsWithElemSpacer() && b.elements.push(new pb.InRowSpacer(this.constants_,this.getInRowSpacing_(null, c[0])));
                if (c.length) {
                    for (var d = 0; d < c.length - 1; d++) {
                        b.elements.push(c[d]);
                        var f = this.getInRowSpacing_(c[d], c[d + 1]);
                        b.elements.push(new pb.InRowSpacer(this.constants_,f))
                    }
                    b.elements.push(c[c.length - 1]);
                    b.endsWithElemSpacer() && b.elements.push(new pb.InRowSpacer(this.constants_,this.getInRowSpacing_(c[c.length - 1], null)))
                }
            }
        }
        ;
        wa.prototype.getInRowSpacing_ = function(a, b) {
            if (!a && b && p.isStatementInput(b))
                return this.constants_.STATEMENT_INPUT_PADDING_LEFT;
            if (a && p.isInput(a) && !b) {
                if (p.isExternalInput(a))
                    return this.constants_.NO_PADDING;
                if (p.isInlineInput(a))
                    return this.constants_.LARGE_PADDING;
                if (p.isStatementInput(a))
                    return this.constants_.NO_PADDING
            }
            return a && p.isLeftSquareCorner(a) && b && (p.isPreviousConnection(b) || p.isNextConnection(b)) ? b.notchOffset : a && p.isLeftRoundedCorner(a) && b && (p.isPreviousConnection(b) || p.isNextConnection(b)) ? b.notchOffset - this.constants_.CORNER_RADIUS : this.constants_.MEDIUM_PADDING
        }
        ;
        wa.prototype.computeBounds_ = function() {
            for (var a = 0, b = 0, c = 0, d = 0, f; f = this.rows[d]; d++) {
                f.measure();
                b = Math.max(b, f.width);
                if (f.hasStatement) {
                    var g = f.getLastInput();
                    a = Math.max(a, f.width - g.width)
                }
                c = Math.max(c, f.widthWithConnectedBlocks)
            }
            this.statementEdge = a;
            this.width = b;
            for (a = 0; d = this.rows[a]; a++)
                d.hasStatement && (d.statementEdge = this.statementEdge);
            this.widthWithChildren = Math.max(b, c);
            this.outputConnection && (this.startX = this.outputConnection.width,
            this.width += this.outputConnection.width,
            this.widthWithChildren += this.outputConnection.width)
        }
        ;
        wa.prototype.alignRowElements_ = function() {
            for (var a = 0, b; b = this.rows[a]; a++)
                if (b.hasStatement)
                    this.alignStatementRow_(b);
                else {
                    var c = b.width;
                    c = this.getDesiredRowWidth_(b) - c;
                    0 < c && this.addAlignmentPadding_(b, c);
                    p.isTopOrBottomRow(b) && (b.widthWithConnectedBlocks = b.width)
                }
        }
        ;
        wa.prototype.getDesiredRowWidth_ = function(a) {
            return this.width - this.startX
        }
        ;
        wa.prototype.addAlignmentPadding_ = function(a, b) {
            var c = a.getFirstSpacer()
              , d = a.getLastSpacer();
            if (a.hasExternalInput || a.hasStatement)
                a.widthWithConnectedBlocks += b;
            a.align === e.module$exports$Blockly$Input.Align.LEFT ? d.width += b : a.align === e.module$exports$Blockly$Input.Align.CENTRE ? (c.width += b / 2,
            d.width += b / 2) : a.align === e.module$exports$Blockly$Input.Align.RIGHT ? c.width += b : d.width += b;
            a.width += b
        }
        ;
        wa.prototype.alignStatementRow_ = function(a) {
            var b = a.getLastInput()
              , c = a.width - b.width
              , d = this.statementEdge;
            c = d - c;
            0 < c && this.addAlignmentPadding_(a, c);
            c = a.width;
            d = this.getDesiredRowWidth_(a);
            b.width += d - c;
            b.height = Math.max(b.height, a.height);
            a.width += d - c;
            a.widthWithConnectedBlocks = Math.max(a.width, this.statementEdge + a.connectedBlockWidths)
        }
        ;
        wa.prototype.addRowSpacing_ = function() {
            var a = this.rows;
            this.rows = [];
            for (var b = 0; b < a.length; b++)
                this.rows.push(a[b]),
                b !== a.length - 1 && this.rows.push(this.makeSpacerRow_(a[b], a[b + 1]))
        }
        ;
        wa.prototype.makeSpacerRow_ = function(a, b) {
            var c = this.getSpacerRowHeight_(a, b)
              , d = this.getSpacerRowWidth_(a, b);
            c = new kd.SpacerRow(this.constants_,c,d);
            a.hasStatement && (c.followsStatement = !0);
            b.hasStatement && (c.precedesStatement = !0);
            return c
        }
        ;
        wa.prototype.getSpacerRowWidth_ = function(a, b) {
            return this.width - this.startX
        }
        ;
        wa.prototype.getSpacerRowHeight_ = function(a, b) {
            return this.constants_.MEDIUM_PADDING
        }
        ;
        wa.prototype.getElemCenterline_ = function(a, b) {
            return p.isSpacer(b) ? a.yPos + b.height / 2 : p.isBottomRow(a) ? (a = a.yPos + a.height - a.descenderHeight,
            p.isNextConnection(b) ? a + b.height / 2 : a - b.height / 2) : p.isTopRow(a) ? p.isHat(b) ? a.capline - b.height / 2 : a.capline + b.height / 2 : a.yPos + a.height / 2
        }
        ;
        wa.prototype.recordElemPositions_ = function(a) {
            for (var b = a.xPos, c = 0, d; d = a.elements[c]; c++)
                p.isSpacer(d) && (d.height = a.height),
                d.xPos = b,
                d.centerline = this.getElemCenterline_(a, d),
                b += d.width
        }
        ;
        wa.prototype.finalize_ = function() {
            for (var a = 0, b = 0, c = 0, d; d = this.rows[c]; c++)
                d.yPos = b,
                d.xPos = this.startX,
                b += d.height,
                a = Math.max(a, d.widthWithConnectedBlocks),
                this.recordElemPositions_(d);
            this.outputConnection && this.block_.nextConnection && this.block_.nextConnection.isConnected() && (a = Math.max(a, this.block_.nextConnection.targetBlock().getHeightWidth().width));
            this.widthWithChildren = a + this.startX;
            this.height = b;
            this.startY = this.topRow.capline;
            this.bottomRow.baseline = b - this.bottomRow.descenderHeight
        }
        ;
        var Ra = function(a) {
            this.name = a;
            this.overrides = this.constants_ = null
        };
        Ra.prototype.getClassName = function() {
            return this.name + "-renderer"
        }
        ;
        Ra.prototype.init = function(a, b) {
            this.constants_ = this.makeConstants_();
            b && (this.overrides = b,
            (0,
            e.module$exports$Blockly$utils$object.mixin)(this.constants_, b));
            this.constants_.setTheme(a);
            this.constants_.init()
        }
        ;
        Ra.prototype.createDom = function(a, b) {
            this.constants_.createDom(a, this.name + "-" + b.name, "." + this.getClassName() + "." + b.getClassName())
        }
        ;
        Ra.prototype.refreshDom = function(a, b) {
            var c = this.getConstants();
            c.dispose();
            this.constants_ = this.makeConstants_();
            this.overrides && (0,
            e.module$exports$Blockly$utils$object.mixin)(this.constants_, this.overrides);
            this.constants_.randomIdentifier = c.randomIdentifier;
            this.constants_.setTheme(b);
            this.constants_.init();
            this.createDom(a, b)
        }
        ;
        Ra.prototype.dispose = function() {
            this.constants_ && this.constants_.dispose()
        }
        ;
        Ra.prototype.makeConstants_ = function() {
            return new va
        }
        ;
        Ra.prototype.makeRenderInfo_ = function(a) {
            return new wa(this,a)
        }
        ;
        Ra.prototype.makeDrawer_ = function(a, b) {
            return new Ca(a,b)
        }
        ;
        Ra.prototype.makeDebugger_ = function() {
            if (!Ia)
                throw Error("Missing require for Blockly.blockRendering.Debug");
            return new Ia(this.getConstants())
        }
        ;
        Ra.prototype.makeMarkerDrawer = function(a, b) {
            return new pa(a,this.getConstants(),b)
        }
        ;
        Ra.prototype.makePathObject = function(a, b) {
            return new Va(a,b,this.constants_)
        }
        ;
        Ra.prototype.getConstants = function() {
            return this.constants_
        }
        ;
        Ra.prototype.shouldHighlightConnection = function(a) {
            return !0
        }
        ;
        Ra.prototype.orphanCanConnectAtEnd = function(a, b, c) {
            return !!K.getConnectionForOrphanedConnection(a, c === e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE ? b.outputConnection : b.previousConnection)
        }
        ;
        Ra.prototype.getConnectionPreviewMethod = function(a, b, c) {
            return b.type === e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE || b.type === e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT ? !a.isConnected() || this.orphanCanConnectAtEnd(c, a.targetBlock(), b.type) ? la.PREVIEW_TYPE.INSERTION_MARKER : la.PREVIEW_TYPE.REPLACEMENT_FADE : la.PREVIEW_TYPE.INSERTION_MARKER
        }
        ;
        Ra.prototype.render = function(a) {
            (0,
            Nb.isDebuggerEnabled)() && !a.renderingDebugger && (a.renderingDebugger = this.makeDebugger_());
            var b = this.makeRenderInfo_(a);
            b.measure();
            this.makeDrawer_(a, b).draw()
        }
        ;
        var ma = {
            isDebuggerEnabled: function() {
                (0,
                q.warn)("Blockly.blockRendering.isDebuggerEnabled()", "September 2021", "September 2022", "Blockly.blockRendering.debug.isDebuggerEnabled()");
                return (0,
                Nb.isDebuggerEnabled)()
            },
            register: function(a, b) {
                (0,
                w.register)(w.Type.RENDERER, a, b)
            },
            unregister: function(a) {
                (0,
                w.unregister)(w.Type.RENDERER, a)
            },
            startDebugger: function() {
                (0,
                q.warn)("Blockly.blockRendering.startDebugger()", "September 2021", "September 2022", "Blockly.blockRendering.debug.startDebugger()");
                (0,
                Nb.startDebugger)()
            },
            stopDebugger: function() {
                (0,
                q.warn)("Blockly.blockRendering.stopDebugger()", "September 2021", "September 2022", "Blockly.blockRendering.debug.stopDebugger()");
                (0,
                Nb.stopDebugger)()
            },
            init: function(a, b, c) {
                a = new ((0,
                w.getClass)(w.Type.RENDERER, a))(a);
                a.init(b, c);
                return a
            }
        };
        ma.BottomRow = Yb.BottomRow;
        ma.Connection = Gc.Connection;
        ma.ConstantProvider = va;
        ma.Debug = Ia;
        ma.Drawer = Ca;
        ma.ExternalValueInput = id.ExternalValueInput;
        ma.Field = Ad.Field;
        ma.Hat = Bd.Hat;
        ma.Icon = Cd.Icon;
        ma.InRowSpacer = pb.InRowSpacer;
        ma.InlineInput = jd.InlineInput;
        ma.InputConnection = Wc.InputConnection;
        ma.InputRow = Ic.InputRow;
        ma.IPathObject = function(a, b) {}
        ;
        ma.JaggedEdge = Dd.JaggedEdge;
        ma.MarkerSvg = pa;
        ma.Measurable = Zb;
        ma.NextConnection = Fd.NextConnection;
        ma.OutputConnection = Gd.OutputConnection;
        ma.PathObject = Va;
        ma.PreviousConnection = Hd.PreviousConnection;
        ma.Renderer = Ra;
        ma.RenderInfo = wa;
        ma.RoundCorner = Jc.RoundCorner;
        ma.Row = Ob;
        ma.SpacerRow = kd.SpacerRow;
        ma.SquareCorner = Kc.SquareCorner;
        ma.StatementInput = Xc.StatementInput;
        ma.TopRow = dc.TopRow;
        ma.Types = p;
        ma.debug = Nb;
        e.module$exports$Blockly$Extensions = {};
        var Yc = Object.create(null);
        e.module$exports$Blockly$Extensions.TEST_ONLY = {
            allExtensions: Yc
        };
        e.module$exports$Blockly$Extensions.register = function(a, b) {
            if ("string" !== typeof a || "" === a.trim())
                throw Error('Error: Invalid extension name "' + a + '"');
            if (Yc[a])
                throw Error('Error: Extension "' + a + '" is already registered.');
            if ("function" !== typeof b)
                throw Error('Error: Extension "' + a + '" must be a function');
            Yc[a] = b
        }
        ;
        e.module$exports$Blockly$Extensions.registerMixin = function(a, b) {
            if (!b || "object" !== typeof b)
                throw Error('Error: Mixin "' + a + '" must be a object');
            (0,
            e.module$exports$Blockly$Extensions.register)(a, function() {
                this.mixin(b)
            })
        }
        ;
        e.module$exports$Blockly$Extensions.registerMutator = function(a, b, c, d) {
            var f = 'Error when registering mutator "' + a + '": ';
            Ne(f, b);
            var g = Id(b.compose, b.decompose, f + " compose/decompose");
            if (c && "function" !== typeof c)
                throw Error(f + 'Extension "' + a + '" is not a function');
            (0,
            e.module$exports$Blockly$Extensions.register)(a, function() {
                if (g) {
                    var m = e.module$exports$Blockly$Mutator.Mutator;
                    if (!m)
                        throw Error(f + "Missing require for Blockly.Mutator");
                    this.setMutator(new m(d || []))
                }
                this.mixin(b);
                c && c.apply(this)
            })
        }
        ;
        e.module$exports$Blockly$Extensions.unregister = function(a) {
            (0,
            e.module$exports$Blockly$Extensions.isRegistered)(a) ? delete Yc[a] : console.warn('No extension mapping for name "' + a + '" found to unregister')
        }
        ;
        e.module$exports$Blockly$Extensions.isRegistered = function(a) {
            return !!Yc[a]
        }
        ;
        e.module$exports$Blockly$Extensions.apply = function(a, b, c) {
            var d = Yc[a];
            if ("function" !== typeof d)
                throw Error('Error: Extension "' + a + '" not found.');
            if (c) {
                if (de(b).length)
                    throw Error('Error: tried to apply mutation "' + a + '" to a block that already has mutator functions.  Block id: ' + b.id);
            } else
                var f = de(b);
            d.apply(b);
            if (c)
                Ne('Error after applying mutator "' + a + '": ', b);
            else {
                a: if (c = f,
                b = de(b),
                b.length !== c.length)
                    b = !1;
                else {
                    for (d = 0; d < b.length; d++)
                        if (c[d] !== b[d]) {
                            b = !1;
                            break a
                        }
                    b = !0
                }
                if (!b)
                    throw Error('Error when applying extension "' + a + '": mutation properties changed when applying a non-mutator extension.');
            }
        }
        ;
        var Id = function(a, b, c) {
            if (a && b) {
                if ("function" !== typeof a || "function" !== typeof b)
                    throw Error(c + " must be a function");
                return !0
            }
            if (!a && !b)
                return !1;
            throw Error(c + "Must have both or neither functions");
        }
          , Ne = function(a, b) {
            var c = Id(b.mutationToDom, b.domToMutation, a + " mutationToDom/domToMutation")
              , d = Id(b.saveExtraState, b.loadExtraState, a + " saveExtraState/loadExtraState");
            if (!c && !d)
                throw Error(a + "Mutations must contain either XML hooks, or JSON hooks, or both");
            Id(b.compose, b.decompose, a + " compose/decompose")
        }
          , de = function(a) {
            var b = [];
            void 0 !== a.domToMutation && b.push(a.domToMutation);
            void 0 !== a.mutationToDom && b.push(a.mutationToDom);
            void 0 !== a.saveExtraState && b.push(a.saveExtraState);
            void 0 !== a.loadExtraState && b.push(a.loadExtraState);
            void 0 !== a.compose && b.push(a.compose);
            void 0 !== a.decompose && b.push(a.decompose);
            return b
        };
        e.module$exports$Blockly$Extensions.runAfterPageLoad = function(a) {
            if ("object" !== typeof document)
                throw Error("runAfterPageLoad() requires browser document.");
            if ("complete" === document.readyState)
                a();
            else
                var b = setInterval(function() {
                    "complete" === document.readyState && (clearInterval(b),
                    a())
                }, 10)
        }
        ;
        e.module$exports$Blockly$Extensions.buildTooltipForDropdown = function(a, b) {
            var c = [];
            "object" === typeof document && (0,
            e.module$exports$Blockly$Extensions.runAfterPageLoad)(function() {
                for (var d in b)
                    (0,
                    ka.checkMessageReferences)(b[d])
            });
            return function() {
                this.type && -1 === c.indexOf(this.type) && (lf(this, a, b),
                c.push(this.type));
                this.setTooltip(function() {
                    var d = String(this.getFieldValue(a))
                      , f = b[d];
                    null === f ? -1 === c.indexOf(this.type) && (d = "No tooltip mapping for value " + d + " of field " + a,
                    null !== this.type && (d += " of block type " + this.type),
                    console.warn(d + ".")) : f = (0,
                    ka.replaceMessageReferences)(f);
                    return f
                }
                .bind(this))
            }
        }
        ;
        var lf = function(a, b, c) {
            var d = a.getField(b);
            if (!d.isOptionListDynamic()) {
                d = d.getOptions();
                for (var f = 0; f < d.length; f++) {
                    var g = d[f][1];
                    null === c[g] && console.warn("No tooltip mapping for value " + g + " of field " + b + " of block type " + a.type)
                }
            }
        };
        e.module$exports$Blockly$Extensions.buildTooltipWithFieldText = function(a, b) {
            "object" === typeof document && (0,
            e.module$exports$Blockly$Extensions.runAfterPageLoad)(function() {
                (0,
                ka.checkMessageReferences)(a)
            });
            return function() {
                this.setTooltip(function() {
                    var c = this.getField(b);
                    return (0,
                    ka.replaceMessageReferences)(a).replace("%1", c ? c.getText() : "")
                }
                .bind(this))
            }
        }
        ;
        (0,
        e.module$exports$Blockly$Extensions.register)("parent_tooltip_when_inline", function() {
            this.tooltipWhenNotConnected = this.tooltip;
            this.setTooltip(function() {
                var a = this.getParent();
                return a && a.getInputsInline() && a.tooltip || this.tooltipWhenNotConnected
            }
            .bind(this))
        });
        var ca = {
            aria: Q,
            colour: na
        };
        ca.Coordinate = J;
        ca.deprecation = q;
        ca.dom = n;
        ca.global = e.module$exports$Blockly$utils$global.globalThis;
        ca.idGenerator = bb;
        ca.KeyCodes = M;
        ca.math = Eb;
        ca.Metrics = function() {}
        ;
        ca.object = e.module$exports$Blockly$utils$object;
        ca.parsing = ka;
        ca.Rect = Ha;
        ca.Size = Pa;
        ca.string = e.module$exports$Blockly$utils$string;
        ca.style = ta;
        ca.Svg = u;
        ca.svgPaths = t;
        ca.svgMath = ja;
        ca.toolbox = X;
        ca.userAgent = V;
        ca.xml = e.module$exports$Blockly$utils$xml;
        ca.noEvent = function(a) {
            (0,
            q.warn)("Blockly.utils.noEvent", "September 2021", "September 2022");
            a.preventDefault();
            a.stopPropagation()
        }
        ;
        ca.isTargetInput = function(a) {
            (0,
            q.warn)("Blockly.utils.isTargetInput", "September 2021", "September 2022", "Blockly.browserEvents.isTargetInput");
            return (0,
            y.isTargetInput)(a)
        }
        ;
        ca.getRelativeXY = function(a) {
            (0,
            q.warn)("Blockly.utils.getRelativeXY", "December 2021", "December 2022", "Blockly.utils.svgMath.getRelativeXY");
            return (0,
            ja.getRelativeXY)(a)
        }
        ;
        ca.getInjectionDivXY_ = function(a) {
            (0,
            q.warn)("Blockly.utils.getInjectionDivXY_", "December 2021", "December 2022", "Blockly.utils.svgMath.getInjectionDivXY");
            return (0,
            ja.getInjectionDivXY)(a)
        }
        ;
        ca.isRightButton = function(a) {
            (0,
            q.warn)("Blockly.utils.isRightButton", "September 2021", "September 2022", "Blockly.browserEvents.isRightButton");
            return (0,
            y.isRightButton)(a)
        }
        ;
        ca.mouseToSvg = function(a, b, c) {
            (0,
            q.warn)("Blockly.utils.mouseToSvg", "September 2021", "September 2022", "Blockly.browserEvents.mouseToSvg");
            return (0,
            y.mouseToSvg)(a, b, c)
        }
        ;
        ca.getScrollDeltaPixels = function(a) {
            (0,
            q.warn)("Blockly.utils.getScrollDeltaPixels", "September 2021", "September 2022", "Blockly.browserEvents.getScrollDeltaPixels");
            return (0,
            y.getScrollDeltaPixels)(a)
        }
        ;
        ca.tokenizeInterpolation = function(a) {
            (0,
            q.warn)("Blockly.utils.tokenizeInterpolation", "December 2021", "December 2022", "Blockly.utils.parsing.tokenizeInterpolation");
            return (0,
            ka.tokenizeInterpolation)(a)
        }
        ;
        ca.replaceMessageReferences = function(a) {
            (0,
            q.warn)("Blockly.utils.replaceMessageReferences", "December 2021", "December 2022", "Blockly.utils.parsing.replaceMessageReferences");
            return (0,
            ka.replaceMessageReferences)(a)
        }
        ;
        ca.checkMessageReferences = function(a) {
            (0,
            q.warn)("Blockly.utils.checkMessageReferences", "December 2021", "December 2022", "Blockly.utils.parsing.checkMessageReferences");
            return (0,
            ka.checkMessageReferences)(a)
        }
        ;
        ca.genUid = function() {
            (0,
            q.warn)("Blockly.utils.genUid", "September 2021", "September 2022", "Blockly.utils.idGenerator.genUid");
            return (0,
            bb.genUid)()
        }
        ;
        ca.is3dSupported = function() {
            (0,
            q.warn)("Blockly.utils.is3dSupported", "December 2021", "December 2022", "Blockly.utils.svgMath.is3dSupported");
            return (0,
            ja.is3dSupported)()
        }
        ;
        ca.getViewportBBox = function() {
            (0,
            q.warn)("Blockly.utils.getViewportBBox", "December 2021", "December 2022", "Blockly.utils.svgMath.getViewportBBox");
            return (0,
            ja.getViewportBBox)()
        }
        ;
        ca.arrayRemove = function(a, b) {
            (0,
            q.warn)("Blockly.utils.arrayRemove", "December 2021", "December 2022");
            return (0,
            zb)(a, b)
        }
        ;
        ca.getDocumentScroll = function() {
            (0,
            q.warn)("Blockly.utils.getDocumentScroll", "December 2021", "December 2022", "Blockly.utils.svgMath.getDocumentScroll");
            return (0,
            ja.getDocumentScroll)()
        }
        ;
        ca.getBlockTypeCounts = function(a, b) {
            (0,
            q.warn)("Blockly.utils.getBlockTypeCounts", "December 2021", "December 2022", "Blockly.common.getBlockTypeCounts");
            return (0,
            e.module$exports$Blockly$common.getBlockTypeCounts)(a, b)
        }
        ;
        ca.screenToWsCoordinates = function(a, b) {
            (0,
            q.warn)("Blockly.utils.screenToWsCoordinates", "December 2021", "December 2022", "Blockly.utils.svgMath.screenToWsCoordinates");
            return (0,
            ja.screenToWsCoordinates)(a, b)
        }
        ;
        ca.parseBlockColour = function(a) {
            (0,
            q.warn)("Blockly.utils.parseBlockColour", "December 2021", "December 2022", "Blockly.utils.parsing.parseBlockColour");
            return (0,
            ka.parseBlockColour)(a)
        }
        ;
        ca.runAfterPageLoad = function(a) {
            (0,
            q.warn)("Blockly.utils.runAfterPageLoad", "December 2021", "December 2022");
            (0,
            e.module$exports$Blockly$Extensions.runAfterPageLoad)(a)
        }
        ;
        var ec = {
            BlockDelete: function(a) {
                ec.BlockDelete.superClass_.constructor.call(this, a);
                if (a) {
                    if (a.getParent())
                        throw Error("Connected blocks cannot be deleted.");
                    a.isShadow() && (this.recordUndo = !1);
                    this.oldXml = (0,
                    e.module$exports$Blockly$Xml.blockToDomWithXY)(a);
                    this.ids = (0,
                    k.getDescendantIds)(a);
                    this.wasShadow = a.isShadow();
                    this.oldJson = (0,
                    Ya.save)(a, {
                        addCoordinates: !0
                    })
                }
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(ec.BlockDelete, Mb.BlockBase);
        ec.BlockDelete.prototype.type = k.DELETE;
        ec.BlockDelete.prototype.toJson = function() {
            var a = ec.BlockDelete.superClass_.toJson.call(this);
            a.oldXml = (0,
            e.module$exports$Blockly$Xml.domToText)(this.oldXml);
            a.ids = this.ids;
            a.wasShadow = this.wasShadow;
            a.oldJson = this.oldJson;
            this.recordUndo || (a.recordUndo = this.recordUndo);
            return a
        }
        ;
        ec.BlockDelete.prototype.fromJson = function(a) {
            ec.BlockDelete.superClass_.fromJson.call(this, a);
            this.oldXml = (0,
            e.module$exports$Blockly$Xml.textToDom)(a.oldXml);
            this.ids = a.ids;
            this.wasShadow = a.wasShadow || "shadow" === this.oldXml.tagName.toLowerCase();
            this.oldJson = a.oldJson;
            void 0 !== a.recordUndo && (this.recordUndo = a.recordUndo)
        }
        ;
        ec.BlockDelete.prototype.run = function(a) {
            var b = this.getEventWorkspace_();
            if (a)
                for (a = 0; a < this.ids.length; a++) {
                    var c = this.ids[a]
                      , d = b.getBlockById(c);
                    d ? d.dispose(!1) : c === this.blockId && console.warn("Can't delete non-existent block: " + c)
                }
            else
                (0,
                Ya.append)(this.oldJson, b)
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.DELETE, ec.BlockDelete);
        var F = {
            Block: function(a, b, c) {
                var d = e.module$exports$Blockly$Generator.Generator;
                if (d && "undefined" !== typeof d.prototype[b])
                    throw Error('Block prototypeName "' + b + '" conflicts with Blockly.Generator members.');
                this.id = c && !a.getBlockById(c) ? c : (0,
                bb.genUid)();
                a.setBlockById(this.id, this);
                this.previousConnection = this.nextConnection = this.outputConnection = null;
                this.inputList = [];
                this.inputsInline = void 0;
                this.disabled = !1;
                this.tooltip = "";
                this.contextMenu = !0;
                this.parentBlock_ = null;
                this.childBlocks_ = [];
                this.editable_ = this.movable_ = this.deletable_ = !0;
                this.collapsed_ = this.isShadow_ = !1;
                this.comment = this.outputShape_ = null;
                this.commentModel = {
                    text: null,
                    pinned: !1,
                    size: new Pa(160,80)
                };
                this.xy_ = new J(0,0);
                this.workspace = a;
                this.isInFlyout = a.isFlyout;
                this.isInMutator = a.isMutator;
                this.RTL = a.RTL;
                this.isInsertionMarker_ = !1;
                this.hat = void 0;
                this.rendered = null;
                this.statementInputCount = 0;
                if (b) {
                    this.type = b;
                    c = e.module$exports$Blockly$blocks.Blocks[b];
                    if (!c || "object" !== typeof c)
                        throw TypeError("Unknown block type: " + b);
                    (0,
                    e.module$exports$Blockly$utils$object.mixin)(this, c)
                }
                a.addTopBlock(this);
                a.addTypedBlock(this);
                (a = (0,
                k.getGroup)()) || (0,
                k.setGroup)(!0);
                b = (0,
                k.getRecordUndo)();
                try {
                    "function" === typeof this.init && ((0,
                    k.setRecordUndo)(!1),
                    this.init(),
                    (0,
                    k.setRecordUndo)(b)),
                    (0,
                    k.isEnabled)() && (0,
                    k.fire)(new ((0,
                    k.get)(k.CREATE))(this))
                } finally {
                    a || (0,
                    k.setGroup)(!1),
                    (0,
                    k.setRecordUndo)(b)
                }
                this.inputsInlineDefault = this.inputsInline;
                "function" === typeof this.onchange && this.setOnChange(this.onchange)
            }
        };
        F.Block.COLLAPSED_INPUT_NAME = lc.COLLAPSED_INPUT_NAME;
        F.Block.COLLAPSED_FIELD_NAME = lc.COLLAPSED_FIELD_NAME;
        F.Block.prototype.data = null;
        F.Block.prototype.disposed = !1;
        F.Block.prototype.hue_ = null;
        F.Block.prototype.colour_ = "#000000";
        F.Block.prototype.styleName_ = "";
        F.Block.prototype.dispose = function(a) {
            if (this.workspace) {
                this.onchangeWrapper_ && this.workspace.removeChangeListener(this.onchangeWrapper_);
                this.unplug(a);
                (0,
                k.isEnabled)() && (0,
                k.fire)(new ((0,
                k.get)(k.DELETE))(this));
                (0,
                k.disable)();
                try {
                    this.workspace && (this.workspace.removeTopBlock(this),
                    this.workspace.removeTypedBlock(this),
                    this.workspace.removeBlockById(this.id),
                    this.workspace = null);
                    (0,
                    e.module$exports$Blockly$common.getSelected)() === this && (0,
                    e.module$exports$Blockly$common.setSelected)(null);
                    for (var b = this.childBlocks_.length - 1; 0 <= b; b--)
                        this.childBlocks_[b].dispose(!1);
                    a = 0;
                    for (b = void 0; b = this.inputList[a]; a++)
                        b.dispose();
                    this.inputList.length = 0;
                    var c = this.getConnections_(!0);
                    a = 0;
                    for (b = void 0; b = c[a]; a++)
                        b.dispose()
                } finally {
                    (0,
                    k.enable)(),
                    this.disposed = !0
                }
            }
        }
        ;
        F.Block.prototype.initModel = function() {
            for (var a = 0, b; b = this.inputList[a]; a++)
                for (var c = 0, d; d = b.fieldRow[c]; c++)
                    d.initModel && d.initModel()
        }
        ;
        F.Block.prototype.unplug = function(a) {
            this.outputConnection && this.unplugFromRow_(a);
            this.previousConnection && this.unplugFromStack_(a)
        }
        ;
        F.Block.prototype.unplugFromRow_ = function(a) {
            var b = null;
            this.outputConnection.isConnected() && (b = this.outputConnection.targetConnection,
            this.outputConnection.disconnect());
            if (b && a && (a = this.getOnlyValueConnection_()) && a.isConnected() && !a.targetBlock().isShadow())
                if (a = a.targetConnection,
                a.disconnect(),
                this.workspace.connectionChecker.canConnect(a, b, !1))
                    b.connect(a);
                else
                    a.onFailedConnect(b)
        }
        ;
        F.Block.prototype.getOnlyValueConnection_ = function() {
            for (var a = null, b = 0; b < this.inputList.length; b++) {
                var c = this.inputList[b].connection;
                if (c && c.type === e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE && c.targetConnection) {
                    if (a)
                        return null;
                    a = c
                }
            }
            return a
        }
        ;
        F.Block.prototype.unplugFromStack_ = function(a) {
            var b = null;
            this.previousConnection.isConnected() && (b = this.previousConnection.targetConnection,
            this.previousConnection.disconnect());
            var c = this.getNextBlock();
            a && c && !c.isShadow() && (a = this.nextConnection.targetConnection,
            a.disconnect(),
            b && this.workspace.connectionChecker.canConnect(b, a, !1) && b.connect(a))
        }
        ;
        F.Block.prototype.getConnections_ = function(a) {
            a = [];
            this.outputConnection && a.push(this.outputConnection);
            this.previousConnection && a.push(this.previousConnection);
            this.nextConnection && a.push(this.nextConnection);
            for (var b = 0, c; c = this.inputList[b]; b++)
                c.connection && a.push(c.connection);
            return a
        }
        ;
        F.Block.prototype.lastConnectionInStack = function(a) {
            for (var b = this.nextConnection; b; ) {
                var c = b.targetBlock();
                if (!c || a && c.isShadow())
                    return b;
                b = c.nextConnection
            }
            return null
        }
        ;
        F.Block.prototype.bumpNeighbours = function() {}
        ;
        F.Block.prototype.getParent = function() {
            return this.parentBlock_
        }
        ;
        F.Block.prototype.getInputWithBlock = function(a) {
            for (var b = 0, c; c = this.inputList[b]; b++)
                if (c.connection && c.connection.targetBlock() === a)
                    return c;
            return null
        }
        ;
        F.Block.prototype.getSurroundParent = function() {
            var a = this;
            do {
                var b = a;
                a = a.getParent();
                if (!a)
                    return null
            } while (a.getNextBlock() === b);
            return a
        }
        ;
        F.Block.prototype.getNextBlock = function() {
            return this.nextConnection && this.nextConnection.targetBlock()
        }
        ;
        F.Block.prototype.getPreviousBlock = function() {
            return this.previousConnection && this.previousConnection.targetBlock()
        }
        ;
        F.Block.prototype.getFirstStatementConnection = function() {
            for (var a = 0, b; b = this.inputList[a]; a++)
                if (b.connection && b.connection.type === e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT)
                    return b.connection;
            return null
        }
        ;
        F.Block.prototype.getRootBlock = function() {
            var a = this;
            do {
                var b = a;
                a = b.parentBlock_
            } while (a);
            return b
        }
        ;
        F.Block.prototype.getTopStackBlock = function() {
            var a = this;
            do
                var b = a.getPreviousBlock();
            while (b && b.getNextBlock() === a && (a = b));
            return a
        }
        ;
        F.Block.prototype.getChildren = function(a) {
            if (!a)
                return this.childBlocks_;
            a = [];
            for (var b = 0, c; c = this.inputList[b]; b++)
                c.connection && (c = c.connection.targetBlock()) && a.push(c);
            (b = this.getNextBlock()) && a.push(b);
            return a
        }
        ;
        F.Block.prototype.setParent = function(a) {
            if (a !== this.parentBlock_) {
                var b = this.previousConnection && this.previousConnection.targetBlock() || this.outputConnection && this.outputConnection.targetBlock()
                  , c = !!b;
                if (c && a && b !== a)
                    throw Error("Block connected to superior one that is not new parent.");
                if (!c && a)
                    throw Error("Block not connected to new parent.");
                if (c && !a)
                    throw Error("Cannot set parent to null while block is still connected to superior block.");
                this.parentBlock_ ? (0,
                zb)(this.parentBlock_.childBlocks_, this) : this.workspace.removeTopBlock(this);
                (this.parentBlock_ = a) ? a.childBlocks_.push(this) : this.workspace.addTopBlock(this)
            }
        }
        ;
        F.Block.prototype.getDescendants = function(a) {
            for (var b = [this], c = this.getChildren(a), d, f = 0; d = c[f]; f++)
                b.push.apply(b, d.getDescendants(a));
            return b
        }
        ;
        F.Block.prototype.isDeletable = function() {
            return this.deletable_ && !this.isShadow_ && !(this.workspace && this.workspace.options.readOnly)
        }
        ;
        F.Block.prototype.setDeletable = function(a) {
            this.deletable_ = a
        }
        ;
        F.Block.prototype.isMovable = function() {
            return this.movable_ && !this.isShadow_ && !(this.workspace && this.workspace.options.readOnly)
        }
        ;
        F.Block.prototype.setMovable = function(a) {
            this.movable_ = a
        }
        ;
        F.Block.prototype.isDuplicatable = function() {
            return this.workspace.hasBlockLimits() ? this.workspace.isCapacityAvailable((0,
            e.module$exports$Blockly$common.getBlockTypeCounts)(this, !0)) : !0
        }
        ;
        F.Block.prototype.isShadow = function() {
            return this.isShadow_
        }
        ;
        F.Block.prototype.setShadow = function(a) {
            this.isShadow_ = a
        }
        ;
        F.Block.prototype.isInsertionMarker = function() {
            return this.isInsertionMarker_
        }
        ;
        F.Block.prototype.setInsertionMarker = function(a) {
            this.isInsertionMarker_ = a
        }
        ;
        F.Block.prototype.isEditable = function() {
            return this.editable_ && !(this.workspace && this.workspace.options.readOnly)
        }
        ;
        F.Block.prototype.setEditable = function(a) {
            this.editable_ = a;
            a = 0;
            for (var b; b = this.inputList[a]; a++)
                for (var c = 0, d; d = b.fieldRow[c]; c++)
                    d.updateEditable()
        }
        ;
        F.Block.prototype.isDisposed = function() {
            return this.disposed
        }
        ;
        F.Block.prototype.getMatchingConnection = function(a, b) {
            var c = this.getConnections_(!0);
            a = a.getConnections_(!0);
            if (c.length !== a.length)
                throw Error("Connection lists did not match in length.");
            for (var d = 0; d < a.length; d++)
                if (a[d] === b)
                    return c[d];
            return null
        }
        ;
        F.Block.prototype.setHelpUrl = function(a) {
            this.helpUrl = a
        }
        ;
        F.Block.prototype.setTooltip = function(a) {
            this.tooltip = a
        }
        ;
        F.Block.prototype.getTooltip = function() {
            return (0,
            aa.getTooltipOfObject)(this)
        }
        ;
        F.Block.prototype.getColour = function() {
            return this.colour_
        }
        ;
        F.Block.prototype.getStyleName = function() {
            return this.styleName_
        }
        ;
        F.Block.prototype.getHue = function() {
            return this.hue_
        }
        ;
        F.Block.prototype.setColour = function(a) {
            a = (0,
            ka.parseBlockColour)(a);
            this.hue_ = a.hue;
            this.colour_ = a.hex
        }
        ;
        F.Block.prototype.setStyle = function(a) {
            this.styleName_ = a
        }
        ;
        F.Block.prototype.setOnChange = function(a) {
            if (a && "function" !== typeof a)
                throw Error("onchange must be a function.");
            this.onchangeWrapper_ && this.workspace.removeChangeListener(this.onchangeWrapper_);
            if (this.onchange = a)
                this.onchangeWrapper_ = a.bind(this),
                this.workspace.addChangeListener(this.onchangeWrapper_)
        }
        ;
        F.Block.prototype.getField = function(a) {
            if ("string" !== typeof a)
                throw TypeError("Block.prototype.getField expects a string with the field name but received " + (void 0 === a ? "nothing" : a + " of type " + typeof a) + " instead");
            for (var b = 0, c; c = this.inputList[b]; b++)
                for (var d = 0, f; f = c.fieldRow[d]; d++)
                    if (f.name === a)
                        return f;
            return null
        }
        ;
        F.Block.prototype.getVars = function() {
            for (var a = [], b = 0, c; c = this.inputList[b]; b++)
                for (var d = 0, f; f = c.fieldRow[d]; d++)
                    f.referencesVariables() && a.push(f.getValue());
            return a
        }
        ;
        F.Block.prototype.getVarModels = function() {
            for (var a = [], b = 0, c; c = this.inputList[b]; b++)
                for (var d = 0, f; f = c.fieldRow[d]; d++)
                    f.referencesVariables() && (f = this.workspace.getVariableById(f.getValue())) && a.push(f);
            return a
        }
        ;
        F.Block.prototype.updateVarName = function(a) {
            for (var b = 0, c; c = this.inputList[b]; b++)
                for (var d = 0, f; f = c.fieldRow[d]; d++)
                    f.referencesVariables() && a.getId() === f.getValue() && f.refreshVariableName()
        }
        ;
        F.Block.prototype.renameVarById = function(a, b) {
            for (var c = 0, d; d = this.inputList[c]; c++)
                for (var f = 0, g; g = d.fieldRow[f]; f++)
                    g.referencesVariables() && a === g.getValue() && g.setValue(b)
        }
        ;
        F.Block.prototype.getFieldValue = function(a) {
            return (a = this.getField(a)) ? a.getValue() : null
        }
        ;
        F.Block.prototype.setFieldValue = function(a, b) {
            var c = this.getField(b);
            if (!c)
                throw Error('Field "' + b + '" not found.');
            c.setValue(a)
        }
        ;
        F.Block.prototype.setPreviousStatement = function(a, b) {
            if (a)
                void 0 === b && (b = null),
                this.previousConnection || (this.previousConnection = this.makeConnection_(e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT)),
                this.previousConnection.setCheck(b);
            else if (this.previousConnection) {
                if (this.previousConnection.isConnected())
                    throw Error("Must disconnect previous statement before removing connection.");
                this.previousConnection.dispose();
                this.previousConnection = null
            }
        }
        ;
        F.Block.prototype.setNextStatement = function(a, b) {
            if (a)
                void 0 === b && (b = null),
                this.nextConnection || (this.nextConnection = this.makeConnection_(e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT)),
                this.nextConnection.setCheck(b);
            else if (this.nextConnection) {
                if (this.nextConnection.isConnected())
                    throw Error("Must disconnect next statement before removing connection.");
                this.nextConnection.dispose();
                this.nextConnection = null
            }
        }
        ;
        F.Block.prototype.setOutput = function(a, b) {
            if (a)
                void 0 === b && (b = null),
                this.outputConnection || (this.outputConnection = this.makeConnection_(e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE)),
                this.outputConnection.setCheck(b);
            else if (this.outputConnection) {
                if (this.outputConnection.isConnected())
                    throw Error("Must disconnect output value before removing connection.");
                this.outputConnection.dispose();
                this.outputConnection = null
            }
        }
        ;
        F.Block.prototype.setInputsInline = function(a) {
            this.inputsInline !== a && ((0,
            k.fire)(new ((0,
            k.get)(k.CHANGE))(this,"inline",null,this.inputsInline,a)),
            this.inputsInline = a)
        }
        ;
        F.Block.prototype.getInputsInline = function() {
            if (void 0 !== this.inputsInline)
                return this.inputsInline;
            for (var a = 1; a < this.inputList.length; a++)
                if (this.inputList[a - 1].type === e.module$exports$Blockly$inputTypes.inputTypes.DUMMY && this.inputList[a].type === e.module$exports$Blockly$inputTypes.inputTypes.DUMMY)
                    return !1;
            for (a = 1; a < this.inputList.length; a++)
                if (this.inputList[a - 1].type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE && this.inputList[a].type === e.module$exports$Blockly$inputTypes.inputTypes.DUMMY)
                    return !0;
            return !1
        }
        ;
        F.Block.prototype.setOutputShape = function(a) {
            this.outputShape_ = a
        }
        ;
        F.Block.prototype.getOutputShape = function() {
            return this.outputShape_
        }
        ;
        F.Block.prototype.isEnabled = function() {
            return !this.disabled
        }
        ;
        F.Block.prototype.setEnabled = function(a) {
            if (this.isEnabled() !== a) {
                var b = this.disabled;
                this.disabled = !a;
                (0,
                k.fire)(new ((0,
                k.get)(k.CHANGE))(this,"disabled",null,b,!a))
            }
        }
        ;
        F.Block.prototype.getInheritedDisabled = function() {
            for (var a = this.getSurroundParent(); a; ) {
                if (a.disabled)
                    return !0;
                a = a.getSurroundParent()
            }
            return !1
        }
        ;
        F.Block.prototype.isCollapsed = function() {
            return this.collapsed_
        }
        ;
        F.Block.prototype.setCollapsed = function(a) {
            this.collapsed_ !== a && ((0,
            k.fire)(new ((0,
            k.get)(k.CHANGE))(this,"collapsed",null,this.collapsed_,a)),
            this.collapsed_ = a)
        }
        ;
        F.Block.prototype.toString = function(a, b) {
            function c(G) {
                var W = G.getCheck();
                !W && G.targetConnection && (W = G.targetConnection.getCheck());
                return !!W && (-1 !== W.indexOf("Boolean") || -1 !== W.indexOf("Number"))
            }
            function d() {
                m && m.getType() === r.getType() && m.getLocation() === r.getLocation() && (m = null)
            }
            var f = [];
            b = b || "?";
            var g = A.ASTNode.NAVIGATE_ALL_FIELDS;
            A.ASTNode.NAVIGATE_ALL_FIELDS = !0;
            for (var m = A.ASTNode.createBlockNode(this), r = m; m; ) {
                switch (m.getType()) {
                case A.ASTNode.types.INPUT:
                    var B = m.getLocation();
                    m.in() ? c(B) && f.push("(") : f.push(b);
                    break;
                case A.ASTNode.types.FIELD:
                    B = m.getLocation(),
                    B.name !== lc.COLLAPSED_FIELD_NAME && f.push(B.getText())
                }
                B = m;
                m = B.in() || B.next();
                if (!m) {
                    m = B.out();
                    for (d(); m && !m.next(); )
                        m = m.out(),
                        d(),
                        m && m.getType() === A.ASTNode.types.INPUT && c(m.getLocation()) && f.push(")");
                    m && (m = m.next())
                }
            }
            A.ASTNode.NAVIGATE_ALL_FIELDS = g;
            for (b = 2; b < f.length; b++)
                "(" === f[b - 2] && ")" === f[b] && (f[b - 2] = f[b - 1],
                f.splice(b - 1, 2));
            f = f.reduce(function(G, W) {
                return G + ("(" === G.substr(-1) || ")" === W ? "" : " ") + W
            }, "");
            f = f.trim() || "???";
            a && f.length > a && (f = f.substring(0, a - 3) + "...");
            return f
        }
        ;
        F.Block.prototype.appendValueInput = function(a) {
            return this.appendInput_(e.module$exports$Blockly$inputTypes.inputTypes.VALUE, a)
        }
        ;
        F.Block.prototype.appendStatementInput = function(a) {
            return this.appendInput_(e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT, a)
        }
        ;
        F.Block.prototype.appendDummyInput = function(a) {
            return this.appendInput_(e.module$exports$Blockly$inputTypes.inputTypes.DUMMY, a || "")
        }
        ;
        F.Block.prototype.jsonInit = function(a) {
            var b = a.type ? 'Block "' + a.type + '": ' : "";
            if (a.output && a.previousStatement)
                throw Error(b + "Must not have both an output and a previousStatement.");
            a.style && a.style.hat && (this.hat = a.style.hat,
            a.style = null);
            if (a.style && a.colour)
                throw Error(b + "Must not have both a colour and a style.");
            a.style ? this.jsonInitStyle_(a, b) : this.jsonInitColour_(a, b);
            for (var c = 0; void 0 !== a["message" + c]; )
                this.interpolate_(a["message" + c], a["args" + c] || [], a["lastDummyAlign" + c], b),
                c++;
            void 0 !== a.inputsInline && this.setInputsInline(a.inputsInline);
            void 0 !== a.output && this.setOutput(!0, a.output);
            void 0 !== a.outputShape && this.setOutputShape(a.outputShape);
            void 0 !== a.previousStatement && this.setPreviousStatement(!0, a.previousStatement);
            void 0 !== a.nextStatement && this.setNextStatement(!0, a.nextStatement);
            void 0 !== a.tooltip && (c = (0,
            ka.replaceMessageReferences)(a.tooltip),
            this.setTooltip(c));
            void 0 !== a.enableContextMenu && (this.contextMenu = !!a.enableContextMenu);
            void 0 !== a.suppressPrefixSuffix && (this.suppressPrefixSuffix = !!a.suppressPrefixSuffix);
            void 0 !== a.helpUrl && (c = (0,
            ka.replaceMessageReferences)(a.helpUrl),
            this.setHelpUrl(c));
            "string" === typeof a.extensions && (console.warn(b + "JSON attribute 'extensions' should be an array of strings. Found raw string in JSON for '" + a.type + "' block."),
            a.extensions = [a.extensions]);
            void 0 !== a.mutator && (0,
            e.module$exports$Blockly$Extensions.apply)(a.mutator, this, !0);
            a = a.extensions;
            if (Array.isArray(a))
                for (b = 0; b < a.length; b++)
                    (0,
                    e.module$exports$Blockly$Extensions.apply)(a[b], this, !1)
        }
        ;
        F.Block.prototype.jsonInitColour_ = function(a, b) {
            if ("colour"in a)
                if (void 0 === a.colour)
                    console.warn(b + "Undefined colour value.");
                else {
                    a = a.colour;
                    try {
                        this.setColour(a)
                    } catch (c) {
                        console.warn(b + "Illegal colour value: ", a)
                    }
                }
        }
        ;
        F.Block.prototype.jsonInitStyle_ = function(a, b) {
            a = a.style;
            try {
                this.setStyle(a)
            } catch (c) {
                console.warn(b + "Style does not exist: ", a)
            }
        }
        ;
        F.Block.prototype.mixin = function(a, b) {
            if (void 0 !== b && "boolean" !== typeof b)
                throw Error("opt_disableCheck must be a boolean if provided");
            if (!b) {
                b = [];
                for (var c in a)
                    void 0 !== this[c] && b.push(c);
                if (b.length)
                    throw Error("Mixin will overwrite block members: " + JSON.stringify(b));
            }
            (0,
            e.module$exports$Blockly$utils$object.mixin)(this, a)
        }
        ;
        F.Block.prototype.interpolate_ = function(a, b, c, d) {
            a = (0,
            ka.tokenizeInterpolation)(a);
            this.validateTokens_(a, b.length);
            b = this.interpolateArguments_(a, b, c);
            c = [];
            a = 0;
            for (var f; f = b[a]; a++)
                if (this.isInputKeyword_(f.type)) {
                    if (f = this.inputFromJson_(f, d)) {
                        for (var g = 0, m; m = c[g]; g++)
                            f.appendField(m[0], m[1]);
                        c.length = 0
                    }
                } else
                    (g = this.fieldFromJson_(f)) && c.push([g, f.name])
        }
        ;
        F.Block.prototype.validateTokens_ = function(a, b) {
            for (var c = [], d = 0, f = 0; f < a.length; f++) {
                var g = a[f];
                if ("number" === typeof g) {
                    if (1 > g || g > b)
                        throw Error('Block "' + this.type + '": Message index %' + g + " out of range.");
                    if (c[g])
                        throw Error('Block "' + this.type + '": Message index %' + g + " duplicated.");
                    c[g] = !0;
                    d++
                }
            }
            if (d !== b)
                throw Error('Block "' + this.type + '": Message does not reference all ' + b + " arg(s).");
        }
        ;
        F.Block.prototype.interpolateArguments_ = function(a, b, c) {
            for (var d = [], f = 0; f < a.length; f++) {
                var g = a[f];
                "number" === typeof g && (g = b[g - 1]);
                ("string" !== typeof g || (g = this.stringToFieldJson_(g),
                g)) && d.push(g)
            }
            (a = d.length) && !this.isInputKeyword_(d[a - 1].type) && (a = {
                type: "input_dummy"
            },
            c && (a.align = c),
            d.push(a));
            return d
        }
        ;
        F.Block.prototype.fieldFromJson_ = function(a) {
            var b = (0,
            tb.fromJson)(a);
            return !b && a.alt ? "string" === typeof a.alt ? (a = this.stringToFieldJson_(a.alt)) ? this.fieldFromJson_(a) : null : this.fieldFromJson_(a.alt) : b
        }
        ;
        F.Block.prototype.inputFromJson_ = function(a, b) {
            var c = {
                LEFT: e.module$exports$Blockly$Input.Align.LEFT,
                RIGHT: e.module$exports$Blockly$Input.Align.RIGHT,
                CENTRE: e.module$exports$Blockly$Input.Align.CENTRE,
                CENTER: e.module$exports$Blockly$Input.Align.CENTRE
            }
              , d = null;
            switch (a.type) {
            case "input_value":
                d = this.appendValueInput(a.name);
                break;
            case "input_statement":
                d = this.appendStatementInput(a.name);
                break;
            case "input_dummy":
                d = this.appendDummyInput(a.name)
            }
            if (!d)
                return null;
            a.check && d.setCheck(a.check);
            a.align && (c = c[a.align.toUpperCase()],
            void 0 === c ? console.warn(b + "Illegal align value: ", a.align) : d.setAlign(c));
            return d
        }
        ;
        F.Block.prototype.isInputKeyword_ = function(a) {
            return "input_value" === a || "input_statement" === a || "input_dummy" === a
        }
        ;
        F.Block.prototype.stringToFieldJson_ = function(a) {
            return (a = a.trim()) ? {
                type: "field_label",
                text: a
            } : null
        }
        ;
        F.Block.prototype.appendInput_ = function(a, b) {
            var c = null;
            if (a === e.module$exports$Blockly$inputTypes.inputTypes.VALUE || a === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT)
                c = this.makeConnection_(a);
            a === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT && this.statementInputCount++;
            a = new e.module$exports$Blockly$Input.Input(a,b,this,c);
            this.inputList.push(a);
            return a
        }
        ;
        F.Block.prototype.moveInputBefore = function(a, b) {
            if (a !== b) {
                for (var c = -1, d = b ? -1 : this.inputList.length, f = 0, g; g = this.inputList[f]; f++)
                    if (g.name === a) {
                        if (c = f,
                        -1 !== d)
                            break
                    } else if (b && g.name === b && (d = f,
                    -1 !== c))
                        break;
                if (-1 === c)
                    throw Error('Named input "' + a + '" not found.');
                if (-1 === d)
                    throw Error('Reference input "' + b + '" not found.');
                this.moveNumberedInputBefore(c, d)
            }
        }
        ;
        F.Block.prototype.moveNumberedInputBefore = function(a, b) {
            if (a === b)
                throw Error("Can't move input to itself.");
            if (a >= this.inputList.length)
                throw RangeError("Input index " + a + " out of bounds.");
            if (b > this.inputList.length)
                throw RangeError("Reference input " + b + " out of bounds.");
            var c = this.inputList[a];
            this.inputList.splice(a, 1);
            a < b && b--;
            this.inputList.splice(b, 0, c)
        }
        ;
        F.Block.prototype.removeInput = function(a, b) {
            for (var c = 0, d; d = this.inputList[c]; c++)
                if (d.name === a)
                    return d.type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT && this.statementInputCount--,
                    d.dispose(),
                    this.inputList.splice(c, 1),
                    !0;
            if (b)
                return !1;
            throw Error("Input not found: " + a);
        }
        ;
        F.Block.prototype.getInput = function(a) {
            for (var b = 0, c; c = this.inputList[b]; b++)
                if (c.name === a)
                    return c;
            return null
        }
        ;
        F.Block.prototype.getInputTargetBlock = function(a) {
            return (a = this.getInput(a)) && a.connection && a.connection.targetBlock()
        }
        ;
        F.Block.prototype.getCommentText = function() {
            return this.commentModel.text
        }
        ;
        F.Block.prototype.setCommentText = function(a) {
            this.commentModel.text !== a && ((0,
            k.fire)(new ((0,
            k.get)(k.CHANGE))(this,"comment",null,this.commentModel.text,a)),
            this.comment = this.commentModel.text = a)
        }
        ;
        F.Block.prototype.setWarningText = function(a, b) {}
        ;
        F.Block.prototype.setMutator = function(a) {}
        ;
        F.Block.prototype.getRelativeToSurfaceXY = function() {
            return this.xy_
        }
        ;
        F.Block.prototype.moveBy = function(a, b) {
            if (this.parentBlock_)
                throw Error("Block has parent.");
            var c = new ((0,
            k.get)(k.MOVE))(this);
            this.xy_.translate(a, b);
            c.recordNew();
            (0,
            k.fire)(c)
        }
        ;
        F.Block.prototype.makeConnection_ = function(a) {
            return new K(this,a)
        }
        ;
        F.Block.prototype.allInputsFilled = function(a) {
            void 0 === a && (a = !0);
            if (!a && this.isShadow())
                return !1;
            for (var b = 0, c; c = this.inputList[b]; b++)
                if (c.connection && (c = c.connection.targetBlock(),
                !c || !c.allInputsFilled(a)))
                    return !1;
            return (b = this.getNextBlock()) ? b.allInputsFilled(a) : !0
        }
        ;
        F.Block.prototype.toDevString = function() {
            var a = this.type ? '"' + this.type + '" block' : "Block";
            this.id && (a += ' (id="' + this.id + '")');
            return a
        }
        ;
        var ia = {
            ContextMenuRegistry: function() {
                ia.ContextMenuRegistry.registry = this;
                this.registry_ = Object.create(null)
            }
        };
        ia.ContextMenuRegistry.ScopeType = {
            BLOCK: "block",
            WORKSPACE: "workspace"
        };
        ia.ContextMenuRegistry.registry = null;
        ia.ContextMenuRegistry.prototype.register = function(a) {
            if (this.registry_[a.id])
                throw Error('Menu item with ID "' + a.id + '" is already registered.');
            this.registry_[a.id] = a
        }
        ;
        ia.ContextMenuRegistry.prototype.unregister = function(a) {
            if (!this.registry_[a])
                throw Error('Menu item with ID "' + a + '" not found.');
            delete this.registry_[a]
        }
        ;
        ia.ContextMenuRegistry.prototype.getItem = function(a) {
            return this.registry_[a] || null
        }
        ;
        ia.ContextMenuRegistry.prototype.getContextMenuOptions = function(a, b) {
            var c = []
              , d = this.registry_;
            Object.keys(d).forEach(function(f) {
                f = d[f];
                if (a === f.scopeType) {
                    var g = f.preconditionFn(b);
                    "hidden" !== g && (f = {
                        text: "function" === typeof f.displayText ? f.displayText(b) : f.displayText,
                        enabled: "enabled" === g,
                        callback: f.callback,
                        scope: b,
                        weight: f.weight
                    },
                    c.push(f))
                }
            });
            c.sort(function(f, g) {
                return f.weight - g.weight
            });
            return c
        }
        ;
        new ia.ContextMenuRegistry;
        var ea = {
            RenderedConnection: function(a, b) {
                ea.RenderedConnection.superClass_.constructor.call(this, a, b);
                this.db_ = a.workspace.connectionDBList[b];
                this.dbOpposite_ = a.workspace.connectionDBList[e.module$exports$Blockly$internalConstants.OPPOSITE_TYPE[b]];
                this.offsetInBlock_ = new J(0,0);
                this.trackedState_ = ea.RenderedConnection.TrackedState.WILL_TRACK;
                this.targetConnection = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(ea.RenderedConnection, K);
        ea.RenderedConnection.TrackedState = {
            WILL_TRACK: -1,
            UNTRACKED: 0,
            TRACKED: 1
        };
        ea.RenderedConnection.prototype.dispose = function() {
            ea.RenderedConnection.superClass_.dispose.call(this);
            this.trackedState_ === ea.RenderedConnection.TrackedState.TRACKED && this.db_.removeConnection(this, this.y)
        }
        ;
        ea.RenderedConnection.prototype.getSourceBlock = function() {
            return ea.RenderedConnection.superClass_.getSourceBlock.call(this)
        }
        ;
        ea.RenderedConnection.prototype.targetBlock = function() {
            return ea.RenderedConnection.superClass_.targetBlock.call(this)
        }
        ;
        ea.RenderedConnection.prototype.distanceFrom = function(a) {
            var b = this.x - a.x;
            a = this.y - a.y;
            return Math.sqrt(b * b + a * a)
        }
        ;
        ea.RenderedConnection.prototype.bumpAwayFrom = function(a) {
            if (!this.sourceBlock_.workspace.isDragging()) {
                var b = this.sourceBlock_.getRootBlock();
                if (!b.isInFlyout) {
                    var c = !1;
                    if (!b.isMovable()) {
                        b = a.getSourceBlock().getRootBlock();
                        if (!b.isMovable())
                            return;
                        a = this;
                        c = !0
                    }
                    var d = (0,
                    e.module$exports$Blockly$common.getSelected)() == b;
                    d || b.addSelect();
                    var f = a.x + e.module$exports$Blockly$internalConstants.SNAP_RADIUS + Math.floor(Math.random() * e.module$exports$Blockly$internalConstants.BUMP_RANDOMNESS) - this.x
                      , g = a.y + e.module$exports$Blockly$internalConstants.SNAP_RADIUS + Math.floor(Math.random() * e.module$exports$Blockly$internalConstants.BUMP_RANDOMNESS) - this.y;
                    c && (g = -g);
                    b.RTL && (f = a.x - e.module$exports$Blockly$internalConstants.SNAP_RADIUS - Math.floor(Math.random() * e.module$exports$Blockly$internalConstants.BUMP_RANDOMNESS) - this.x);
                    b.moveBy(f, g);
                    d || b.removeSelect()
                }
            }
        }
        ;
        ea.RenderedConnection.prototype.moveTo = function(a, b) {
            this.trackedState_ === ea.RenderedConnection.TrackedState.WILL_TRACK ? (this.db_.addConnection(this, b),
            this.trackedState_ = ea.RenderedConnection.TrackedState.TRACKED) : this.trackedState_ === ea.RenderedConnection.TrackedState.TRACKED && (this.db_.removeConnection(this, this.y),
            this.db_.addConnection(this, b));
            this.x = a;
            this.y = b
        }
        ;
        ea.RenderedConnection.prototype.moveBy = function(a, b) {
            this.moveTo(this.x + a, this.y + b)
        }
        ;
        ea.RenderedConnection.prototype.moveToOffset = function(a) {
            this.moveTo(a.x + this.offsetInBlock_.x, a.y + this.offsetInBlock_.y)
        }
        ;
        ea.RenderedConnection.prototype.setOffsetInBlock = function(a, b) {
            this.offsetInBlock_.x = a;
            this.offsetInBlock_.y = b
        }
        ;
        ea.RenderedConnection.prototype.getOffsetInBlock = function() {
            return this.offsetInBlock_
        }
        ;
        ea.RenderedConnection.prototype.tighten = function() {
            var a = this.targetConnection.x - this.x
              , b = this.targetConnection.y - this.y;
            if (0 !== a || 0 !== b) {
                var c = this.targetBlock()
                  , d = c.getSvgRoot();
                if (!d)
                    throw Error("block is not rendered.");
                d = (0,
                ja.getRelativeXY)(d);
                c.getSvgRoot().setAttribute("transform", "translate(" + (d.x - a) + "," + (d.y - b) + ")");
                c.moveConnections(-a, -b)
            }
        }
        ;
        ea.RenderedConnection.prototype.closest = function(a, b) {
            return this.dbOpposite_.searchForClosest(this, a, b)
        }
        ;
        ea.RenderedConnection.prototype.highlight = function() {
            var a = this.sourceBlock_.workspace.getRenderer().getConstants()
              , b = a.shapeFor(this);
            this.type === e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE || this.type === e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE ? (a = a.TAB_OFFSET_FROM_TOP,
            b = (0,
            t.moveBy)(0, -a) + (0,
            t.lineOnAxis)("v", a) + b.pathDown + (0,
            t.lineOnAxis)("v", a)) : (a = a.NOTCH_OFFSET_LEFT - a.CORNER_RADIUS,
            b = (0,
            t.moveBy)(-a, 0) + (0,
            t.lineOnAxis)("h", a) + b.pathLeft + (0,
            t.lineOnAxis)("h", a));
            a = this.sourceBlock_.getRelativeToSurfaceXY();
            K.highlightedPath_ = (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyHighlightedConnectionPath",
                d: b,
                transform: "translate(" + (this.x - a.x) + "," + (this.y - a.y) + ")" + (this.sourceBlock_.RTL ? " scale(-1 1)" : "")
            }, this.sourceBlock_.getSvgRoot())
        }
        ;
        ea.RenderedConnection.prototype.unhighlight = function() {
            (0,
            n.removeNode)(K.highlightedPath_);
            delete K.highlightedPath_
        }
        ;
        ea.RenderedConnection.prototype.setTracking = function(a) {
            a && this.trackedState_ === ea.RenderedConnection.TrackedState.TRACKED || !a && this.trackedState_ === ea.RenderedConnection.TrackedState.UNTRACKED || this.sourceBlock_.isInFlyout || (a ? (this.db_.addConnection(this, this.y),
            this.trackedState_ = ea.RenderedConnection.TrackedState.TRACKED) : (this.trackedState_ === ea.RenderedConnection.TrackedState.TRACKED && this.db_.removeConnection(this, this.y),
            this.trackedState_ = ea.RenderedConnection.TrackedState.UNTRACKED))
        }
        ;
        ea.RenderedConnection.prototype.stopTrackingAll = function() {
            this.setTracking(!1);
            if (this.targetConnection)
                for (var a = this.targetBlock().getDescendants(!1), b = 0; b < a.length; b++) {
                    for (var c = a[b], d = c.getConnections_(!0), f = 0; f < d.length; f++)
                        d[f].setTracking(!1);
                    c = c.getIcons();
                    for (d = 0; d < c.length; d++)
                        c[d].setVisible(!1)
                }
        }
        ;
        ea.RenderedConnection.prototype.startTrackingAll = function() {
            this.setTracking(!0);
            var a = [];
            if (this.type !== e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE && this.type !== e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT)
                return a;
            var b = this.targetBlock();
            if (b) {
                if (b.isCollapsed()) {
                    var c = [];
                    b.outputConnection && c.push(b.outputConnection);
                    b.nextConnection && c.push(b.nextConnection);
                    b.previousConnection && c.push(b.previousConnection)
                } else
                    c = b.getConnections_(!0);
                for (var d = 0; d < c.length; d++)
                    a.push.apply(a, c[d].startTrackingAll());
                a.length || (a = [b])
            }
            return a
        }
        ;
        ea.RenderedConnection.prototype.onFailedConnect = function(a) {
            var b = this.getSourceBlock();
            if ((0,
            k.getRecordUndo)()) {
                var c = (0,
                k.getGroup)();
                setTimeout(function() {
                    b.isDisposed() || b.getParent() || ((0,
                    k.setGroup)(c),
                    this.bumpAwayFrom(a),
                    (0,
                    k.setGroup)(!1))
                }
                .bind(this), e.module$exports$Blockly$internalConstants.BUMP_DELAY)
            }
        }
        ;
        ea.RenderedConnection.prototype.disconnectInternal_ = function(a, b) {
            ea.RenderedConnection.superClass_.disconnectInternal_.call(this, a, b);
            a.rendered && a.render();
            b.rendered && (b.updateDisabled(),
            b.render(),
            b.getSvgRoot().style.display = "block")
        }
        ;
        ea.RenderedConnection.prototype.respawnShadow_ = function() {
            ea.RenderedConnection.superClass_.respawnShadow_.call(this);
            var a = this.targetBlock();
            a && (a.initSvg(),
            a.render(!1),
            a = this.getSourceBlock(),
            a.rendered && a.render())
        }
        ;
        ea.RenderedConnection.prototype.neighbours = function(a) {
            return this.dbOpposite_.getNeighbours(this, a)
        }
        ;
        ea.RenderedConnection.prototype.connect_ = function(a) {
            ea.RenderedConnection.superClass_.connect_.call(this, a);
            var b = this.getSourceBlock();
            a = a.getSourceBlock();
            var c = b.rendered
              , d = a.rendered;
            c && b.updateDisabled();
            d && a.updateDisabled();
            c && d && (this.type === e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT || this.type === e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT ? a.render() : b.render());
            if (b = b.getInputWithBlock(a))
                b = b.isVisible(),
                a.getSvgRoot().style.display = b ? "block" : "none"
        }
        ;
        ea.RenderedConnection.prototype.onCheckChanged_ = function() {
            !this.isConnected() || this.targetConnection && this.getConnectionChecker().canConnect(this, this.targetConnection, !1) || ((this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug(),
            this.sourceBlock_.bumpNeighbours())
        }
        ;
        var qc = function() {
            this.drawer_ = this.curNode_ = this.colour = null;
            this.type = "marker"
        };
        qc.prototype.setDrawer = function(a) {
            this.drawer_ = a
        }
        ;
        qc.prototype.getDrawer = function() {
            return this.drawer_
        }
        ;
        qc.prototype.getCurNode = function() {
            return this.curNode_
        }
        ;
        qc.prototype.setCurNode = function(a) {
            var b = this.curNode_;
            this.curNode_ = a;
            this.drawer_ && this.drawer_.draw(b, this.curNode_)
        }
        ;
        qc.prototype.draw = function() {
            this.drawer_ && this.drawer_.draw(this.curNode_, this.curNode_)
        }
        ;
        qc.prototype.hide = function() {
            this.drawer_ && this.drawer_.hide()
        }
        ;
        qc.prototype.dispose = function() {
            this.getDrawer() && this.getDrawer().dispose()
        }
        ;
        var rc = {
            Cursor: function() {
                rc.Cursor.superClass_.constructor.call(this);
                this.type = "cursor"
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(rc.Cursor, qc);
        rc.Cursor.prototype.next = function() {
            var a = this.getCurNode();
            if (!a)
                return null;
            for (a = a.next(); a && a.next() && (a.getType() === A.ASTNode.types.NEXT || a.getType() === A.ASTNode.types.BLOCK); )
                a = a.next();
            a && this.setCurNode(a);
            return a
        }
        ;
        rc.Cursor.prototype.in = function() {
            var a = this.getCurNode();
            if (!a)
                return null;
            if (a.getType() === A.ASTNode.types.PREVIOUS || a.getType() === A.ASTNode.types.OUTPUT)
                a = a.next();
            (a = a.in()) && this.setCurNode(a);
            return a
        }
        ;
        rc.Cursor.prototype.prev = function() {
            var a = this.getCurNode();
            if (!a)
                return null;
            for (a = a.prev(); a && a.prev() && (a.getType() === A.ASTNode.types.NEXT || a.getType() === A.ASTNode.types.BLOCK); )
                a = a.prev();
            a && this.setCurNode(a);
            return a
        }
        ;
        rc.Cursor.prototype.out = function() {
            var a = this.getCurNode();
            if (!a)
                return null;
            (a = a.out()) && a.getType() === A.ASTNode.types.BLOCK && (a = a.prev() || a);
            a && this.setCurNode(a);
            return a
        }
        ;
        (0,
        w.register)(w.Type.CURSOR, w.DEFAULT, rc.Cursor);
        var hb = {
            BasicCursor: function() {
                hb.BasicCursor.superClass_.constructor.call(this)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(hb.BasicCursor, rc.Cursor);
        hb.BasicCursor.registrationName = "basicCursor";
        hb.BasicCursor.prototype.next = function() {
            var a = this.getCurNode();
            if (!a)
                return null;
            (a = this.getNextNode_(a, this.validNode_)) && this.setCurNode(a);
            return a
        }
        ;
        hb.BasicCursor.prototype.in = function() {
            return this.next()
        }
        ;
        hb.BasicCursor.prototype.prev = function() {
            var a = this.getCurNode();
            if (!a)
                return null;
            (a = this.getPreviousNode_(a, this.validNode_)) && this.setCurNode(a);
            return a
        }
        ;
        hb.BasicCursor.prototype.out = function() {
            return this.prev()
        }
        ;
        hb.BasicCursor.prototype.getNextNode_ = function(a, b) {
            if (!a)
                return null;
            var c = a.in() || a.next();
            if (b(c))
                return c;
            if (c)
                return this.getNextNode_(c, b);
            a = this.findSiblingOrParent_(a.out());
            return b(a) ? a : a ? this.getNextNode_(a, b) : null
        }
        ;
        hb.BasicCursor.prototype.getPreviousNode_ = function(a, b) {
            if (!a)
                return null;
            var c = a.prev();
            c = c ? this.getRightMostChild_(c) : a.out();
            return b(c) ? c : c ? this.getPreviousNode_(c, b) : null
        }
        ;
        hb.BasicCursor.prototype.validNode_ = function(a) {
            var b = !1;
            a = a && a.getType();
            if (a === A.ASTNode.types.OUTPUT || a === A.ASTNode.types.INPUT || a === A.ASTNode.types.FIELD || a === A.ASTNode.types.NEXT || a === A.ASTNode.types.PREVIOUS || a === A.ASTNode.types.WORKSPACE)
                b = !0;
            return b
        }
        ;
        hb.BasicCursor.prototype.findSiblingOrParent_ = function(a) {
            if (!a)
                return null;
            var b = a.next();
            return b ? b : this.findSiblingOrParent_(a.out())
        }
        ;
        hb.BasicCursor.prototype.getRightMostChild_ = function(a) {
            if (!a.in())
                return a;
            for (a = a.in(); a.next(); )
                a = a.next();
            return this.getRightMostChild_(a)
        }
        ;
        (0,
        w.register)(w.Type.CURSOR, hb.BasicCursor.registrationName, hb.BasicCursor);
        var ld = {
            TabNavigateCursor: function() {
                ld.TabNavigateCursor.superClass_.constructor.call(this)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(ld.TabNavigateCursor, hb.BasicCursor);
        ld.TabNavigateCursor.prototype.validNode_ = function(a) {
            var b = !1
              , c = a && a.getType();
            a && (a = a.getLocation(),
            c === A.ASTNode.types.FIELD && a && a.isTabNavigable() && a.isClickable() && (b = !0));
            return b
        }
        ;
        var sc = {
            Selected: function(a, b, c) {
                sc.Selected.superClass_.constructor.call(this, c);
                this.oldElementId = a;
                this.newElementId = b
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(sc.Selected, vb.UiBase);
        sc.Selected.prototype.type = k.SELECTED;
        sc.Selected.prototype.toJson = function() {
            var a = sc.Selected.superClass_.toJson.call(this);
            a.oldElementId = this.oldElementId;
            a.newElementId = this.newElementId;
            return a
        }
        ;
        sc.Selected.prototype.fromJson = function(a) {
            sc.Selected.superClass_.fromJson.call(this, a);
            this.oldElementId = a.oldElementId;
            this.newElementId = a.newElementId
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.SELECTED, sc.Selected);
        var E = {
            BlockSvg: function(a, b, c) {
                this.svgGroup_ = (0,
                n.createSvgElement)(u.G, {}, null);
                this.svgGroup_.translate_ = "";
                this.style = a.getRenderer().getConstants().getBlockStyle(null);
                this.pathObject = a.getRenderer().makePathObject(this.svgGroup_, this.style);
                this.renderIsInProgress_ = this.rendered = !1;
                this.workspace = a;
                this.previousConnection = this.nextConnection = this.outputConnection = null;
                this.useDragSurface_ = (0,
                ja.is3dSupported)() && !!a.getBlockDragSurface();
                var d = this.pathObject.svgPath;
                d.tooltip = this;
                (0,
                aa.bindMouseEvents)(d);
                E.BlockSvg.superClass_.constructor.call(this, a, b, c);
                this.svgGroup_.dataset ? this.svgGroup_.dataset.id = this.id : V.IE && this.svgGroup_.setAttribute("data-id", this.id)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(E.BlockSvg, F.Block);
        E.BlockSvg.prototype.height = 0;
        E.BlockSvg.prototype.width = 0;
        E.BlockSvg.prototype.warningTextDb_ = null;
        E.BlockSvg.INLINE = -1;
        E.BlockSvg.COLLAPSED_WARNING_ID = "TEMP_COLLAPSED_WARNING_";
        E.BlockSvg.prototype.initSvg = function() {
            if (!this.workspace.rendered)
                throw TypeError("Workspace is headless.");
            for (var a = 0, b; b = this.inputList[a]; a++)
                b.init();
            a = this.getIcons();
            for (b = 0; b < a.length; b++)
                a[b].createIcon();
            this.applyColour();
            this.pathObject.updateMovable(this.isMovable());
            a = this.getSvgRoot();
            this.workspace.options.readOnly || this.eventsInit_ || !a || (0,
            y.conditionalBind)(a, "mousedown", this, this.onMouseDown_);
            this.eventsInit_ = !0;
            a.parentNode || this.workspace.getCanvas().appendChild(a)
        }
        ;
        E.BlockSvg.prototype.getColourSecondary = function() {
            return this.style.colourSecondary
        }
        ;
        E.BlockSvg.prototype.getColourTertiary = function() {
            return this.style.colourTertiary
        }
        ;
        E.BlockSvg.prototype.select = function() {
            if (this.isShadow() && this.getParent())
                this.getParent().select();
            else if ((0,
            e.module$exports$Blockly$common.getSelected)() !== this) {
                var a = null;
                if ((0,
                e.module$exports$Blockly$common.getSelected)()) {
                    a = (0,
                    e.module$exports$Blockly$common.getSelected)().id;
                    (0,
                    k.disable)();
                    try {
                        (0,
                        e.module$exports$Blockly$common.getSelected)().unselect()
                    } finally {
                        (0,
                        k.enable)()
                    }
                }
                a = new ((0,
                k.get)(k.SELECTED))(a,this.id,this.workspace.id);
                (0,
                k.fire)(a);
                (0,
                e.module$exports$Blockly$common.setSelected)(this);
                this.addSelect()
            }
        }
        ;
        E.BlockSvg.prototype.unselect = function() {
            if ((0,
            e.module$exports$Blockly$common.getSelected)() === this) {
                var a = new ((0,
                k.get)(k.SELECTED))(this.id,null,this.workspace.id);
                a.workspaceId = this.workspace.id;
                (0,
                k.fire)(a);
                (0,
                e.module$exports$Blockly$common.setSelected)(null);
                this.removeSelect()
            }
        }
        ;
        E.BlockSvg.prototype.mutator = null;
        E.BlockSvg.prototype.comment = null;
        E.BlockSvg.prototype.commentIcon_ = null;
        E.BlockSvg.prototype.warning = null;
        E.BlockSvg.prototype.getIcons = function() {
            var a = [];
            this.mutator && a.push(this.mutator);
            this.commentIcon_ && a.push(this.commentIcon_);
            this.warning && a.push(this.warning);
            return a
        }
        ;
        E.BlockSvg.prototype.setParent = function(a) {
            var b = this.parentBlock_;
            if (a !== b) {
                (0,
                n.startTextWidthCache)();
                E.BlockSvg.superClass_.setParent.call(this, a);
                (0,
                n.stopTextWidthCache)();
                var c = this.getSvgRoot();
                if (!this.workspace.isClearing && c) {
                    var d = this.getRelativeToSurfaceXY();
                    a ? (a.getSvgRoot().appendChild(c),
                    a = this.getRelativeToSurfaceXY(),
                    this.moveConnections(a.x - d.x, a.y - d.y)) : b && (this.workspace.getCanvas().appendChild(c),
                    this.translate(d.x, d.y));
                    this.applyColour()
                }
            }
        }
        ;
        E.BlockSvg.prototype.getRelativeToSurfaceXY = function() {
            var a = 0
              , b = 0
              , c = this.useDragSurface_ ? this.workspace.getBlockDragSurface().getGroup() : null
              , d = this.getSvgRoot();
            if (d) {
                do {
                    var f = (0,
                    ja.getRelativeXY)(d);
                    a += f.x;
                    b += f.y;
                    this.useDragSurface_ && this.workspace.getBlockDragSurface().getCurrentBlock() === d && (f = this.workspace.getBlockDragSurface().getSurfaceTranslation(),
                    a += f.x,
                    b += f.y);
                    d = d.parentNode
                } while (d && d !== this.workspace.getCanvas() && d !== c)
            }
            return new J(a,b)
        }
        ;
        E.BlockSvg.prototype.moveBy = function(a, b) {
            if (this.parentBlock_)
                throw Error("Block has parent.");
            var c = (0,
            k.isEnabled)(), d;
            c && (d = new ((0,
            k.get)(k.MOVE))(this));
            var f = this.getRelativeToSurfaceXY();
            this.translate(f.x + a, f.y + b);
            this.moveConnections(a, b);
            c && (d.recordNew(),
            (0,
            k.fire)(d));
            this.workspace.resizeContents()
        }
        ;
        E.BlockSvg.prototype.translate = function(a, b) {
            this.getSvgRoot().setAttribute("transform", "translate(" + a + "," + b + ")")
        }
        ;
        E.BlockSvg.prototype.moveToDragSurface = function() {
            if (this.useDragSurface_) {
                var a = this.getRelativeToSurfaceXY();
                this.clearTransformAttributes_();
                this.workspace.getBlockDragSurface().translateSurface(a.x, a.y);
                (a = this.getSvgRoot()) && this.workspace.getBlockDragSurface().setBlocksAndShow(a)
            }
        }
        ;
        E.BlockSvg.prototype.moveTo = function(a) {
            var b = this.getRelativeToSurfaceXY();
            this.moveBy(a.x - b.x, a.y - b.y)
        }
        ;
        E.BlockSvg.prototype.moveOffDragSurface = function(a) {
            this.useDragSurface_ && (this.translate(a.x, a.y),
            this.workspace.getBlockDragSurface().clearAndHide(this.workspace.getCanvas()))
        }
        ;
        E.BlockSvg.prototype.moveDuringDrag = function(a) {
            this.useDragSurface_ ? this.workspace.getBlockDragSurface().translateSurface(a.x, a.y) : (this.svgGroup_.translate_ = "translate(" + a.x + "," + a.y + ")",
            this.svgGroup_.setAttribute("transform", this.svgGroup_.translate_ + this.svgGroup_.skew_))
        }
        ;
        E.BlockSvg.prototype.clearTransformAttributes_ = function() {
            this.getSvgRoot().removeAttribute("transform")
        }
        ;
        E.BlockSvg.prototype.snapToGrid = function() {
            if (this.workspace && !this.workspace.isDragging() && !this.getParent() && !this.isInFlyout) {
                var a = this.workspace.getGrid();
                if (a && a.shouldSnap()) {
                    var b = a.getSpacing()
                      , c = b / 2
                      , d = this.getRelativeToSurfaceXY();
                    a = Math.round(Math.round((d.x - c) / b) * b + c - d.x);
                    b = Math.round(Math.round((d.y - c) / b) * b + c - d.y);
                    (a || b) && this.moveBy(a, b)
                }
            }
        }
        ;
        E.BlockSvg.prototype.getBoundingRectangle = function() {
            var a = this.getRelativeToSurfaceXY()
              , b = this.getHeightWidth();
            if (this.RTL)
                var c = a.x - b.width
                  , d = a.x;
            else
                c = a.x,
                d = a.x + b.width;
            return new Ha(a.y,a.y + b.height,c,d)
        }
        ;
        E.BlockSvg.prototype.markDirty = function() {
            this.pathObject.constants = this.workspace.getRenderer().getConstants();
            for (var a = 0, b; b = this.inputList[a]; a++)
                b.markDirty()
        }
        ;
        E.BlockSvg.prototype.setCollapsed = function(a) {
            this.collapsed_ !== a && (E.BlockSvg.superClass_.setCollapsed.call(this, a),
            a ? this.rendered && this.render() : this.updateCollapsed_())
        }
        ;
        E.BlockSvg.prototype.updateCollapsed_ = function() {
            for (var a = this.isCollapsed(), b = lc.COLLAPSED_INPUT_NAME, c = lc.COLLAPSED_FIELD_NAME, d = 0, f; f = this.inputList[d]; d++)
                f.name !== b && f.setVisible(!a);
            if (a) {
                a = this.getIcons();
                for (d = 0; f = a[d]; d++)
                    f.setVisible(!1);
                a = this.toString(e.module$exports$Blockly$internalConstants.COLLAPSE_CHARS);
                (d = this.getField(c)) ? d.setValue(a) : (this.getInput(b) || this.appendDummyInput(b)).appendField(new e.module$exports$Blockly$FieldLabel.FieldLabel(a), c)
            } else
                this.updateDisabled(),
                this.removeInput(b)
        }
        ;
        E.BlockSvg.prototype.tab = function(a, b) {
            var c = new ld.TabNavigateCursor;
            c.setCurNode(A.ASTNode.createFieldNode(a));
            a = c.getCurNode();
            b ? c.next() : c.prev();
            (b = c.getCurNode()) && b !== a && (b.getLocation().showEditor(),
            this.workspace.keyboardAccessibilityMode && this.workspace.getCursor().setCurNode(b))
        }
        ;
        E.BlockSvg.prototype.onMouseDown_ = function(a) {
            var b = this.workspace && this.workspace.getGesture(a);
            b && b.handleBlockStart(a, this)
        }
        ;
        E.BlockSvg.prototype.showHelp = function() {
            var a = "function" === typeof this.helpUrl ? this.helpUrl() : this.helpUrl;
            a && window.open(a)
        }
        ;
        E.BlockSvg.prototype.generateContextMenu = function() {
            if (this.workspace.options.readOnly || !this.contextMenu)
                return null;
            var a = ia.ContextMenuRegistry.registry.getContextMenuOptions(ia.ContextMenuRegistry.ScopeType.BLOCK, {
                block: this
            });
            this.customContextMenu && this.customContextMenu(a);
            return a
        }
        ;
        E.BlockSvg.prototype.showContextMenu = function(a) {
            var b = this.generateContextMenu();
            b && b.length && ((0,
            e.module$exports$Blockly$ContextMenu.show)(a, b, this.RTL),
            (0,
            e.module$exports$Blockly$ContextMenu.setCurrentBlock)(this))
        }
        ;
        E.BlockSvg.prototype.moveConnections = function(a, b) {
            if (this.rendered) {
                for (var c = this.getConnections_(!1), d = 0; d < c.length; d++)
                    c[d].moveBy(a, b);
                c = this.getIcons();
                for (d = 0; d < c.length; d++)
                    c[d].computeIconLocation();
                for (c = 0; c < this.childBlocks_.length; c++)
                    this.childBlocks_[c].moveConnections(a, b)
            }
        }
        ;
        E.BlockSvg.prototype.setDragging = function(a) {
            if (a) {
                var b = this.getSvgRoot();
                b.translate_ = "";
                b.skew_ = "";
                e.module$exports$Blockly$common.draggingConnections.push.apply(e.module$exports$Blockly$common.draggingConnections, z.arrayFromIterable(this.getConnections_(!0)));
                (0,
                n.addClass)(this.svgGroup_, "blocklyDragging")
            } else
                e.module$exports$Blockly$common.draggingConnections.length = 0,
                (0,
                n.removeClass)(this.svgGroup_, "blocklyDragging");
            for (b = 0; b < this.childBlocks_.length; b++)
                this.childBlocks_[b].setDragging(a)
        }
        ;
        E.BlockSvg.prototype.setMovable = function(a) {
            E.BlockSvg.superClass_.setMovable.call(this, a);
            this.pathObject.updateMovable(a)
        }
        ;
        E.BlockSvg.prototype.setEditable = function(a) {
            E.BlockSvg.superClass_.setEditable.call(this, a);
            a = this.getIcons();
            for (var b = 0; b < a.length; b++)
                a[b].updateEditable()
        }
        ;
        E.BlockSvg.prototype.setShadow = function(a) {
            E.BlockSvg.superClass_.setShadow.call(this, a);
            this.applyColour()
        }
        ;
        E.BlockSvg.prototype.setInsertionMarker = function(a) {
            this.isInsertionMarker_ !== a && (this.isInsertionMarker_ = a) && (this.setColour(this.workspace.getRenderer().getConstants().INSERTION_MARKER_COLOUR),
            this.pathObject.updateInsertionMarker(!0))
        }
        ;
        E.BlockSvg.prototype.getSvgRoot = function() {
            return this.svgGroup_
        }
        ;
        E.BlockSvg.prototype.dispose = function(a, b) {
            if (this.workspace) {
                (0,
                aa.dispose)();
                (0,
                aa.unbindMouseEvents)(this.pathObject.svgPath);
                (0,
                n.startTextWidthCache)();
                var c = this.workspace;
                (0,
                e.module$exports$Blockly$common.getSelected)() === this && (this.unselect(),
                this.workspace.cancelCurrentGesture());
                (0,
                e.module$exports$Blockly$ContextMenu.getCurrentBlock)() === this && (0,
                e.module$exports$Blockly$ContextMenu.hide)();
                b && this.rendered && (this.unplug(a),
                (0,
                Pb.disposeUiEffect)(this));
                this.rendered = !1;
                if (this.warningTextDb_) {
                    for (var d in this.warningTextDb_)
                        clearTimeout(this.warningTextDb_[d]);
                    this.warningTextDb_ = null
                }
                b = this.getIcons();
                for (d = 0; d < b.length; d++)
                    b[d].dispose();
                E.BlockSvg.superClass_.dispose.call(this, !!a);
                (0,
                n.removeNode)(this.svgGroup_);
                c.resizeContents();
                this.svgGroup_ = null;
                (0,
                n.stopTextWidthCache)()
            }
        }
        ;
        E.BlockSvg.prototype.checkAndDelete = function() {
            this.workspace.isFlyout || ((0,
            k.setGroup)(!0),
            this.workspace.hideChaff(),
            this.outputConnection ? this.dispose(!1, !0) : this.dispose(!0, !0),
            (0,
            k.setGroup)(!1))
        }
        ;
        E.BlockSvg.prototype.toCopyData = function() {
            return this.isInsertionMarker_ ? null : {
                saveInfo: (0,
                Ya.save)(this, {
                    addCoordinates: !0,
                    addNextBlocks: !1
                }),
                source: this.workspace,
                typeCounts: (0,
                e.module$exports$Blockly$common.getBlockTypeCounts)(this, !0)
            }
        }
        ;
        E.BlockSvg.prototype.applyColour = function() {
            this.pathObject.applyColour(this);
            for (var a = this.getIcons(), b = 0; b < a.length; b++)
                a[b].applyColour();
            for (a = 0; b = this.inputList[a]; a++)
                for (var c = 0, d; d = b.fieldRow[c]; c++)
                    d.applyColour()
        }
        ;
        E.BlockSvg.prototype.updateDisabled = function() {
            var a = this.getChildren(!1);
            this.applyColour();
            if (!this.isCollapsed())
                for (var b = 0, c; c = a[b]; b++)
                    c.rendered && c.updateDisabled()
        }
        ;
        E.BlockSvg.prototype.getCommentIcon = function() {
            return this.commentIcon_
        }
        ;
        E.BlockSvg.prototype.setCommentText = function(a) {
            var b = Qa.Comment;
            if (!b)
                throw Error("Missing require for Blockly.Comment");
            this.commentModel.text !== a && (E.BlockSvg.superClass_.setCommentText.call(this, a),
            a = null !== a,
            !!this.commentIcon_ === a ? this.commentIcon_.updateText() : (a ? this.comment = this.commentIcon_ = new b(this) : (this.commentIcon_.dispose(),
            this.comment = this.commentIcon_ = null),
            this.rendered && (this.render(),
            this.bumpNeighbours())))
        }
        ;
        E.BlockSvg.prototype.setWarningText = function(a, b) {
            var c = Hb.Warning;
            if (!c)
                throw Error("Missing require for Blockly.Warning");
            this.warningTextDb_ || (this.warningTextDb_ = Object.create(null));
            var d = b || "";
            if (d)
                this.warningTextDb_[d] && (clearTimeout(this.warningTextDb_[d]),
                delete this.warningTextDb_[d]);
            else {
                b = z.makeIterator(Object.keys(this.warningTextDb_));
                for (var f = b.next(); !f.done; f = b.next())
                    f = f.value,
                    clearTimeout(this.warningTextDb_[f]),
                    delete this.warningTextDb_[f]
            }
            if (this.workspace.isDragging()) {
                var g = this;
                this.warningTextDb_[d] = setTimeout(function() {
                    g.workspace && (delete g.warningTextDb_[d],
                    g.setWarningText(a, d))
                }, 100)
            } else {
                this.isInFlyout && (a = null);
                b = !1;
                if ("string" === typeof a) {
                    f = this.getSurroundParent();
                    for (var m = null; f; )
                        f.isCollapsed() && (m = f),
                        f = f.getSurroundParent();
                    m && m.setWarningText(e.module$exports$Blockly$Msg.Msg.COLLAPSED_WARNINGS_WARNING, E.BlockSvg.COLLAPSED_WARNING_ID);
                    this.warning || (this.warning = new c(this),
                    b = !0);
                    this.warning.setText(a, d)
                } else
                    this.warning && !d ? (this.warning.dispose(),
                    b = !0) : this.warning && (c = this.warning.getText(),
                    this.warning.setText("", d),
                    (b = this.warning.getText()) || this.warning.dispose(),
                    b = c !== b);
                b && this.rendered && (this.render(),
                this.bumpNeighbours())
            }
        }
        ;
        E.BlockSvg.prototype.setMutator = function(a) {
            this.mutator && this.mutator !== a && this.mutator.dispose();
            a && (a.setBlock(this),
            this.mutator = a,
            a.createIcon());
            this.rendered && (this.render(),
            this.bumpNeighbours())
        }
        ;
        E.BlockSvg.prototype.setEnabled = function(a) {
            this.isEnabled() !== a && (E.BlockSvg.superClass_.setEnabled.call(this, a),
            this.rendered && !this.getInheritedDisabled() && this.updateDisabled())
        }
        ;
        E.BlockSvg.prototype.setHighlighted = function(a) {
            this.rendered && this.pathObject.updateHighlighted(a)
        }
        ;
        E.BlockSvg.prototype.addSelect = function() {
            this.pathObject.updateSelected(!0)
        }
        ;
        E.BlockSvg.prototype.removeSelect = function() {
            this.pathObject.updateSelected(!1)
        }
        ;
        E.BlockSvg.prototype.setDeleteStyle = function(a) {
            this.pathObject.updateDraggingDelete(a)
        }
        ;
        E.BlockSvg.prototype.getColour = function() {
            return this.style.colourPrimary
        }
        ;
        E.BlockSvg.prototype.setColour = function(a) {
            E.BlockSvg.superClass_.setColour.call(this, a);
            a = this.workspace.getRenderer().getConstants().getBlockStyleForColour(this.colour_);
            this.pathObject.setStyle(a.style);
            this.style = a.style;
            this.styleName_ = a.name;
            this.applyColour()
        }
        ;
        E.BlockSvg.prototype.setStyle = function(a) {
            var b = this.workspace.getRenderer().getConstants().getBlockStyle(a);
            this.styleName_ = a;
            if (b)
                this.hat = b.hat,
                this.pathObject.setStyle(b),
                this.colour_ = b.colourPrimary,
                this.style = b,
                this.applyColour();
            else
                throw Error("Invalid style name: " + a);
        }
        ;
        E.BlockSvg.prototype.bringToFront = function() {
            var a = this;
            do {
                var b = a.getSvgRoot()
                  , c = b.parentNode
                  , d = c.childNodes;
                d[d.length - 1] !== b && c.appendChild(b);
                a = a.getParent()
            } while (a)
        }
        ;
        E.BlockSvg.prototype.setPreviousStatement = function(a, b) {
            E.BlockSvg.superClass_.setPreviousStatement.call(this, a, b);
            this.rendered && (this.render(),
            this.bumpNeighbours())
        }
        ;
        E.BlockSvg.prototype.setNextStatement = function(a, b) {
            E.BlockSvg.superClass_.setNextStatement.call(this, a, b);
            this.rendered && (this.render(),
            this.bumpNeighbours())
        }
        ;
        E.BlockSvg.prototype.setOutput = function(a, b) {
            E.BlockSvg.superClass_.setOutput.call(this, a, b);
            this.rendered && (this.render(),
            this.bumpNeighbours())
        }
        ;
        E.BlockSvg.prototype.setInputsInline = function(a) {
            E.BlockSvg.superClass_.setInputsInline.call(this, a);
            this.rendered && (this.render(),
            this.bumpNeighbours())
        }
        ;
        E.BlockSvg.prototype.removeInput = function(a, b) {
            a = E.BlockSvg.superClass_.removeInput.call(this, a, b);
            this.rendered && (this.render(),
            this.bumpNeighbours());
            return a
        }
        ;
        E.BlockSvg.prototype.moveNumberedInputBefore = function(a, b) {
            E.BlockSvg.superClass_.moveNumberedInputBefore.call(this, a, b);
            this.rendered && (this.render(),
            this.bumpNeighbours())
        }
        ;
        E.BlockSvg.prototype.appendInput_ = function(a, b) {
            a = E.BlockSvg.superClass_.appendInput_.call(this, a, b);
            this.rendered && (this.render(),
            this.bumpNeighbours());
            return a
        }
        ;
        E.BlockSvg.prototype.setConnectionTracking = function(a) {
            this.previousConnection && this.previousConnection.setTracking(a);
            this.outputConnection && this.outputConnection.setTracking(a);
            if (this.nextConnection) {
                this.nextConnection.setTracking(a);
                var b = this.nextConnection.targetBlock();
                b && b.setConnectionTracking(a)
            }
            if (!this.collapsed_)
                for (b = 0; b < this.inputList.length; b++) {
                    var c = this.inputList[b].connection;
                    c && (c.setTracking(a),
                    (c = c.targetBlock()) && c.setConnectionTracking(a))
                }
        }
        ;
        E.BlockSvg.prototype.getConnections_ = function(a) {
            var b = [];
            if (a || this.rendered)
                if (this.outputConnection && b.push(this.outputConnection),
                this.previousConnection && b.push(this.previousConnection),
                this.nextConnection && b.push(this.nextConnection),
                a || !this.collapsed_) {
                    a = 0;
                    for (var c; c = this.inputList[a]; a++)
                        c.connection && b.push(c.connection)
                }
            return b
        }
        ;
        E.BlockSvg.prototype.lastConnectionInStack = function(a) {
            return E.BlockSvg.superClass_.lastConnectionInStack.call(this, a)
        }
        ;
        E.BlockSvg.prototype.getMatchingConnection = function(a, b) {
            return E.BlockSvg.superClass_.getMatchingConnection.call(this, a, b)
        }
        ;
        E.BlockSvg.prototype.makeConnection_ = function(a) {
            return new ea.RenderedConnection(this,a)
        }
        ;
        E.BlockSvg.prototype.bumpNeighbours = function() {
            if (this.workspace && !this.workspace.isDragging()) {
                var a = this.getRootBlock();
                if (!a.isInFlyout)
                    for (var b = this.getConnections_(!1), c = 0, d; d = b[c]; c++) {
                        d.isConnected() && d.isSuperior() && d.targetBlock().bumpNeighbours();
                        for (var f = d.neighbours(e.module$exports$Blockly$internalConstants.SNAP_RADIUS), g = 0, m; m = f[g]; g++)
                            d.isConnected() && m.isConnected() || m.getSourceBlock().getRootBlock() !== a && (d.isSuperior() ? m.bumpAwayFrom(d) : d.bumpAwayFrom(m))
                    }
            }
        }
        ;
        E.BlockSvg.prototype.scheduleSnapAndBump = function() {
            var a = this
              , b = (0,
            k.getGroup)();
            setTimeout(function() {
                (0,
                k.setGroup)(b);
                a.snapToGrid();
                (0,
                k.setGroup)(!1)
            }, e.module$exports$Blockly$internalConstants.BUMP_DELAY / 2);
            setTimeout(function() {
                (0,
                k.setGroup)(b);
                a.bumpNeighbours();
                (0,
                k.setGroup)(!1)
            }, e.module$exports$Blockly$internalConstants.BUMP_DELAY)
        }
        ;
        E.BlockSvg.prototype.positionNearConnection = function(a, b) {
            a.type !== e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT && a.type !== e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE || this.moveBy(b.x - a.x, b.y - a.y)
        }
        ;
        E.BlockSvg.prototype.getParent = function() {
            return E.BlockSvg.superClass_.getParent.call(this)
        }
        ;
        E.BlockSvg.prototype.getRootBlock = function() {
            return E.BlockSvg.superClass_.getRootBlock.call(this)
        }
        ;
        E.BlockSvg.prototype.render = function(a) {
            if (!this.renderIsInProgress_) {
                this.renderIsInProgress_ = !0;
                try {
                    this.rendered = !0;
                    (0,
                    n.startTextWidthCache)();
                    this.isCollapsed() && this.updateCollapsed_();
                    this.workspace.getRenderer().render(this);
                    this.updateConnectionLocations_();
                    if (!1 !== a) {
                        var b = this.getParent();
                        b ? b.render(!0) : this.workspace.resizeContents()
                    }
                    (0,
                    n.stopTextWidthCache)();
                    this.updateMarkers_()
                } finally {
                    this.renderIsInProgress_ = !1
                }
            }
        }
        ;
        E.BlockSvg.prototype.updateMarkers_ = function() {
            this.workspace.keyboardAccessibilityMode && this.pathObject.cursorSvg && this.workspace.getCursor().draw();
            this.workspace.keyboardAccessibilityMode && this.pathObject.markerSvg && this.workspace.getMarker(ub.LOCAL_MARKER).draw()
        }
        ;
        E.BlockSvg.prototype.updateConnectionLocations_ = function() {
            var a = this.getRelativeToSurfaceXY();
            this.previousConnection && this.previousConnection.moveToOffset(a);
            this.outputConnection && this.outputConnection.moveToOffset(a);
            for (var b = 0; b < this.inputList.length; b++) {
                var c = this.inputList[b].connection;
                c && (c.moveToOffset(a),
                c.isConnected() && c.tighten())
            }
            this.nextConnection && (this.nextConnection.moveToOffset(a),
            this.nextConnection.isConnected() && this.nextConnection.tighten())
        }
        ;
        E.BlockSvg.prototype.setCursorSvg = function(a) {
            this.pathObject.setCursorSvg(a)
        }
        ;
        E.BlockSvg.prototype.setMarkerSvg = function(a) {
            this.pathObject.setMarkerSvg(a)
        }
        ;
        E.BlockSvg.prototype.getHeightWidth = function() {
            var a = this.height
              , b = this.width
              , c = this.getNextBlock();
            if (c) {
                c = c.getHeightWidth();
                var d = this.workspace.getRenderer().getConstants().NOTCH_HEIGHT;
                a += c.height - d;
                b = Math.max(b, c.width)
            }
            return {
                height: a,
                width: b
            }
        }
        ;
        E.BlockSvg.prototype.fadeForReplacement = function(a) {
            this.pathObject.updateReplacementFade(a)
        }
        ;
        E.BlockSvg.prototype.highlightShapeForInput = function(a, b) {
            this.pathObject.updateShapeForInputHighlight(a, b)
        }
        ;
        var wb = function(a) {
            this.connections_ = [];
            this.connectionChecker_ = a
        };
        wb.prototype.addConnection = function(a, b) {
            b = this.calculateIndexForYPos_(b);
            this.connections_.splice(b, 0, a)
        }
        ;
        wb.prototype.findIndexOfConnection_ = function(a, b) {
            if (!this.connections_.length)
                return -1;
            var c = this.calculateIndexForYPos_(b);
            if (c >= this.connections_.length)
                return -1;
            b = a.y;
            for (var d = c; 0 <= d && this.connections_[d].y === b; ) {
                if (this.connections_[d] === a)
                    return d;
                d--
            }
            for (d = c; d < this.connections_.length && this.connections_[d].y === b; ) {
                if (this.connections_[d] === a)
                    return d;
                d++
            }
            return -1
        }
        ;
        wb.prototype.calculateIndexForYPos_ = function(a) {
            if (!this.connections_.length)
                return 0;
            for (var b = 0, c = this.connections_.length; b < c; ) {
                var d = Math.floor((b + c) / 2);
                if (this.connections_[d].y < a)
                    b = d + 1;
                else if (this.connections_[d].y > a)
                    c = d;
                else {
                    b = d;
                    break
                }
            }
            return b
        }
        ;
        wb.prototype.removeConnection = function(a, b) {
            a = this.findIndexOfConnection_(a, b);
            if (-1 === a)
                throw Error("Unable to find connection in connectionDB.");
            this.connections_.splice(a, 1)
        }
        ;
        wb.prototype.getNeighbours = function(a, b) {
            function c(G) {
                var W = f - d[G].x
                  , ra = g - d[G].y;
                Math.sqrt(W * W + ra * ra) <= b && B.push(d[G]);
                return ra < b
            }
            var d = this.connections_
              , f = a.x
              , g = a.y;
            a = 0;
            for (var m = d.length - 2, r = m; a < r; )
                d[r].y < g ? a = r : m = r,
                r = Math.floor((a + m) / 2);
            var B = [];
            m = a = r;
            if (d.length) {
                for (; 0 <= a && c(a); )
                    a--;
                do
                    m++;
                while (m < d.length && c(m))
            }
            return B
        }
        ;
        wb.prototype.isInYRange_ = function(a, b, c) {
            return Math.abs(this.connections_[a].y - b) <= c
        }
        ;
        wb.prototype.searchForClosest = function(a, b, c) {
            if (!this.connections_.length)
                return {
                    connection: null,
                    radius: b
                };
            var d = a.y
              , f = a.x;
            a.x = f + c.x;
            a.y = d + c.y;
            var g = this.calculateIndexForYPos_(a.y);
            c = null;
            for (var m = b, r, B = g - 1; 0 <= B && this.isInYRange_(B, a.y, b); )
                r = this.connections_[B],
                this.connectionChecker_.canConnect(a, r, !0, m) && (c = r,
                m = r.distanceFrom(a)),
                B--;
            for (; g < this.connections_.length && this.isInYRange_(g, a.y, b); )
                r = this.connections_[g],
                this.connectionChecker_.canConnect(a, r, !0, m) && (c = r,
                m = r.distanceFrom(a)),
                g++;
            a.x = f;
            a.y = d;
            return {
                connection: c,
                radius: m
            }
        }
        ;
        wb.init = function(a) {
            var b = [];
            b[e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE] = new wb(a);
            b[e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE] = new wb(a);
            b[e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT] = new wb(a);
            b[e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT] = new wb(a);
            return b
        }
        ;
        var tc = function(a, b) {
            this.workspace_ = a;
            this.theme_ = b;
            this.subscribedWorkspaces_ = [];
            this.componentDB_ = Object.create(null)
        };
        tc.prototype.getTheme = function() {
            return this.theme_
        }
        ;
        tc.prototype.setTheme = function(a) {
            var b = this.theme_;
            this.theme_ = a;
            if (a = this.workspace_.getInjectionDiv())
                b && (0,
                n.removeClass)(a, b.getClassName()),
                (0,
                n.addClass)(a, this.theme_.getClassName());
            for (b = 0; a = this.subscribedWorkspaces_[b]; b++)
                a.refreshTheme();
            b = 0;
            a = Object.keys(this.componentDB_);
            for (var c; c = a[b]; b++)
                for (var d = 0, f; f = this.componentDB_[c][d]; d++) {
                    var g = f.element;
                    f = f.propertyName;
                    var m = this.theme_ && this.theme_.getComponentStyle(c);
                    g.style[f] = m || ""
                }
            b = z.makeIterator(this.subscribedWorkspaces_);
            for (a = b.next(); !a.done; a = b.next())
                a.value.hideChaff()
        }
        ;
        tc.prototype.subscribeWorkspace = function(a) {
            this.subscribedWorkspaces_.push(a)
        }
        ;
        tc.prototype.unsubscribeWorkspace = function(a) {
            if (!(0,
            zb)(this.subscribedWorkspaces_, a))
                throw Error("Cannot unsubscribe a workspace that hasn't been subscribed.");
        }
        ;
        tc.prototype.subscribe = function(a, b, c) {
            this.componentDB_[b] || (this.componentDB_[b] = []);
            this.componentDB_[b].push({
                element: a,
                propertyName: c
            });
            b = this.theme_ && this.theme_.getComponentStyle(b);
            a.style[c] = b || ""
        }
        ;
        tc.prototype.unsubscribe = function(a) {
            if (a)
                for (var b = Object.keys(this.componentDB_), c = 0, d; d = b[c]; c++) {
                    for (var f = this.componentDB_[d], g = f.length - 1; 0 <= g; g--)
                        f[g].element === a && f.splice(g, 1);
                    this.componentDB_[d].length || delete this.componentDB_[d]
                }
        }
        ;
        tc.prototype.dispose = function() {
            this.componentDB_ = this.subscribedWorkspaces_ = this.theme_ = this.owner_ = null
        }
        ;
        var ya = {
            TouchGesture: function(a, b) {
                ya.TouchGesture.superClass_.constructor.call(this, a, b);
                this.isMultiTouch_ = !1;
                this.cachedPoints_ = Object.create(null);
                this.startDistance_ = this.previousScale_ = 0;
                this.isPinchZoomEnabled_ = this.onStartWrapper_ = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(ya.TouchGesture, ba);
        ya.TouchGesture.ZOOM_IN_MULTIPLIER = 5;
        ya.TouchGesture.ZOOM_OUT_MULTIPLIER = 6;
        ya.TouchGesture.prototype.doStart = function(a) {
            this.isPinchZoomEnabled_ = this.startWorkspace_.options.zoomOptions && this.startWorkspace_.options.zoomOptions.pinch;
            ya.TouchGesture.superClass_.doStart.call(this, a);
            !this.isEnding_ && (0,
            O.isTouchEvent)(a) && this.handleTouchStart(a)
        }
        ;
        ya.TouchGesture.prototype.bindMouseEvents = function(a) {
            this.onStartWrapper_ = (0,
            y.conditionalBind)(document, "mousedown", null, this.handleStart.bind(this), !0);
            this.onMoveWrapper_ = (0,
            y.conditionalBind)(document, "mousemove", null, this.handleMove.bind(this), !0);
            this.onUpWrapper_ = (0,
            y.conditionalBind)(document, "mouseup", null, this.handleUp.bind(this), !0);
            a.preventDefault();
            a.stopPropagation()
        }
        ;
        ya.TouchGesture.prototype.handleStart = function(a) {
            !this.isDragging() && (0,
            O.isTouchEvent)(a) && (this.handleTouchStart(a),
            this.isMultiTouch() && (0,
            O.longStop)())
        }
        ;
        ya.TouchGesture.prototype.handleMove = function(a) {
            this.isDragging() ? (0,
            O.shouldHandleEvent)(a) && ya.TouchGesture.superClass_.handleMove.call(this, a) : this.isMultiTouch() ? ((0,
            O.isTouchEvent)(a) && this.handleTouchMove(a),
            (0,
            O.longStop)()) : ya.TouchGesture.superClass_.handleMove.call(this, a)
        }
        ;
        ya.TouchGesture.prototype.handleUp = function(a) {
            (0,
            O.isTouchEvent)(a) && !this.isDragging() && this.handleTouchEnd(a);
            !this.isMultiTouch() || this.isDragging() ? (0,
            O.shouldHandleEvent)(a) && ya.TouchGesture.superClass_.handleUp.call(this, a) : (a.preventDefault(),
            a.stopPropagation(),
            this.dispose())
        }
        ;
        ya.TouchGesture.prototype.isMultiTouch = function() {
            return this.isMultiTouch_
        }
        ;
        ya.TouchGesture.prototype.dispose = function() {
            ya.TouchGesture.superClass_.dispose.call(this);
            this.onStartWrapper_ && (0,
            y.unbind)(this.onStartWrapper_)
        }
        ;
        ya.TouchGesture.prototype.handleTouchStart = function(a) {
            var b = (0,
            O.getTouchIdentifierFromEvent)(a);
            this.cachedPoints_[b] = this.getTouchPoint(a);
            b = Object.keys(this.cachedPoints_);
            2 === b.length && (this.startDistance_ = J.distance(this.cachedPoints_[b[0]], this.cachedPoints_[b[1]]),
            this.isMultiTouch_ = !0,
            a.preventDefault())
        }
        ;
        ya.TouchGesture.prototype.handleTouchMove = function(a) {
            var b = (0,
            O.getTouchIdentifierFromEvent)(a);
            this.cachedPoints_[b] = this.getTouchPoint(a);
            b = Object.keys(this.cachedPoints_);
            this.isPinchZoomEnabled_ && 2 === b.length ? this.handlePinch_(a) : ya.TouchGesture.superClass_.handleMove.call(this, a)
        }
        ;
        ya.TouchGesture.prototype.handlePinch_ = function(a) {
            var b = Object.keys(this.cachedPoints_);
            b = J.distance(this.cachedPoints_[b[0]], this.cachedPoints_[b[1]]) / this.startDistance_;
            if (0 < this.previousScale_ && Infinity > this.previousScale_) {
                var c = b - this.previousScale_;
                c = 0 < c ? c * ya.TouchGesture.ZOOM_IN_MULTIPLIER : c * ya.TouchGesture.ZOOM_OUT_MULTIPLIER;
                var d = this.startWorkspace_
                  , f = (0,
                y.mouseToSvg)(a, d.getParentSvg(), d.getInverseScreenCTM());
                d.zoom(f.x, f.y, c)
            }
            this.previousScale_ = b;
            a.preventDefault()
        }
        ;
        ya.TouchGesture.prototype.handleTouchEnd = function(a) {
            a = (0,
            O.getTouchIdentifierFromEvent)(a);
            this.cachedPoints_[a] && delete this.cachedPoints_[a];
            2 > Object.keys(this.cachedPoints_).length && (this.cachedPoints_ = Object.create(null),
            this.previousScale_ = 0)
        }
        ;
        ya.TouchGesture.prototype.getTouchPoint = function(a) {
            return this.startWorkspace_ ? new J(a.changedTouches ? a.changedTouches[0].pageX : a.pageX,a.changedTouches ? a.changedTouches[0].pageY : a.pageY) : null
        }
        ;
        var Lc = function(a) {
            this.parentWorkspace_ = a;
            this.SOUNDS_ = Object.create(null)
        };
        Lc.prototype.lastSound_ = null;
        Lc.prototype.dispose = function() {
            this.SOUNDS_ = this.parentWorkspace_ = null
        }
        ;
        Lc.prototype.load = function(a, b) {
            if (a.length) {
                try {
                    var c = new e.module$exports$Blockly$utils$global.globalThis.Audio
                } catch (r) {
                    return
                }
                for (var d, f = 0; f < a.length; f++) {
                    var g = a[f]
                      , m = g.match(/\.(\w+)$/);
                    if (m && c.canPlayType("audio/" + m[1])) {
                        d = new e.module$exports$Blockly$utils$global.globalThis.Audio(g);
                        break
                    }
                }
                d && d.play && (this.SOUNDS_[b] = d)
            }
        }
        ;
        Lc.prototype.preload = function() {
            for (var a in this.SOUNDS_) {
                var b = this.SOUNDS_[a];
                b.volume = .01;
                var c = b.play();
                void 0 !== c ? c.then(b.pause).catch(function() {}) : b.pause();
                if (V.IPAD || V.IPHONE)
                    break
            }
        }
        ;
        Lc.prototype.play = function(a, b) {
            var c = this.SOUNDS_[a];
            c ? (a = new Date,
            null !== this.lastSound_ && a - this.lastSound_ < e.module$exports$Blockly$internalConstants.SOUND_LIMIT || (this.lastSound_ = a,
            c = V.IPAD || V.ANDROID ? c : c.cloneNode(),
            c.volume = void 0 === b ? 1 : b,
            c.play())) : this.parentWorkspace_ && this.parentWorkspace_.getAudioManager().play(a, b)
        }
        ;
        var uc = {
            ThemeChange: function(a, b) {
                uc.ThemeChange.superClass_.constructor.call(this, b);
                this.themeName = a
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(uc.ThemeChange, vb.UiBase);
        uc.ThemeChange.prototype.type = k.THEME_CHANGE;
        uc.ThemeChange.prototype.toJson = function() {
            var a = uc.ThemeChange.superClass_.toJson.call(this);
            a.themeName = this.themeName;
            return a
        }
        ;
        uc.ThemeChange.prototype.fromJson = function(a) {
            uc.ThemeChange.superClass_.fromJson.call(this, a);
            this.themeName = a.themeName
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.THEME_CHANGE, uc.ThemeChange);
        var vc = {
            ViewportChange: function(a, b, c, d, f) {
                vc.ViewportChange.superClass_.constructor.call(this, d);
                this.viewTop = a;
                this.viewLeft = b;
                this.scale = c;
                this.oldScale = f
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(vc.ViewportChange, vb.UiBase);
        vc.ViewportChange.prototype.type = k.VIEWPORT_CHANGE;
        vc.ViewportChange.prototype.toJson = function() {
            var a = vc.ViewportChange.superClass_.toJson.call(this);
            a.viewTop = this.viewTop;
            a.viewLeft = this.viewLeft;
            a.scale = this.scale;
            a.oldScale = this.oldScale;
            return a
        }
        ;
        vc.ViewportChange.prototype.fromJson = function(a) {
            vc.ViewportChange.superClass_.fromJson.call(this, a);
            this.viewTop = a.viewTop;
            this.viewLeft = a.viewLeft;
            this.scale = a.scale;
            this.oldScale = a.oldScale
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.VIEWPORT_CHANGE, vc.ViewportChange);
        var ib = function(a) {
            this.workspace_ = a
        };
        ib.prototype.getDimensionsPx_ = function(a) {
            var b = 0
              , c = 0;
            a && (b = a.getWidth(),
            c = a.getHeight());
            return new Pa(b,c)
        }
        ;
        ib.prototype.getFlyoutMetrics = function(a) {
            a = this.getDimensionsPx_(this.workspace_.getFlyout(a));
            return {
                width: a.width,
                height: a.height,
                position: this.workspace_.toolboxPosition
            }
        }
        ;
        ib.prototype.getToolboxMetrics = function() {
            var a = this.getDimensionsPx_(this.workspace_.getToolbox());
            return {
                width: a.width,
                height: a.height,
                position: this.workspace_.toolboxPosition
            }
        }
        ;
        ib.prototype.getSvgMetrics = function() {
            return this.workspace_.getCachedParentSvgSize()
        }
        ;
        ib.prototype.getAbsoluteMetrics = function() {
            var a = 0
              , b = this.getToolboxMetrics()
              , c = this.getFlyoutMetrics(!0)
              , d = !!this.workspace_.getToolbox()
              , f = !!this.workspace_.getFlyout(!0)
              , g = d ? b.position : c.position
              , m = g === X.Position.LEFT;
            g = g === X.Position.TOP;
            d && m ? a = b.width : f && m && (a = c.width);
            m = 0;
            d && g ? m = b.height : f && g && (m = c.height);
            return {
                top: m,
                left: a
            }
        }
        ;
        ib.prototype.getViewMetrics = function(a) {
            a = a ? this.workspace_.scale : 1;
            var b = this.getSvgMetrics()
              , c = this.getToolboxMetrics()
              , d = this.getFlyoutMetrics(!0)
              , f = this.workspace_.getToolbox() ? c.position : d.position;
            if (this.workspace_.getToolbox())
                if (f === X.Position.TOP || f === X.Position.BOTTOM)
                    b.height -= c.height;
                else {
                    if (f === X.Position.LEFT || f === X.Position.RIGHT)
                        b.width -= c.width
                }
            else if (this.workspace_.getFlyout(!0))
                if (f === X.Position.TOP || f === X.Position.BOTTOM)
                    b.height -= d.height;
                else if (f === X.Position.LEFT || f === X.Position.RIGHT)
                    b.width -= d.width;
            return {
                height: b.height / a,
                width: b.width / a,
                top: -this.workspace_.scrollY / a,
                left: -this.workspace_.scrollX / a
            }
        }
        ;
        ib.prototype.getContentMetrics = function(a) {
            a = a ? 1 : this.workspace_.scale;
            var b = this.workspace_.getBlocksBoundingBox();
            return {
                height: (b.bottom - b.top) * a,
                width: (b.right - b.left) * a,
                top: b.top * a,
                left: b.left * a
            }
        }
        ;
        ib.prototype.hasFixedEdges = function() {
            return !this.workspace_.isMovableHorizontally() || !this.workspace_.isMovableVertically()
        }
        ;
        ib.prototype.getComputedFixedEdges_ = function(a) {
            if (!this.hasFixedEdges())
                return {};
            var b = this.workspace_.isMovableHorizontally()
              , c = this.workspace_.isMovableVertically();
            a = a || this.getViewMetrics(!1);
            var d = {};
            c || (d.top = a.top,
            d.bottom = a.top + a.height);
            b || (d.left = a.left,
            d.right = a.left + a.width);
            return d
        }
        ;
        ib.prototype.getPaddedContent_ = function(a, b) {
            var c = b.top + b.height
              , d = b.left + b.width
              , f = a.width;
            a = a.height;
            var g = f / 2
              , m = a / 2;
            return {
                top: Math.min(b.top - m, c - a),
                bottom: Math.max(c + m, b.top + a),
                left: Math.min(b.left - g, d - f),
                right: Math.max(d + g, b.left + f)
            }
        }
        ;
        ib.prototype.getScrollMetrics = function(a, b, c) {
            a = a ? this.workspace_.scale : 1;
            b = b || this.getViewMetrics(!1);
            var d = c || this.getContentMetrics();
            c = this.getComputedFixedEdges_(b);
            b = this.getPaddedContent_(b, d);
            d = void 0 !== c.top ? c.top : b.top;
            var f = void 0 !== c.left ? c.left : b.left;
            return {
                top: d / a,
                left: f / a,
                width: ((void 0 !== c.right ? c.right : b.right) - f) / a,
                height: ((void 0 !== c.bottom ? c.bottom : b.bottom) - d) / a
            }
        }
        ;
        ib.prototype.getUiMetrics = function() {
            return {
                viewMetrics: this.getViewMetrics(),
                absoluteMetrics: this.getAbsoluteMetrics(),
                toolboxMetrics: this.getToolboxMetrics()
            }
        }
        ;
        ib.prototype.getMetrics = function() {
            var a = this.getToolboxMetrics()
              , b = this.getFlyoutMetrics(!0)
              , c = this.getSvgMetrics()
              , d = this.getAbsoluteMetrics()
              , f = this.getViewMetrics()
              , g = this.getContentMetrics()
              , m = this.getScrollMetrics(!1, f, g);
            return {
                contentHeight: g.height,
                contentWidth: g.width,
                contentTop: g.top,
                contentLeft: g.left,
                scrollHeight: m.height,
                scrollWidth: m.width,
                scrollTop: m.top,
                scrollLeft: m.left,
                viewHeight: f.height,
                viewWidth: f.width,
                viewTop: f.top,
                viewLeft: f.left,
                absoluteTop: d.top,
                absoluteLeft: d.left,
                svgHeight: c.height,
                svgWidth: c.width,
                toolboxWidth: a.width,
                toolboxHeight: a.height,
                toolboxPosition: a.position,
                flyoutWidth: b.width,
                flyoutHeight: b.height
            }
        }
        ;
        (0,
        w.register)(w.Type.METRICS_MANAGER, w.DEFAULT, ib);
        var x = {
            WorkspaceSvg: function(a, b, c) {
                x.WorkspaceSvg.superClass_.constructor.call(this, a);
                this.metricsManager_ = new ((0,
                w.getClassFromOptions)(w.Type.METRICS_MANAGER, a, !0))(this);
                this.getMetrics = a.getMetrics || this.metricsManager_.getMetrics.bind(this.metricsManager_);
                this.setMetrics = a.setMetrics || x.WorkspaceSvg.setTopLevelWorkspaceMetrics_;
                this.componentManager_ = new oa;
                this.connectionDBList = wb.init(this.connectionChecker);
                b && (this.blockDragSurface_ = b);
                c && (this.workspaceDragSurface_ = c);
                this.useWorkspaceDragSurface_ = !!this.workspaceDragSurface_ && (0,
                ja.is3dSupported)();
                this.highlightedBlocks_ = [];
                this.audioManager_ = new Lc(a.parentWorkspace);
                this.grid_ = this.options.gridPattern ? new Fb(this.options.gridPattern,a.gridOptions) : null;
                this.markerManager_ = new ub(this);
                this.toolboxCategoryCallbacks_ = Object.create(null);
                this.flyoutButtonCallbacks_ = Object.create(null);
                (a = e.module$exports$Blockly$Variables) && a.flyoutCategory && this.registerToolboxCategoryCallback(a.CATEGORY_NAME, a.flyoutCategory);
                (a = Mc) && a.flyoutCategory && this.registerToolboxCategoryCallback(a.CATEGORY_NAME, a.flyoutCategory);
                (a = e.module$exports$Blockly$Procedures) && a.flyoutCategory && (this.registerToolboxCategoryCallback(a.CATEGORY_NAME, a.flyoutCategory),
                this.addChangeListener(a.mutatorOpenListener));
                this.themeManager_ = this.options.parentWorkspace ? this.options.parentWorkspace.getThemeManager() : new tc(this,this.options.theme || ud);
                this.themeManager_.subscribeWorkspace(this);
                this.renderer_ = (0,
                ma.init)(this.options.renderer || "geras", this.getTheme(), this.options.rendererOverrides);
                this.cachedParentSvg_ = null;
                this.keyboardAccessibilityMode = !1;
                this.topBoundedElements_ = [];
                this.dragTargetAreas_ = [];
                this.cachedParentSvgSize_ = new Pa(0,0)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(x.WorkspaceSvg, N.Workspace);
        x.WorkspaceSvg.prototype.resizeHandlerWrapper_ = null;
        x.WorkspaceSvg.prototype.rendered = !0;
        x.WorkspaceSvg.prototype.isVisible_ = !0;
        x.WorkspaceSvg.prototype.isFlyout = !1;
        x.WorkspaceSvg.prototype.isMutator = !1;
        x.WorkspaceSvg.prototype.resizesEnabled_ = !0;
        x.WorkspaceSvg.prototype.scrollX = 0;
        x.WorkspaceSvg.prototype.scrollY = 0;
        x.WorkspaceSvg.prototype.startScrollX = 0;
        x.WorkspaceSvg.prototype.startScrollY = 0;
        x.WorkspaceSvg.prototype.dragDeltaXY_ = null;
        x.WorkspaceSvg.prototype.scale = 1;
        x.WorkspaceSvg.prototype.oldScale_ = 1;
        x.WorkspaceSvg.prototype.oldTop_ = 0;
        x.WorkspaceSvg.prototype.oldLeft_ = 0;
        x.WorkspaceSvg.prototype.trashcan = null;
        x.WorkspaceSvg.prototype.scrollbar = null;
        x.WorkspaceSvg.prototype.flyout_ = null;
        x.WorkspaceSvg.prototype.toolbox_ = null;
        x.WorkspaceSvg.prototype.currentGesture_ = null;
        x.WorkspaceSvg.prototype.blockDragSurface_ = null;
        x.WorkspaceSvg.prototype.workspaceDragSurface_ = null;
        x.WorkspaceSvg.prototype.useWorkspaceDragSurface_ = !1;
        x.WorkspaceSvg.prototype.isDragSurfaceActive_ = !1;
        x.WorkspaceSvg.prototype.injectionDiv_ = null;
        x.WorkspaceSvg.prototype.lastRecordedPageScroll_ = null;
        x.WorkspaceSvg.prototype.targetWorkspace = null;
        x.WorkspaceSvg.prototype.inverseScreenCTM_ = null;
        x.WorkspaceSvg.prototype.inverseScreenCTMDirty_ = !0;
        x.WorkspaceSvg.prototype.getMarkerManager = function() {
            return this.markerManager_
        }
        ;
        x.WorkspaceSvg.prototype.getMetricsManager = function() {
            return this.metricsManager_
        }
        ;
        x.WorkspaceSvg.prototype.setMetricsManager = function(a) {
            this.metricsManager_ = a;
            this.getMetrics = this.metricsManager_.getMetrics.bind(this.metricsManager_)
        }
        ;
        x.WorkspaceSvg.prototype.getComponentManager = function() {
            return this.componentManager_
        }
        ;
        x.WorkspaceSvg.prototype.setCursorSvg = function(a) {
            this.markerManager_.setCursorSvg(a)
        }
        ;
        x.WorkspaceSvg.prototype.setMarkerSvg = function(a) {
            this.markerManager_.setMarkerSvg(a)
        }
        ;
        x.WorkspaceSvg.prototype.getMarker = function(a) {
            return this.markerManager_ ? this.markerManager_.getMarker(a) : null
        }
        ;
        x.WorkspaceSvg.prototype.getCursor = function() {
            return this.markerManager_ ? this.markerManager_.getCursor() : null
        }
        ;
        x.WorkspaceSvg.prototype.getRenderer = function() {
            return this.renderer_
        }
        ;
        x.WorkspaceSvg.prototype.getThemeManager = function() {
            return this.themeManager_
        }
        ;
        x.WorkspaceSvg.prototype.getTheme = function() {
            return this.themeManager_.getTheme()
        }
        ;
        x.WorkspaceSvg.prototype.setTheme = function(a) {
            a || (a = ud);
            this.themeManager_.setTheme(a)
        }
        ;
        x.WorkspaceSvg.prototype.refreshTheme = function() {
            this.svgGroup_ && this.renderer_.refreshDom(this.svgGroup_, this.getTheme());
            this.updateBlockStyles_(this.getAllBlocks(!1).filter(function(b) {
                return !!b.getStyleName()
            }));
            this.refreshToolboxSelection();
            this.toolbox_ && this.toolbox_.refreshTheme();
            this.isVisible() && this.setVisible(!0);
            var a = new ((0,
            k.get)(k.THEME_CHANGE))(this.getTheme().name,this.id);
            (0,
            k.fire)(a)
        }
        ;
        x.WorkspaceSvg.prototype.updateBlockStyles_ = function(a) {
            for (var b = 0, c; c = a[b]; b++) {
                var d = c.getStyleName();
                d && (c.setStyle(d),
                c.mutator && c.mutator.updateBlockStyle())
            }
        }
        ;
        x.WorkspaceSvg.prototype.getInverseScreenCTM = function() {
            if (this.inverseScreenCTMDirty_) {
                var a = this.getParentSvg().getScreenCTM();
                a && (this.inverseScreenCTM_ = a.inverse(),
                this.inverseScreenCTMDirty_ = !1)
            }
            return this.inverseScreenCTM_
        }
        ;
        x.WorkspaceSvg.prototype.updateInverseScreenCTM = function() {
            this.inverseScreenCTMDirty_ = !0
        }
        ;
        x.WorkspaceSvg.prototype.isVisible = function() {
            return this.isVisible_
        }
        ;
        x.WorkspaceSvg.prototype.getSvgXY = function(a) {
            var b = 0
              , c = 0
              , d = 1;
            if ((0,
            n.containsNode)(this.getCanvas(), a) || (0,
            n.containsNode)(this.getBubbleCanvas(), a))
                d = this.scale;
            do {
                var f = (0,
                ja.getRelativeXY)(a);
                if (a === this.getCanvas() || a === this.getBubbleCanvas())
                    d = 1;
                b += f.x * d;
                c += f.y * d;
                a = a.parentNode
            } while (a && a !== this.getParentSvg());
            return new J(b,c)
        }
        ;
        x.WorkspaceSvg.prototype.getCachedParentSvgSize = function() {
            var a = this.cachedParentSvgSize_;
            return new Pa(a.width,a.height)
        }
        ;
        x.WorkspaceSvg.prototype.getOriginOffsetInPixels = function() {
            return (0,
            ja.getInjectionDivXY)(this.getCanvas())
        }
        ;
        x.WorkspaceSvg.prototype.getInjectionDiv = function() {
            if (!this.injectionDiv_)
                for (var a = this.svgGroup_; a; ) {
                    if (-1 !== (" " + (a.getAttribute("class") || "") + " ").indexOf(" injectionDiv ")) {
                        this.injectionDiv_ = a;
                        break
                    }
                    a = a.parentNode
                }
            return this.injectionDiv_
        }
        ;
        x.WorkspaceSvg.prototype.getBlockCanvas = function() {
            return this.svgBlockCanvas_
        }
        ;
        x.WorkspaceSvg.prototype.setResizeHandlerWrapper = function(a) {
            this.resizeHandlerWrapper_ = a
        }
        ;
        x.WorkspaceSvg.prototype.createDom = function(a) {
            this.svgGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyWorkspace"
            }, null);
            a && (this.svgBackground_ = (0,
            n.createSvgElement)(u.RECT, {
                height: "100%",
                width: "100%",
                "class": a
            }, this.svgGroup_),
            "blocklyMainBackground" === a && this.grid_ ? this.svgBackground_.style.fill = "url(#" + this.grid_.getPatternId() + ")" : this.themeManager_.subscribe(this.svgBackground_, "workspaceBackgroundColour", "fill"));
            this.svgBlockCanvas_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyBlockCanvas"
            }, this.svgGroup_);
            this.svgBubbleCanvas_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyBubbleCanvas"
            }, this.svgGroup_);
            this.isFlyout || ((0,
            y.conditionalBind)(this.svgGroup_, "mousedown", this, this.onMouseDown_, !1, !0),
            document.body.addEventListener("wheel", function() {}),
            (0,
            y.conditionalBind)(this.svgGroup_, "wheel", this, this.onMouseWheel_));
            this.options.hasCategories && (this.toolbox_ = new ((0,
            w.getClassFromOptions)(w.Type.TOOLBOX, this.options, !0))(this));
            this.grid_ && this.grid_.update(this.scale);
            this.recordDragTargets();
            (a = (0,
            w.getClassFromOptions)(w.Type.CURSOR, this.options)) && this.markerManager_.setCursor(new a);
            this.renderer_.createDom(this.svgGroup_, this.getTheme());
            return this.svgGroup_
        }
        ;
        x.WorkspaceSvg.prototype.dispose = function() {
            this.rendered = !1;
            this.currentGesture_ && this.currentGesture_.cancel();
            this.svgGroup_ && ((0,
            n.removeNode)(this.svgGroup_),
            this.svgGroup_ = null);
            this.svgBubbleCanvas_ = this.svgBlockCanvas_ = null;
            this.toolbox_ && (this.toolbox_.dispose(),
            this.toolbox_ = null);
            this.flyout_ && (this.flyout_.dispose(),
            this.flyout_ = null);
            this.trashcan && (this.trashcan.dispose(),
            this.trashcan = null);
            this.scrollbar && (this.scrollbar.dispose(),
            this.scrollbar = null);
            this.zoomControls_ && (this.zoomControls_.dispose(),
            this.zoomControls_ = null);
            this.audioManager_ && (this.audioManager_.dispose(),
            this.audioManager_ = null);
            this.grid_ && (this.grid_.dispose(),
            this.grid_ = null);
            this.renderer_.dispose();
            this.markerManager_ && (this.markerManager_.dispose(),
            this.markerManager_ = null);
            x.WorkspaceSvg.superClass_.dispose.call(this);
            this.themeManager_ && (this.themeManager_.unsubscribeWorkspace(this),
            this.themeManager_.unsubscribe(this.svgBackground_),
            this.options.parentWorkspace || (this.themeManager_.dispose(),
            this.themeManager_ = null));
            this.flyoutButtonCallbacks_ = this.toolboxCategoryCallbacks_ = this.connectionDBList = null;
            if (!this.options.parentWorkspace) {
                var a = this.getParentSvg();
                a && a.parentNode && (0,
                n.removeNode)(a.parentNode)
            }
            this.resizeHandlerWrapper_ && ((0,
            y.unbind)(this.resizeHandlerWrapper_),
            this.resizeHandlerWrapper_ = null)
        }
        ;
        x.WorkspaceSvg.prototype.newBlock = function(a, b) {
            return new E.BlockSvg(this,a,b)
        }
        ;
        x.WorkspaceSvg.prototype.addTrashcan = function() {
            var a = ha.Trashcan;
            if (!a)
                throw Error("Missing require for Blockly.Trashcan");
            this.trashcan = new a(this);
            a = this.trashcan.createDom();
            this.svgGroup_.insertBefore(a, this.svgBlockCanvas_)
        }
        ;
        x.WorkspaceSvg.prototype.addZoomControls = function() {
            var a = Na.ZoomControls;
            if (!a)
                throw Error("Missing require for Blockly.ZoomControls");
            this.zoomControls_ = new a(this);
            a = this.zoomControls_.createDom();
            this.svgGroup_.appendChild(a)
        }
        ;
        x.WorkspaceSvg.prototype.addFlyout = function(a) {
            var b = new nb.Options({
                parentWorkspace: this,
                rtl: this.RTL,
                oneBasedIndex: this.options.oneBasedIndex,
                horizontalLayout: this.horizontalLayout,
                renderer: this.options.renderer,
                rendererOverrides: this.options.rendererOverrides,
                move: {
                    scrollbars: !0
                }
            });
            b.toolboxPosition = this.options.toolboxPosition;
            this.flyout_ = this.horizontalLayout ? new ((0,
            w.getClassFromOptions)(w.Type.FLYOUTS_HORIZONTAL_TOOLBOX, this.options, !0))(b) : new ((0,
            w.getClassFromOptions)(w.Type.FLYOUTS_VERTICAL_TOOLBOX, this.options, !0))(b);
            this.flyout_.autoClose = !1;
            this.flyout_.getWorkspace().setVisible(!0);
            return this.flyout_.createDom(a)
        }
        ;
        x.WorkspaceSvg.prototype.getFlyout = function(a) {
            return this.flyout_ || a ? this.flyout_ : this.toolbox_ ? this.toolbox_.getFlyout() : null
        }
        ;
        x.WorkspaceSvg.prototype.getToolbox = function() {
            return this.toolbox_
        }
        ;
        x.WorkspaceSvg.prototype.updateScreenCalculations_ = function() {
            this.updateInverseScreenCTM();
            this.recordDragTargets()
        }
        ;
        x.WorkspaceSvg.prototype.resizeContents = function() {
            this.resizesEnabled_ && this.rendered && (this.scrollbar && this.scrollbar.resize(),
            this.updateInverseScreenCTM())
        }
        ;
        x.WorkspaceSvg.prototype.resize = function() {
            this.toolbox_ && this.toolbox_.position();
            this.flyout_ && this.flyout_.position();
            for (var a = this.componentManager_.getComponents(oa.Capability.POSITIONABLE, !0), b = this.getMetricsManager().getUiMetrics(), c = [], d = 0, f; f = a[d]; d++)
                f.position(b, c),
                (f = f.getBoundingRectangle()) && c.push(f);
            this.scrollbar && this.scrollbar.resize();
            this.updateScreenCalculations_()
        }
        ;
        x.WorkspaceSvg.prototype.updateScreenCalculationsIfScrolled = function() {
            var a = (0,
            ja.getDocumentScroll)();
            J.equals(this.lastRecordedPageScroll_, a) || (this.lastRecordedPageScroll_ = a,
            this.updateScreenCalculations_())
        }
        ;
        x.WorkspaceSvg.prototype.getCanvas = function() {
            return this.svgBlockCanvas_
        }
        ;
        x.WorkspaceSvg.prototype.setCachedParentSvgSize = function(a, b) {
            var c = this.getParentSvg();
            a && (this.cachedParentSvgSize_.width = a,
            c.cachedWidth_ = a);
            b && (this.cachedParentSvgSize_.height = b,
            c.cachedHeight_ = b)
        }
        ;
        x.WorkspaceSvg.prototype.getBubbleCanvas = function() {
            return this.svgBubbleCanvas_
        }
        ;
        x.WorkspaceSvg.prototype.getParentSvg = function() {
            if (!this.cachedParentSvg_)
                for (var a = this.svgGroup_; a; ) {
                    if ("svg" === a.tagName) {
                        this.cachedParentSvg_ = a;
                        break
                    }
                    a = a.parentNode
                }
            return this.cachedParentSvg_
        }
        ;
        x.WorkspaceSvg.prototype.maybeFireViewportChangeEvent = function() {
            if ((0,
            k.isEnabled)()) {
                var a = this.scale
                  , b = -this.scrollY
                  , c = -this.scrollX;
                if (!(a === this.oldScale_ && 1 > Math.abs(b - this.oldTop_) && 1 > Math.abs(c - this.oldLeft_))) {
                    var d = new ((0,
                    k.get)(k.VIEWPORT_CHANGE))(b,c,a,this.id,this.oldScale_);
                    this.oldScale_ = a;
                    this.oldTop_ = b;
                    this.oldLeft_ = c;
                    (0,
                    k.fire)(d)
                }
            }
        }
        ;
        x.WorkspaceSvg.prototype.translate = function(a, b) {
            if (this.useWorkspaceDragSurface_ && this.isDragSurfaceActive_)
                this.workspaceDragSurface_.translateSurface(a, b);
            else {
                var c = "translate(" + a + "," + b + ") scale(" + this.scale + ")";
                this.svgBlockCanvas_.setAttribute("transform", c);
                this.svgBubbleCanvas_.setAttribute("transform", c)
            }
            this.blockDragSurface_ && this.blockDragSurface_.translateAndScaleGroup(a, b, this.scale);
            this.grid_ && this.grid_.moveTo(a, b);
            this.maybeFireViewportChangeEvent()
        }
        ;
        x.WorkspaceSvg.prototype.resetDragSurface = function() {
            if (this.useWorkspaceDragSurface_) {
                this.isDragSurfaceActive_ = !1;
                var a = this.workspaceDragSurface_.getSurfaceTranslation();
                this.workspaceDragSurface_.clearAndHide(this.svgGroup_);
                a = "translate(" + a.x + "," + a.y + ") scale(" + this.scale + ")";
                this.svgBlockCanvas_.setAttribute("transform", a);
                this.svgBubbleCanvas_.setAttribute("transform", a)
            }
        }
        ;
        x.WorkspaceSvg.prototype.setupDragSurface = function() {
            if (this.useWorkspaceDragSurface_ && !this.isDragSurfaceActive_) {
                this.isDragSurfaceActive_ = !0;
                var a = this.svgBlockCanvas_.previousSibling
                  , b = parseInt(this.getParentSvg().getAttribute("width"), 10)
                  , c = parseInt(this.getParentSvg().getAttribute("height"), 10)
                  , d = (0,
                ja.getRelativeXY)(this.getCanvas());
                this.workspaceDragSurface_.setContentsAndShow(this.getCanvas(), this.getBubbleCanvas(), a, b, c, this.scale);
                this.workspaceDragSurface_.translateSurface(d.x, d.y)
            }
        }
        ;
        x.WorkspaceSvg.prototype.getBlockDragSurface = function() {
            return this.blockDragSurface_
        }
        ;
        x.WorkspaceSvg.prototype.getWidth = function() {
            var a = this.getMetrics();
            return a ? a.viewWidth / this.scale : 0
        }
        ;
        x.WorkspaceSvg.prototype.setVisible = function(a) {
            this.isVisible_ = a;
            if (this.svgGroup_)
                if (this.scrollbar && this.scrollbar.setContainerVisible(a),
                this.getFlyout() && this.getFlyout().setContainerVisible(a),
                this.getParentSvg().style.display = a ? "block" : "none",
                this.toolbox_ && this.toolbox_.setVisible(a),
                a) {
                    a = this.getAllBlocks(!1);
                    for (var b = a.length - 1; 0 <= b; b--)
                        a[b].markDirty();
                    this.render();
                    this.toolbox_ && this.toolbox_.position()
                } else
                    this.hideChaff(!0)
        }
        ;
        x.WorkspaceSvg.prototype.render = function() {
            for (var a = this.getAllBlocks(!1), b = a.length - 1; 0 <= b; b--)
                a[b].render(!1);
            if (this.currentGesture_)
                for (a = this.currentGesture_.getInsertionMarkers(),
                b = 0; b < a.length; b++)
                    a[b].render(!1);
            this.markerManager_.updateMarkers()
        }
        ;
        x.WorkspaceSvg.prototype.highlightBlock = function(a, b) {
            if (void 0 === b) {
                for (var c = 0, d; d = this.highlightedBlocks_[c]; c++)
                    d.setHighlighted(!1);
                this.highlightedBlocks_.length = 0
            }
            if (a = a ? this.getBlockById(a) : null)
                (b = void 0 === b || b) ? -1 === this.highlightedBlocks_.indexOf(a) && this.highlightedBlocks_.push(a) : (0,
                zb)(this.highlightedBlocks_, a),
                a.setHighlighted(b)
        }
        ;
        x.WorkspaceSvg.prototype.paste = function(a) {
            this.rendered && (a.type || a.tagName) && (this.currentGesture_ && this.currentGesture_.cancel(),
            a.type ? this.pasteBlock_(null, a) : "comment" === a.tagName.toLowerCase() ? this.pasteWorkspaceComment_(a) : this.pasteBlock_(a, null))
        }
        ;
        x.WorkspaceSvg.prototype.pasteBlock_ = function(a, b) {
            (0,
            k.disable)();
            try {
                var c = 0
                  , d = 0;
                if (a) {
                    var f = (0,
                    e.module$exports$Blockly$Xml.domToBlock)(a, this);
                    c = parseInt(a.getAttribute("x"), 10);
                    this.RTL && (c = -c);
                    d = parseInt(a.getAttribute("y"), 10)
                } else
                    b && (f = (0,
                    Ya.append)(b, this),
                    c = b.x || 10,
                    this.RTL && (c = this.getWidth() - c),
                    d = b.y || 10);
                if (!isNaN(c) && !isNaN(d)) {
                    do {
                        var g = !1
                          , m = this.getAllBlocks(!1);
                        a = 0;
                        for (b = void 0; b = m[a]; a++) {
                            var r = b.getRelativeToSurfaceXY();
                            if (1 >= Math.abs(c - r.x) && 1 >= Math.abs(d - r.y)) {
                                g = !0;
                                break
                            }
                        }
                        if (!g) {
                            var B = f.getConnections_(!1);
                            a = 0;
                            for (b = void 0; b = B[a]; a++)
                                if (b.closest(e.module$exports$Blockly$internalConstants.SNAP_RADIUS, new J(c,d)).connection) {
                                    g = !0;
                                    break
                                }
                        }
                        g && (c = this.RTL ? c - e.module$exports$Blockly$internalConstants.SNAP_RADIUS : c + e.module$exports$Blockly$internalConstants.SNAP_RADIUS,
                        d += 2 * e.module$exports$Blockly$internalConstants.SNAP_RADIUS)
                    } while (g);
                    f.moveTo(new J(c,d))
                }
            } finally {
                (0,
                k.enable)()
            }
            (0,
            k.isEnabled)() && !f.isShadow() && (0,
            k.fire)(new ((0,
            k.get)(k.CREATE))(f));
            f.select()
        }
        ;
        x.WorkspaceSvg.prototype.pasteWorkspaceComment_ = function(a) {
            (0,
            k.disable)();
            try {
                var b = S.fromXml(a, this)
                  , c = parseInt(a.getAttribute("x"), 10)
                  , d = parseInt(a.getAttribute("y"), 10);
                isNaN(c) || isNaN(d) || (this.RTL && (c = -c),
                b.moveBy(c + 50, d + 50))
            } finally {
                (0,
                k.enable)()
            }
            (0,
            k.isEnabled)() && ua.fireCreateEvent(b);
            b.select()
        }
        ;
        x.WorkspaceSvg.prototype.refreshToolboxSelection = function() {
            var a = this.isFlyout ? this.targetWorkspace : this;
            a && !a.currentGesture_ && a.toolbox_ && a.toolbox_.getFlyout() && a.toolbox_.refreshSelection()
        }
        ;
        x.WorkspaceSvg.prototype.renameVariableById = function(a, b) {
            x.WorkspaceSvg.superClass_.renameVariableById.call(this, a, b);
            this.refreshToolboxSelection()
        }
        ;
        x.WorkspaceSvg.prototype.deleteVariableById = function(a) {
            x.WorkspaceSvg.superClass_.deleteVariableById.call(this, a);
            this.refreshToolboxSelection()
        }
        ;
        x.WorkspaceSvg.prototype.createVariable = function(a, b, c) {
            a = x.WorkspaceSvg.superClass_.createVariable.call(this, a, b, c);
            this.refreshToolboxSelection();
            return a
        }
        ;
        x.WorkspaceSvg.prototype.recordDeleteAreas = function() {
            ca.deprecation.warn("WorkspaceSvg.prototype.recordDeleteAreas", "June 2021", "June 2022", "WorkspaceSvg.prototype.recordDragTargets");
            this.recordDragTargets()
        }
        ;
        x.WorkspaceSvg.prototype.recordDragTargets = function() {
            var a = this.componentManager_.getComponents(oa.Capability.DRAG_TARGET, !0);
            this.dragTargetAreas_ = [];
            for (var b = 0, c; c = a[b]; b++) {
                var d = c.getClientRect();
                d && this.dragTargetAreas_.push({
                    component: c,
                    clientRect: d
                })
            }
        }
        ;
        x.WorkspaceSvg.prototype.getDragTarget = function(a) {
            for (var b = 0, c; c = this.dragTargetAreas_[b]; b++)
                if (c.clientRect.contains(a.clientX, a.clientY))
                    return c.component;
            return null
        }
        ;
        x.WorkspaceSvg.prototype.onMouseDown_ = function(a) {
            var b = this.getGesture(a);
            b && b.handleWsStart(a, this)
        }
        ;
        x.WorkspaceSvg.prototype.startDrag = function(a, b) {
            a = (0,
            y.mouseToSvg)(a, this.getParentSvg(), this.getInverseScreenCTM());
            a.x /= this.scale;
            a.y /= this.scale;
            this.dragDeltaXY_ = J.difference(b, a)
        }
        ;
        x.WorkspaceSvg.prototype.moveDrag = function(a) {
            a = (0,
            y.mouseToSvg)(a, this.getParentSvg(), this.getInverseScreenCTM());
            a.x /= this.scale;
            a.y /= this.scale;
            return J.sum(this.dragDeltaXY_, a)
        }
        ;
        x.WorkspaceSvg.prototype.isDragging = function() {
            return null !== this.currentGesture_ && this.currentGesture_.isDragging()
        }
        ;
        x.WorkspaceSvg.prototype.isDraggable = function() {
            return this.options.moveOptions && this.options.moveOptions.drag
        }
        ;
        x.WorkspaceSvg.prototype.isMovable = function() {
            return this.options.moveOptions && !!this.options.moveOptions.scrollbars || this.options.moveOptions && this.options.moveOptions.wheel || this.options.moveOptions && this.options.moveOptions.drag || this.options.zoomOptions && this.options.zoomOptions.wheel || this.options.zoomOptions && this.options.zoomOptions.pinch
        }
        ;
        x.WorkspaceSvg.prototype.isMovableHorizontally = function() {
            var a = !!this.scrollbar;
            return this.isMovable() && (!a || a && this.scrollbar.canScrollHorizontally())
        }
        ;
        x.WorkspaceSvg.prototype.isMovableVertically = function() {
            var a = !!this.scrollbar;
            return this.isMovable() && (!a || a && this.scrollbar.canScrollVertically())
        }
        ;
        x.WorkspaceSvg.prototype.onMouseWheel_ = function(a) {
            if (ba.inProgress())
                a.preventDefault(),
                a.stopPropagation();
            else {
                var b = this.options.zoomOptions && this.options.zoomOptions.wheel
                  , c = this.options.moveOptions && this.options.moveOptions.wheel;
                if (b || c) {
                    var d = (0,
                    y.getScrollDeltaPixels)(a);
                    if (V.MAC)
                        var f = a.metaKey;
                    b && (a.ctrlKey || f || !c) ? (d = -d.y / 50,
                    b = (0,
                    y.mouseToSvg)(a, this.getParentSvg(), this.getInverseScreenCTM()),
                    this.zoom(b.x, b.y, d)) : (b = this.scrollX - d.x,
                    c = this.scrollY - d.y,
                    a.shiftKey && !d.x && (b = this.scrollX - d.y,
                    c = this.scrollY),
                    this.scroll(b, c));
                    a.preventDefault()
                }
            }
        }
        ;
        x.WorkspaceSvg.prototype.getBlocksBoundingBox = function() {
            var a = this.getTopBoundedElements();
            if (!a.length)
                return new Ha(0,0,0,0);
            for (var b = a[0].getBoundingRectangle(), c = 1; c < a.length; c++) {
                var d = a[c];
                d.isInsertionMarker && d.isInsertionMarker() || (d = d.getBoundingRectangle(),
                d.top < b.top && (b.top = d.top),
                d.bottom > b.bottom && (b.bottom = d.bottom),
                d.left < b.left && (b.left = d.left),
                d.right > b.right && (b.right = d.right))
            }
            return b
        }
        ;
        x.WorkspaceSvg.prototype.cleanUp = function() {
            this.setResizesEnabled(!1);
            (0,
            k.setGroup)(!0);
            for (var a = this.getTopBlocks(!0), b = 0, c = 0, d; d = a[c]; c++)
                if (d.isMovable()) {
                    var f = d.getRelativeToSurfaceXY();
                    d.moveBy(-f.x, b - f.y);
                    d.snapToGrid();
                    b = d.getRelativeToSurfaceXY().y + d.getHeightWidth().height + this.renderer_.getConstants().MIN_BLOCK_HEIGHT
                }
            (0,
            k.setGroup)(!1);
            this.setResizesEnabled(!0)
        }
        ;
        x.WorkspaceSvg.prototype.showContextMenu = function(a) {
            if (!this.options.readOnly && !this.isFlyout) {
                var b = ia.ContextMenuRegistry.registry.getContextMenuOptions(ia.ContextMenuRegistry.ScopeType.WORKSPACE, {
                    workspace: this
                });
                this.configureContextMenu && this.configureContextMenu(b, a);
                (0,
                e.module$exports$Blockly$ContextMenu.show)(a, b, this.RTL)
            }
        }
        ;
        x.WorkspaceSvg.prototype.updateToolbox = function(a) {
            if (a = (0,
            X.convertToolboxDefToJson)(a)) {
                if (!this.options.languageTree)
                    throw Error("Existing toolbox is null.  Can't create new toolbox.");
                if ((0,
                X.hasCategories)(a)) {
                    if (!this.toolbox_)
                        throw Error("Existing toolbox has no categories.  Can't change mode.");
                    this.options.languageTree = a;
                    this.toolbox_.render(a)
                } else {
                    if (!this.flyout_)
                        throw Error("Existing toolbox has categories.  Can't change mode.");
                    this.options.languageTree = a;
                    this.flyout_.show(a)
                }
            } else if (this.options.languageTree)
                throw Error("Can't nullify an existing toolbox.");
        }
        ;
        x.WorkspaceSvg.prototype.markFocused = function() {
            this.options.parentWorkspace ? this.options.parentWorkspace.markFocused() : ((0,
            e.module$exports$Blockly$common.setMainWorkspace)(this),
            this.setBrowserFocus())
        }
        ;
        x.WorkspaceSvg.prototype.setBrowserFocus = function() {
            document.activeElement && document.activeElement.blur && document.activeElement.blur();
            try {
                this.getParentSvg().focus({
                    preventScroll: !0
                })
            } catch (a) {
                try {
                    this.getParentSvg().parentNode.setActive()
                } catch (b) {
                    this.getParentSvg().parentNode.focus({
                        preventScroll: !0
                    })
                }
            }
        }
        ;
        x.WorkspaceSvg.prototype.zoom = function(a, b, c) {
            c = Math.pow(this.options.zoomOptions.scaleSpeed, c);
            var d = this.scale * c;
            if (this.scale !== d) {
                d > this.options.zoomOptions.maxScale ? c = this.options.zoomOptions.maxScale / this.scale : d < this.options.zoomOptions.minScale && (c = this.options.zoomOptions.minScale / this.scale);
                var f = this.getCanvas().getCTM()
                  , g = this.getParentSvg().createSVGPoint();
                g.x = a;
                g.y = b;
                g = g.matrixTransform(f.inverse());
                a = g.x;
                b = g.y;
                f = f.translate(a * (1 - c), b * (1 - c)).scale(c);
                this.scrollX = f.e;
                this.scrollY = f.f;
                this.setScale(d)
            }
        }
        ;
        x.WorkspaceSvg.prototype.zoomCenter = function(a) {
            var b = this.getMetrics();
            if (this.flyout_) {
                var c = b.svgWidth ? b.svgWidth / 2 : 0;
                b = b.svgHeight ? b.svgHeight / 2 : 0
            } else
                c = b.viewWidth / 2 + b.absoluteLeft,
                b = b.viewHeight / 2 + b.absoluteTop;
            this.zoom(c, b, a)
        }
        ;
        x.WorkspaceSvg.prototype.zoomToFit = function() {
            if (this.isMovable()) {
                var a = this.getMetrics()
                  , b = a.viewWidth;
                a = a.viewHeight;
                var c = this.getBlocksBoundingBox()
                  , d = c.right - c.left;
                c = c.bottom - c.top;
                if (d) {
                    this.flyout_ && (this.horizontalLayout ? (a += this.flyout_.getHeight(),
                    c += this.flyout_.getHeight() / this.scale) : (b += this.flyout_.getWidth(),
                    d += this.flyout_.getWidth() / this.scale));
                    b /= d;
                    a /= c;
                    (0,
                    k.disable)();
                    try {
                        this.setScale(Math.min(b, a)),
                        this.scrollCenter()
                    } finally {
                        (0,
                        k.enable)()
                    }
                    this.maybeFireViewportChangeEvent()
                }
            } else
                console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.")
        }
        ;
        x.WorkspaceSvg.prototype.beginCanvasTransition = function() {
            (0,
            n.addClass)(this.svgBlockCanvas_, "blocklyCanvasTransitioning");
            (0,
            n.addClass)(this.svgBubbleCanvas_, "blocklyCanvasTransitioning")
        }
        ;
        x.WorkspaceSvg.prototype.endCanvasTransition = function() {
            (0,
            n.removeClass)(this.svgBlockCanvas_, "blocklyCanvasTransitioning");
            (0,
            n.removeClass)(this.svgBubbleCanvas_, "blocklyCanvasTransitioning")
        }
        ;
        x.WorkspaceSvg.prototype.scrollCenter = function() {
            if (this.isMovable()) {
                var a = this.getMetrics()
                  , b = (a.scrollWidth - a.viewWidth) / 2
                  , c = (a.scrollHeight - a.viewHeight) / 2;
                b = -b - a.scrollLeft;
                c = -c - a.scrollTop;
                this.scroll(b, c)
            } else
                console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.")
        }
        ;
        x.WorkspaceSvg.prototype.centerOnBlock = function(a) {
            if (this.isMovable()) {
                if (a = a ? this.getBlockById(a) : null) {
                    var b = a.getRelativeToSurfaceXY()
                      , c = a.getHeightWidth()
                      , d = this.scale;
                    a = (b.x + (this.RTL ? -1 : 1) * c.width / 2) * d;
                    b = (b.y + c.height / 2) * d;
                    c = this.getMetrics();
                    this.scroll(-(a - c.viewWidth / 2), -(b - c.viewHeight / 2))
                }
            } else
                console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.")
        }
        ;
        x.WorkspaceSvg.prototype.setScale = function(a) {
            this.options.zoomOptions.maxScale && a > this.options.zoomOptions.maxScale ? a = this.options.zoomOptions.maxScale : this.options.zoomOptions.minScale && a < this.options.zoomOptions.minScale && (a = this.options.zoomOptions.minScale);
            this.scale = a;
            this.hideChaff(!1);
            (a = this.getFlyout(!1)) && a.isVisible() && (a.reflow(),
            this.recordDragTargets());
            this.grid_ && this.grid_.update(this.scale);
            a = this.getMetrics();
            this.scrollX -= a.absoluteLeft;
            this.scrollY -= a.absoluteTop;
            a.viewLeft += a.absoluteLeft;
            a.viewTop += a.absoluteTop;
            this.scroll(this.scrollX, this.scrollY);
            this.scrollbar && (this.flyout_ ? this.scrollbar.resizeView(a) : this.scrollbar.resizeContent(a))
        }
        ;
        x.WorkspaceSvg.prototype.getScale = function() {
            return this.options.parentWorkspace ? this.options.parentWorkspace.getScale() : this.scale
        }
        ;
        x.WorkspaceSvg.prototype.scroll = function(a, b) {
            this.hideChaff(!0);
            var c = this.getMetrics();
            a = Math.min(a, -c.scrollLeft);
            b = Math.min(b, -c.scrollTop);
            var d = c.scrollTop + Math.max(0, c.scrollHeight - c.viewHeight);
            a = Math.max(a, -(c.scrollLeft + Math.max(0, c.scrollWidth - c.viewWidth)));
            b = Math.max(b, -d);
            this.scrollX = a;
            this.scrollY = b;
            this.scrollbar && this.scrollbar.set(-(a + c.scrollLeft), -(b + c.scrollTop), !1);
            a += c.absoluteLeft;
            b += c.absoluteTop;
            this.translate(a, b)
        }
        ;
        x.WorkspaceSvg.setTopLevelWorkspaceMetrics_ = function(a) {
            var b = this.getMetrics();
            "number" === typeof a.x && (this.scrollX = -(b.scrollLeft + (b.scrollWidth - b.viewWidth) * a.x));
            "number" === typeof a.y && (this.scrollY = -(b.scrollTop + (b.scrollHeight - b.viewHeight) * a.y));
            this.translate(this.scrollX + b.absoluteLeft, this.scrollY + b.absoluteTop)
        }
        ;
        x.WorkspaceSvg.prototype.getBlockById = function(a) {
            return x.WorkspaceSvg.superClass_.getBlockById.call(this, a)
        }
        ;
        x.WorkspaceSvg.prototype.getTopBlocks = function(a) {
            return x.WorkspaceSvg.superClass_.getTopBlocks.call(this, a)
        }
        ;
        x.WorkspaceSvg.prototype.addTopBlock = function(a) {
            this.addTopBoundedElement(a);
            x.WorkspaceSvg.superClass_.addTopBlock.call(this, a)
        }
        ;
        x.WorkspaceSvg.prototype.removeTopBlock = function(a) {
            this.removeTopBoundedElement(a);
            x.WorkspaceSvg.superClass_.removeTopBlock.call(this, a)
        }
        ;
        x.WorkspaceSvg.prototype.addTopComment = function(a) {
            this.addTopBoundedElement(a);
            x.WorkspaceSvg.superClass_.addTopComment.call(this, a)
        }
        ;
        x.WorkspaceSvg.prototype.removeTopComment = function(a) {
            this.removeTopBoundedElement(a);
            x.WorkspaceSvg.superClass_.removeTopComment.call(this, a)
        }
        ;
        x.WorkspaceSvg.prototype.addTopBoundedElement = function(a) {
            this.topBoundedElements_.push(a)
        }
        ;
        x.WorkspaceSvg.prototype.removeTopBoundedElement = function(a) {
            (0,
            zb)(this.topBoundedElements_, a)
        }
        ;
        x.WorkspaceSvg.prototype.getTopBoundedElements = function() {
            return [].concat(this.topBoundedElements_)
        }
        ;
        x.WorkspaceSvg.prototype.setResizesEnabled = function(a) {
            var b = !this.resizesEnabled_ && a;
            this.resizesEnabled_ = a;
            b && this.resizeContents()
        }
        ;
        x.WorkspaceSvg.prototype.clear = function() {
            this.setResizesEnabled(!1);
            x.WorkspaceSvg.superClass_.clear.call(this);
            this.topBoundedElements_ = [];
            this.setResizesEnabled(!0)
        }
        ;
        x.WorkspaceSvg.prototype.registerButtonCallback = function(a, b) {
            if ("function" !== typeof b)
                throw TypeError("Button callbacks must be functions.");
            this.flyoutButtonCallbacks_[a] = b
        }
        ;
        x.WorkspaceSvg.prototype.getButtonCallback = function(a) {
            return (a = this.flyoutButtonCallbacks_[a]) ? a : null
        }
        ;
        x.WorkspaceSvg.prototype.removeButtonCallback = function(a) {
            this.flyoutButtonCallbacks_[a] = null
        }
        ;
        x.WorkspaceSvg.prototype.registerToolboxCategoryCallback = function(a, b) {
            if ("function" !== typeof b)
                throw TypeError("Toolbox category callbacks must be functions.");
            this.toolboxCategoryCallbacks_[a] = b
        }
        ;
        x.WorkspaceSvg.prototype.getToolboxCategoryCallback = function(a) {
            return this.toolboxCategoryCallbacks_[a] || null
        }
        ;
        x.WorkspaceSvg.prototype.removeToolboxCategoryCallback = function(a) {
            this.toolboxCategoryCallbacks_[a] = null
        }
        ;
        x.WorkspaceSvg.prototype.getGesture = function(a) {
            var b = "mousedown" === a.type || "touchstart" === a.type || "pointerdown" === a.type
              , c = this.currentGesture_;
            return c ? b && c.hasStarted() ? (console.warn("Tried to start the same gesture twice."),
            c.cancel(),
            null) : c : b ? this.currentGesture_ = new ya.TouchGesture(a,this) : null
        }
        ;
        x.WorkspaceSvg.prototype.clearGesture = function() {
            this.currentGesture_ = null
        }
        ;
        x.WorkspaceSvg.prototype.cancelCurrentGesture = function() {
            this.currentGesture_ && this.currentGesture_.cancel()
        }
        ;
        x.WorkspaceSvg.prototype.getAudioManager = function() {
            return this.audioManager_
        }
        ;
        x.WorkspaceSvg.prototype.getGrid = function() {
            return this.grid_
        }
        ;
        x.WorkspaceSvg.prototype.hideChaff = function(a) {
            (0,
            aa.hide)();
            (0,
            sa.hide)();
            C.hideWithoutAnimation();
            var b = !!a;
            this.getComponentManager().getComponents(oa.Capability.AUTOHIDEABLE, !0).forEach(function(c) {
                return c.autoHide(b)
            })
        }
        ;
        x.resizeSvgContents = function(a) {
            a.resizeContents()
        }
        ;
        var mf = function(a, b) {
            a.setAttribute("dir", "LTR");
            (0,
            v.inject)(b.hasCss, b.pathToMedia);
            a = (0,
            n.createSvgElement)(u.SVG, {
                xmlns: n.SVG_NS,
                "xmlns:html": n.HTML_NS,
                "xmlns:xlink": n.XLINK_NS,
                version: "1.1",
                "class": "blocklySvg",
                tabindex: "0"
            }, a);
            var c = (0,
            n.createSvgElement)(u.DEFS, {}, a)
              , d = String(Math.random()).substring(2);
            b.gridPattern = Fb.createDom(d, b.gridOptions, c);
            return a
        }
          , nf = function(a, b, c, d) {
            b.parentWorkspace = null;
            b = new x.WorkspaceSvg(b,c,d);
            c = b.options;
            b.scale = c.zoomOptions.startScale;
            a.appendChild(b.createDom("blocklyMainBackground"));
            (0,
            n.addClass)(b.getInjectionDiv(), b.getRenderer().getClassName());
            (0,
            n.addClass)(b.getInjectionDiv(), b.getTheme().getClassName());
            !c.hasCategories && c.languageTree && (d = b.addFlyout(u.SVG),
            (0,
            n.insertAfter)(d, a));
            c.hasTrashcan && b.addTrashcan();
            c.zoomOptions && c.zoomOptions.controls && b.addZoomControls();
            b.getThemeManager().subscribe(a, "workspaceBackgroundColour", "background-color");
            b.translate(0, 0);
            b.addChangeListener((0,
            Fc.bumpIntoBoundsHandler)(b));
            (0,
            e.module$exports$Blockly$common.svgResize)(b);
            (0,
            sa.createDom)();
            C.createDom();
            (0,
            aa.createDom)();
            return b
        }
          , qf = function(a) {
            var b = a.options
              , c = a.getParentSvg();
            (0,
            y.conditionalBind)(c.parentNode, "contextmenu", null, function(f) {
                (0,
                y.isTargetInput)(f) || f.preventDefault()
            });
            c = (0,
            y.conditionalBind)(window, "resize", null, function() {
                a.hideChaff(!0);
                (0,
                e.module$exports$Blockly$common.svgResize)(a);
                Fc.bumpTopObjectsIntoBounds(a)
            });
            a.setResizeHandlerWrapper(c);
            of();
            if (b.languageTree) {
                c = a.getToolbox();
                var d = a.getFlyout(!0);
                c ? c.init() : d && (d.init(a),
                d.show(b.languageTree),
                "function" === typeof d.scrollToStart && d.scrollToStart())
            }
            b.hasTrashcan && a.trashcan.init();
            b.zoomOptions && b.zoomOptions.controls && a.zoomControls_.init();
            b.moveOptions && b.moveOptions.scrollbars ? (a.scrollbar = new ob(a,!0 === b.moveOptions.scrollbars || !!b.moveOptions.scrollbars.horizontal,!0 === b.moveOptions.scrollbars || !!b.moveOptions.scrollbars.vertical,"blocklyMainWorkspaceScrollbar"),
            a.scrollbar.resize()) : a.setMetrics({
                x: .5,
                y: .5
            });
            b.hasSounds && pf(b.pathToMedia, a)
        }
          , rf = function(a) {
            var b = (0,
            e.module$exports$Blockly$common.getMainWorkspace)();
            if (b && !((0,
            y.isTargetInput)(a) || b.rendered && !b.isVisible()))
                R.ShortcutRegistry.registry.onKeyDown(b, a)
        }
          , Oe = !1
          , of = function() {
            Oe || ((0,
            y.conditionalBind)(document, "scroll", null, function() {
                for (var a = N.Workspace.getAll(), b = 0, c; c = a[b]; b++)
                    c.updateInverseScreenCTM && c.updateInverseScreenCTM()
            }),
            (0,
            y.conditionalBind)(document, "keydown", null, rf),
            (0,
            y.bind)(document, "touchend", null, O.longStop),
            (0,
            y.bind)(document, "touchcancel", null, O.longStop),
            V.IPAD && (0,
            y.conditionalBind)(window, "orientationchange", document, function() {
                (0,
                e.module$exports$Blockly$common.svgResize)((0,
                e.module$exports$Blockly$common.getMainWorkspace)())
            }));
            Oe = !0
        }
          , pf = function(a, b) {
            var c = b.getAudioManager();
            c.load([a + "click.mp3", a + "click.wav", a + "click.ogg"], "click");
            c.load([a + "disconnect.wav", a + "disconnect.mp3", a + "disconnect.ogg"], "disconnect");
            c.load([a + "delete.mp3", a + "delete.ogg", a + "delete.wav"], "delete");
            var d = [];
            a = function() {
                for (; d.length; )
                    (0,
                    y.unbind)(d.pop());
                c.preload()
            }
            ;
            d.push((0,
            y.conditionalBind)(document, "mousemove", null, a, !0));
            d.push((0,
            y.conditionalBind)(document, "touchstart", null, a, !0))
        }
          , Nc = function() {};
        Nc.prototype.onDragEnter = function(a) {}
        ;
        Nc.prototype.onDragOver = function(a) {}
        ;
        Nc.prototype.onDragExit = function(a) {}
        ;
        Nc.prototype.onDrop = function(a) {}
        ;
        Nc.prototype.shouldPreventMove = function(a) {
            return !1
        }
        ;
        var Ec = {
            DeleteArea: function() {
                Ec.DeleteArea.superClass_.constructor.call(this);
                this.wouldDelete_ = !1
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Ec.DeleteArea, Nc);
        Ec.DeleteArea.prototype.wouldDelete = function(a, b) {
            a instanceof E.BlockSvg ? (a = !a.getParent() && a.isDeletable(),
            this.updateWouldDelete_(a && !b)) : this.updateWouldDelete_(a.isDeletable());
            return this.wouldDelete_
        }
        ;
        Ec.DeleteArea.prototype.updateWouldDelete_ = function(a) {
            this.wouldDelete_ = a
        }
        ;
        var Oc = {
            FlyoutMetricsManager: function(a, b) {
                this.flyout_ = b;
                Oc.FlyoutMetricsManager.superClass_.constructor.call(this, a)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Oc.FlyoutMetricsManager, ib);
        Oc.FlyoutMetricsManager.prototype.getBoundingBox_ = function() {
            try {
                var a = this.workspace_.getCanvas().getBBox()
            } catch (b) {
                a = {
                    height: 0,
                    y: 0,
                    width: 0,
                    x: 0
                }
            }
            return a
        }
        ;
        Oc.FlyoutMetricsManager.prototype.getContentMetrics = function(a) {
            var b = this.getBoundingBox_();
            a = a ? 1 : this.workspace_.scale;
            return {
                height: b.height * a,
                width: b.width * a,
                top: b.y * a,
                left: b.x * a
            }
        }
        ;
        Oc.FlyoutMetricsManager.prototype.getScrollMetrics = function(a, b, c) {
            b = c || this.getContentMetrics();
            c = this.flyout_.MARGIN * this.workspace_.scale;
            a = a ? this.workspace_.scale : 1;
            return {
                height: (b.height + 2 * c) / a,
                width: (b.width + b.left + c) / a,
                top: 0,
                left: 0
            }
        }
        ;
        var Y = {
            Flyout: function(a) {
                Y.Flyout.superClass_.constructor.call(this);
                a.setMetrics = this.setMetrics_.bind(this);
                this.workspace_ = new x.WorkspaceSvg(a);
                this.workspace_.setMetricsManager(new Oc.FlyoutMetricsManager(this.workspace_,this));
                this.workspace_.isFlyout = !0;
                this.workspace_.setVisible(this.isVisible_);
                this.id = (0,
                bb.genUid)();
                this.RTL = !!a.RTL;
                this.horizontalLayout = !1;
                this.toolboxPosition_ = a.toolboxPosition;
                this.eventWrappers_ = [];
                this.mats_ = [];
                this.buttons_ = [];
                this.listeners_ = [];
                this.permanentlyDisabled_ = [];
                this.tabWidth_ = this.workspace_.getRenderer().getConstants().TAB_WIDTH;
                this.targetWorkspace = null;
                this.recycledBlocks_ = []
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Y.Flyout, Ec.DeleteArea);
        Y.Flyout.prototype.autoClose = !0;
        Y.Flyout.prototype.isVisible_ = !1;
        Y.Flyout.prototype.containerVisible_ = !0;
        Y.Flyout.prototype.CORNER_RADIUS = 8;
        Y.Flyout.prototype.MARGIN = Y.Flyout.prototype.CORNER_RADIUS;
        Y.Flyout.prototype.GAP_X = 3 * Y.Flyout.prototype.MARGIN;
        Y.Flyout.prototype.GAP_Y = 3 * Y.Flyout.prototype.MARGIN;
        Y.Flyout.prototype.SCROLLBAR_MARGIN = 2.5;
        Y.Flyout.prototype.width_ = 0;
        Y.Flyout.prototype.height_ = 0;
        Y.Flyout.prototype.dragAngleRange_ = 70;
        Y.Flyout.prototype.createDom = function(a) {
            this.svgGroup_ = (0,
            n.createSvgElement)(a, {
                "class": "blocklyFlyout",
                style: "display: none"
            }, null);
            this.svgBackground_ = (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyFlyoutBackground"
            }, this.svgGroup_);
            this.svgGroup_.appendChild(this.workspace_.createDom());
            this.workspace_.getThemeManager().subscribe(this.svgBackground_, "flyoutBackgroundColour", "fill");
            this.workspace_.getThemeManager().subscribe(this.svgBackground_, "flyoutOpacity", "fill-opacity");
            return this.svgGroup_
        }
        ;
        Y.Flyout.prototype.init = function(a) {
            this.targetWorkspace = a;
            this.workspace_.targetWorkspace = a;
            this.workspace_.scrollbar = new ob(this.workspace_,this.horizontalLayout,!this.horizontalLayout,"blocklyFlyoutScrollbar",this.SCROLLBAR_MARGIN);
            this.hide();
            Array.prototype.push.apply(this.eventWrappers_, (0,
            y.conditionalBind)(this.svgGroup_, "wheel", this, this.wheel_));
            this.autoClose || (this.filterWrapper_ = this.filterForCapacity_.bind(this),
            this.targetWorkspace.addChangeListener(this.filterWrapper_));
            Array.prototype.push.apply(this.eventWrappers_, (0,
            y.conditionalBind)(this.svgBackground_, "mousedown", this, this.onMouseDown_));
            this.workspace_.getGesture = this.targetWorkspace.getGesture.bind(this.targetWorkspace);
            this.workspace_.setVariableMap(this.targetWorkspace.getVariableMap());
            this.workspace_.createPotentialVariableMap();
            a.getComponentManager().addComponent({
                component: this,
                weight: 1,
                capabilities: [oa.Capability.DELETE_AREA, oa.Capability.DRAG_TARGET]
            })
        }
        ;
        Y.Flyout.prototype.dispose = function() {
            this.hide();
            this.workspace_.getComponentManager().removeComponent(this.id);
            (0,
            y.unbind)(this.eventWrappers_);
            this.filterWrapper_ && (this.targetWorkspace.removeChangeListener(this.filterWrapper_),
            this.filterWrapper_ = null);
            this.workspace_ && (this.workspace_.getThemeManager().unsubscribe(this.svgBackground_),
            this.workspace_.targetWorkspace = null,
            this.workspace_.dispose(),
            this.workspace_ = null);
            this.svgGroup_ && ((0,
            n.removeNode)(this.svgGroup_),
            this.svgGroup_ = null);
            this.targetWorkspace = this.svgBackground_ = null
        }
        ;
        Y.Flyout.prototype.getWidth = function() {
            return this.width_
        }
        ;
        Y.Flyout.prototype.getHeight = function() {
            return this.height_
        }
        ;
        Y.Flyout.prototype.getFlyoutScale = function() {
            return this.targetWorkspace.scale
        }
        ;
        Y.Flyout.prototype.getWorkspace = function() {
            return this.workspace_
        }
        ;
        Y.Flyout.prototype.isVisible = function() {
            return this.isVisible_
        }
        ;
        Y.Flyout.prototype.setVisible = function(a) {
            var b = a !== this.isVisible();
            this.isVisible_ = a;
            b && (this.autoClose || this.workspace_.recordDragTargets(),
            this.updateDisplay_())
        }
        ;
        Y.Flyout.prototype.setContainerVisible = function(a) {
            var b = a !== this.containerVisible_;
            this.containerVisible_ = a;
            b && this.updateDisplay_()
        }
        ;
        Y.Flyout.prototype.updateDisplay_ = function() {
            var a = this.containerVisible_ ? this.isVisible() : !1;
            this.svgGroup_.style.display = a ? "block" : "none";
            this.workspace_.scrollbar.setContainerVisible(a)
        }
        ;
        Y.Flyout.prototype.positionAt_ = function(a, b, c, d) {
            this.svgGroup_.setAttribute("width", a);
            this.svgGroup_.setAttribute("height", b);
            this.workspace_.setCachedParentSvgSize(a, b);
            "svg" === this.svgGroup_.tagName ? (0,
            n.setCssTransform)(this.svgGroup_, "translate(" + c + "px," + d + "px)") : this.svgGroup_.setAttribute("transform", "translate(" + c + "," + d + ")");
            if (a = this.workspace_.scrollbar)
                a.setOrigin(c, d),
                a.resize(),
                a.hScroll && a.hScroll.setPosition(a.hScroll.position.x, a.hScroll.position.y),
                a.vScroll && a.vScroll.setPosition(a.vScroll.position.x, a.vScroll.position.y)
        }
        ;
        Y.Flyout.prototype.hide = function() {
            if (this.isVisible()) {
                this.setVisible(!1);
                for (var a = 0, b; b = this.listeners_[a]; a++)
                    (0,
                    y.unbind)(b);
                this.listeners_.length = 0;
                this.reflowWrapper_ && (this.workspace_.removeChangeListener(this.reflowWrapper_),
                this.reflowWrapper_ = null)
            }
        }
        ;
        Y.Flyout.prototype.show = function(a) {
            this.workspace_.setResizesEnabled(!1);
            this.hide();
            this.clearOldBlocks_();
            "string" === typeof a && (a = this.getDynamicCategoryContents_(a));
            this.setVisible(!0);
            a = (0,
            X.convertFlyoutDefToJsonArray)(a);
            a = this.createFlyoutInfo_(a);
            this.layout_(a.contents, a.gaps);
            this.listeners_.push((0,
            y.conditionalBind)(this.svgBackground_, "mouseover", this, function() {
                for (var b = this.workspace_.getTopBlocks(!1), c = 0, d; d = b[c]; c++)
                    d.removeSelect()
            }));
            this.horizontalLayout ? this.height_ = 0 : this.width_ = 0;
            this.workspace_.setResizesEnabled(!0);
            this.reflow();
            this.filterForCapacity_();
            this.position();
            this.reflowWrapper_ = this.reflow.bind(this);
            this.workspace_.addChangeListener(this.reflowWrapper_);
            this.emptyRecycledBlocks_()
        }
        ;
        Y.Flyout.prototype.createFlyoutInfo_ = function(a) {
            var b = []
              , c = [];
            this.permanentlyDisabled_.length = 0;
            for (var d = this.horizontalLayout ? this.GAP_X : this.GAP_Y, f = 0, g; g = a[f]; f++)
                switch (g.custom && (g = this.getDynamicCategoryContents_(g.custom),
                g = (0,
                X.convertFlyoutDefToJsonArray)(g),
                a.splice.apply(a, [f, 1].concat(g)),
                g = a[f]),
                g.kind.toUpperCase()) {
                case "BLOCK":
                    var m = this.createFlyoutBlock_(g);
                    b.push({
                        type: "block",
                        block: m
                    });
                    this.addBlockGap_(g, c, d);
                    break;
                case "SEP":
                    this.addSeparatorGap_(g, c, d);
                    break;
                case "LABEL":
                    g = this.createButton_(g, !0);
                    b.push({
                        type: "button",
                        button: g
                    });
                    c.push(d);
                    break;
                case "BUTTON":
                    g = this.createButton_(g, !1),
                    b.push({
                        type: "button",
                        button: g
                    }),
                    c.push(d)
                }
            return {
                contents: b,
                gaps: c
            }
        }
        ;
        Y.Flyout.prototype.getDynamicCategoryContents_ = function(a) {
            a = this.workspace_.targetWorkspace.getToolboxCategoryCallback(a);
            if ("function" !== typeof a)
                throw TypeError("Couldn't find a callback function when opening a toolbox category.");
            return a(this.workspace_.targetWorkspace)
        }
        ;
        Y.Flyout.prototype.createButton_ = function(a, b) {
            var c = cb.FlyoutButton;
            if (!c)
                throw Error("Missing require for Blockly.FlyoutButton");
            return new c(this.workspace_,this.targetWorkspace,a,b)
        }
        ;
        Y.Flyout.prototype.createFlyoutBlock_ = function(a) {
            var b;
            a.blockxml ? (a = "string" === typeof a.blockxml ? (0,
            e.module$exports$Blockly$Xml.textToDom)(a.blockxml) : a.blockxml,
            (b = this.getRecycledBlock_(a.getAttribute("type"))) || (b = (0,
            e.module$exports$Blockly$Xml.domToBlock)(a, this.workspace_))) : (b = this.getRecycledBlock_(a.type),
            b || (void 0 === a.enabled && (a.enabled = "true" !== a.disabled && !0 !== a.disabled),
            b = (0,
            Ya.append)(a, this.workspace_)));
            b.isEnabled() || this.permanentlyDisabled_.push(b);
            return b
        }
        ;
        Y.Flyout.prototype.getRecycledBlock_ = function(a) {
            for (var b = -1, c = 0; c < this.recycledBlocks_.length; c++)
                if (this.recycledBlocks_[c].type === a) {
                    b = c;
                    break
                }
            return -1 === b ? void 0 : this.recycledBlocks_.splice(b, 1)[0]
        }
        ;
        Y.Flyout.prototype.addBlockGap_ = function(a, b, c) {
            if (a.gap)
                var d = parseInt(a.gap, 10);
            else
                a.blockxml && (a = "string" === typeof a.blockxml ? (0,
                e.module$exports$Blockly$Xml.textToDom)(a.blockxml) : a.blockxml,
                d = parseInt(a.getAttribute("gap"), 10));
            b.push(isNaN(d) ? c : d)
        }
        ;
        Y.Flyout.prototype.addSeparatorGap_ = function(a, b, c) {
            a = parseInt(a.gap, 10);
            !isNaN(a) && 0 < b.length ? b[b.length - 1] = a : b.push(c)
        }
        ;
        Y.Flyout.prototype.clearOldBlocks_ = function() {
            for (var a = this.workspace_.getTopBlocks(!1), b = 0, c; c = a[b]; b++)
                this.blockIsRecyclable_(c) ? this.recycleBlock_(c) : c.dispose(!1, !1);
            for (a = 0; a < this.mats_.length; a++)
                if (b = this.mats_[a])
                    (0,
                    aa.unbindMouseEvents)(b),
                    (0,
                    n.removeNode)(b);
            for (a = this.mats_.length = 0; b = this.buttons_[a]; a++)
                b.dispose();
            this.buttons_.length = 0;
            this.workspace_.getPotentialVariableMap().clear()
        }
        ;
        Y.Flyout.prototype.emptyRecycledBlocks_ = function() {
            for (var a = 0; a < this.recycledBlocks_.length; a++)
                this.recycledBlocks_[a].dispose();
            this.recycledBlocks_ = []
        }
        ;
        Y.Flyout.prototype.blockIsRecyclable_ = function(a) {
            return !1
        }
        ;
        Y.Flyout.prototype.recycleBlock_ = function(a) {
            var b = a.getRelativeToSurfaceXY();
            a.moveBy(-b.x, -b.y);
            this.recycledBlocks_.push(a)
        }
        ;
        Y.Flyout.prototype.addBlockListeners_ = function(a, b, c) {
            this.listeners_.push((0,
            y.conditionalBind)(a, "mousedown", null, this.blockMouseDown_(b)));
            this.listeners_.push((0,
            y.conditionalBind)(c, "mousedown", null, this.blockMouseDown_(b)));
            this.listeners_.push((0,
            y.bind)(a, "mouseenter", b, b.addSelect));
            this.listeners_.push((0,
            y.bind)(a, "mouseleave", b, b.removeSelect));
            this.listeners_.push((0,
            y.bind)(c, "mouseenter", b, b.addSelect));
            this.listeners_.push((0,
            y.bind)(c, "mouseleave", b, b.removeSelect))
        }
        ;
        Y.Flyout.prototype.blockMouseDown_ = function(a) {
            var b = this;
            return function(c) {
                var d = b.targetWorkspace.getGesture(c);
                d && (d.setStartBlock(a),
                d.handleFlyoutStart(c, b))
            }
        }
        ;
        Y.Flyout.prototype.onMouseDown_ = function(a) {
            var b = this.targetWorkspace.getGesture(a);
            b && b.handleFlyoutStart(a, this)
        }
        ;
        Y.Flyout.prototype.isBlockCreatable_ = function(a) {
            return a.isEnabled()
        }
        ;
        Y.Flyout.prototype.createBlock = function(a) {
            var b = null;
            (0,
            k.disable)();
            var c = this.targetWorkspace.getAllVariables();
            this.targetWorkspace.setResizesEnabled(!1);
            try {
                b = this.placeNewBlock_(a)
            } finally {
                (0,
                k.enable)()
            }
            this.targetWorkspace.hideChaff();
            a = (0,
            e.module$exports$Blockly$Variables.getAddedVariables)(this.targetWorkspace, c);
            if ((0,
            k.isEnabled)()) {
                (0,
                k.setGroup)(!0);
                for (c = 0; c < a.length; c++) {
                    var d = a[c];
                    (0,
                    k.fire)(new ((0,
                    k.get)(k.VAR_CREATE))(d))
                }
                (0,
                k.fire)(new ((0,
                k.get)(k.CREATE))(b))
            }
            this.autoClose ? this.hide() : this.filterForCapacity_();
            return b
        }
        ;
        Y.Flyout.prototype.initFlyoutButton_ = function(a, b, c) {
            var d = a.createDom();
            a.moveTo(b, c);
            a.show();
            this.listeners_.push((0,
            y.conditionalBind)(d, "mousedown", this, this.onMouseDown_));
            this.buttons_.push(a)
        }
        ;
        Y.Flyout.prototype.createRect_ = function(a, b, c, d, f) {
            b = (0,
            n.createSvgElement)(u.RECT, {
                "fill-opacity": 0,
                x: b,
                y: c,
                height: d.height,
                width: d.width
            }, null);
            b.tooltip = a;
            (0,
            aa.bindMouseEvents)(b);
            this.workspace_.getCanvas().insertBefore(b, a.getSvgRoot());
            a.flyoutRect_ = b;
            return this.mats_[f] = b
        }
        ;
        Y.Flyout.prototype.moveRectToBlock_ = function(a, b) {
            var c = b.getHeightWidth();
            a.setAttribute("width", c.width);
            a.setAttribute("height", c.height);
            b = b.getRelativeToSurfaceXY();
            a.setAttribute("y", b.y);
            a.setAttribute("x", this.RTL ? b.x - c.width : b.x)
        }
        ;
        Y.Flyout.prototype.filterForCapacity_ = function() {
            for (var a = this.workspace_.getTopBlocks(!1), b = 0, c; c = a[b]; b++)
                if (-1 === this.permanentlyDisabled_.indexOf(c))
                    for (var d = this.targetWorkspace.isCapacityAvailable((0,
                    e.module$exports$Blockly$common.getBlockTypeCounts)(c)); c; )
                        c.setEnabled(d),
                        c = c.getNextBlock()
        }
        ;
        Y.Flyout.prototype.reflow = function() {
            this.reflowWrapper_ && this.workspace_.removeChangeListener(this.reflowWrapper_);
            this.reflowInternal_();
            this.reflowWrapper_ && this.workspace_.addChangeListener(this.reflowWrapper_)
        }
        ;
        Y.Flyout.prototype.isScrollable = function() {
            return this.workspace_.scrollbar ? this.workspace_.scrollbar.isVisible() : !1
        }
        ;
        Y.Flyout.prototype.placeNewBlock_ = function(a) {
            var b = this.targetWorkspace;
            if (!a.getSvgRoot())
                throw Error("oldBlock is not rendered.");
            var c = (0,
            Ya.save)(a);
            b.setResizesEnabled(!1);
            b = (0,
            Ya.append)(c, b);
            this.positionNewBlock_(a, b);
            return b
        }
        ;
        Y.Flyout.prototype.positionNewBlock_ = function(a, b) {
            var c = this.targetWorkspace
              , d = c.getOriginOffsetInPixels()
              , f = this.workspace_.getOriginOffsetInPixels();
            a = a.getRelativeToSurfaceXY();
            a.scale(this.workspace_.scale);
            f = J.sum(f, a);
            d = J.difference(f, d);
            d.scale(1 / c.scale);
            b.moveTo(new J(d.x,d.y))
        }
        ;
        var jb = {
            VerticalFlyout: function(a) {
                jb.VerticalFlyout.superClass_.constructor.call(this, a)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(jb.VerticalFlyout, Y.Flyout);
        jb.VerticalFlyout.registryName = "verticalFlyout";
        jb.VerticalFlyout.prototype.setMetrics_ = function(a) {
            if (this.isVisible()) {
                var b = this.workspace_.getMetricsManager()
                  , c = b.getScrollMetrics()
                  , d = b.getViewMetrics();
                b = b.getAbsoluteMetrics();
                "number" === typeof a.y && (this.workspace_.scrollY = -(c.top + (c.height - d.height) * a.y));
                this.workspace_.translate(this.workspace_.scrollX + b.left, this.workspace_.scrollY + b.top)
            }
        }
        ;
        jb.VerticalFlyout.prototype.getX = function() {
            if (!this.isVisible())
                return 0;
            var a = this.targetWorkspace.getMetricsManager()
              , b = a.getAbsoluteMetrics()
              , c = a.getViewMetrics();
            a = a.getToolboxMetrics();
            return this.targetWorkspace.toolboxPosition === this.toolboxPosition_ ? this.targetWorkspace.getToolbox() ? this.toolboxPosition_ === X.Position.LEFT ? a.width : c.width - this.width_ : this.toolboxPosition_ === X.Position.LEFT ? 0 : c.width : this.toolboxPosition_ === X.Position.LEFT ? 0 : c.width + b.left - this.width_
        }
        ;
        jb.VerticalFlyout.prototype.getY = function() {
            return 0
        }
        ;
        jb.VerticalFlyout.prototype.position = function() {
            if (this.isVisible() && this.targetWorkspace.isVisible()) {
                var a = this.targetWorkspace.getMetricsManager().getViewMetrics();
                this.height_ = a.height;
                this.setBackgroundPath_(this.width_ - this.CORNER_RADIUS, a.height - 2 * this.CORNER_RADIUS);
                a = this.getX();
                var b = this.getY();
                this.positionAt_(this.width_, this.height_, a, b)
            }
        }
        ;
        jb.VerticalFlyout.prototype.setBackgroundPath_ = function(a, b) {
            var c = this.toolboxPosition_ === X.Position.RIGHT
              , d = a + this.CORNER_RADIUS;
            d = ["M " + (c ? d : 0) + ",0"];
            d.push("h", c ? -a : a);
            d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, c ? 0 : 1, c ? -this.CORNER_RADIUS : this.CORNER_RADIUS, this.CORNER_RADIUS);
            d.push("v", Math.max(0, b));
            d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, c ? 0 : 1, c ? this.CORNER_RADIUS : -this.CORNER_RADIUS, this.CORNER_RADIUS);
            d.push("h", c ? a : -a);
            d.push("z");
            this.svgBackground_.setAttribute("d", d.join(" "))
        }
        ;
        jb.VerticalFlyout.prototype.scrollToStart = function() {
            this.workspace_.scrollbar.setY(0)
        }
        ;
        jb.VerticalFlyout.prototype.wheel_ = function(a) {
            var b = (0,
            y.getScrollDeltaPixels)(a);
            if (b.y) {
                var c = this.workspace_.getMetricsManager()
                  , d = c.getScrollMetrics();
                b = c.getViewMetrics().top - d.top + b.y;
                this.workspace_.scrollbar.setY(b);
                (0,
                sa.hide)();
                C.hideWithoutAnimation()
            }
            a.preventDefault();
            a.stopPropagation()
        }
        ;
        jb.VerticalFlyout.prototype.layout_ = function(a, b) {
            this.workspace_.scale = this.targetWorkspace.scale;
            for (var c = this.MARGIN, d = this.RTL ? c : c + this.tabWidth_, f = 0, g; g = a[f]; f++)
                if ("block" === g.type) {
                    g = g.block;
                    for (var m = g.getDescendants(!1), r = 0, B; B = m[r]; r++)
                        B.isInFlyout = !0;
                    g.render();
                    m = g.getSvgRoot();
                    r = g.getHeightWidth();
                    B = g.outputConnection ? d - this.tabWidth_ : d;
                    g.moveBy(B, c);
                    B = this.createRect_(g, this.RTL ? B - r.width : B, c, r, f);
                    this.addBlockListeners_(m, g, B);
                    c += r.height + b[f]
                } else
                    "button" === g.type && (this.initFlyoutButton_(g.button, d, c),
                    c += g.button.height + b[f])
        }
        ;
        jb.VerticalFlyout.prototype.isDragTowardWorkspace = function(a) {
            a = Math.atan2(a.y, a.x) / Math.PI * 180;
            var b = this.dragAngleRange_;
            return a < b && a > -b || a < -180 + b || a > 180 - b ? !0 : !1
        }
        ;
        jb.VerticalFlyout.prototype.getClientRect = function() {
            if (!this.svgGroup_ || this.autoClose || !this.isVisible())
                return null;
            var a = this.svgGroup_.getBoundingClientRect()
              , b = a.left;
            return this.toolboxPosition_ === X.Position.LEFT ? new Ha(-1E9,1E9,-1E9,b + a.width) : new Ha(-1E9,1E9,b,1E9)
        }
        ;
        jb.VerticalFlyout.prototype.reflowInternal_ = function() {
            this.workspace_.scale = this.getFlyoutScale();
            for (var a = 0, b = this.workspace_.getTopBlocks(!1), c = 0, d; d = b[c]; c++) {
                var f = d.getHeightWidth().width;
                d.outputConnection && (f -= this.tabWidth_);
                a = Math.max(a, f)
            }
            for (c = 0; d = this.buttons_[c]; c++)
                a = Math.max(a, d.width);
            a += 1.5 * this.MARGIN + this.tabWidth_;
            a *= this.workspace_.scale;
            a += L.Scrollbar.scrollbarThickness;
            if (this.width_ !== a) {
                for (c = 0; d = b[c]; c++) {
                    if (this.RTL) {
                        f = d.getRelativeToSurfaceXY().x;
                        var g = a / this.workspace_.scale - this.MARGIN;
                        d.outputConnection || (g -= this.tabWidth_);
                        d.moveBy(g - f, 0)
                    }
                    d.flyoutRect_ && this.moveRectToBlock_(d.flyoutRect_, d)
                }
                if (this.RTL)
                    for (b = 0; c = this.buttons_[b]; b++)
                        d = c.getPosition().y,
                        c.moveTo(a / this.workspace_.scale - c.width - this.MARGIN - this.tabWidth_, d);
                this.targetWorkspace.toolboxPosition !== this.toolboxPosition_ || this.toolboxPosition_ !== X.Position.LEFT || this.targetWorkspace.getToolbox() || this.targetWorkspace.translate(this.targetWorkspace.scrollX + a, this.targetWorkspace.scrollY);
                this.width_ = a;
                this.position();
                this.targetWorkspace.recordDragTargets()
            }
        }
        ;
        (0,
        w.register)(w.Type.FLYOUTS_VERTICAL_TOOLBOX, w.DEFAULT, jb.VerticalFlyout);
        var Rb = function(a, b, c) {
            this.id_ = a.toolboxitemid || (0,
            bb.getNextUniqueId)();
            this.level_ = (this.parent_ = c || null) ? this.parent_.getLevel() + 1 : 0;
            this.toolboxItemDef_ = a;
            this.parentToolbox_ = b;
            this.workspace_ = this.parentToolbox_.getWorkspace()
        };
        Rb.prototype.init = function() {}
        ;
        Rb.prototype.getDiv = function() {
            return null
        }
        ;
        Rb.prototype.getId = function() {
            return this.id_
        }
        ;
        Rb.prototype.getParent = function() {
            return null
        }
        ;
        Rb.prototype.getLevel = function() {
            return this.level_
        }
        ;
        Rb.prototype.isSelectable = function() {
            return !1
        }
        ;
        Rb.prototype.isCollapsible = function() {
            return !1
        }
        ;
        Rb.prototype.dispose = function() {}
        ;
        var da = {
            ToolboxCategory: function(a, b, c) {
                da.ToolboxCategory.superClass_.constructor.call(this, a, b, c);
                this.name_ = (0,
                ka.replaceMessageReferences)(a.name);
                this.colour_ = this.getColour_(a);
                this.labelDom_ = this.iconDom_ = this.rowContents_ = this.rowDiv_ = this.htmlDiv_ = null;
                this.cssConfig_ = this.makeDefaultCssConfig_();
                (0,
                e.module$exports$Blockly$utils$object.mixin)(this.cssConfig_, a.cssconfig || a.cssConfig);
                this.isDisabled_ = this.isHidden_ = !1;
                this.flyoutItems_ = [];
                this.parseContents_(a)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(da.ToolboxCategory, Rb);
        da.ToolboxCategory.registrationName = "category";
        da.ToolboxCategory.nestedPadding = 19;
        da.ToolboxCategory.borderWidth = 8;
        da.ToolboxCategory.defaultBackgroundColour = "#57e";
        da.ToolboxCategory.prototype.makeDefaultCssConfig_ = function() {
            return {
                container: "blocklyToolboxCategory",
                row: "blocklyTreeRow",
                rowcontentcontainer: "blocklyTreeRowContentContainer",
                icon: "blocklyTreeIcon",
                label: "blocklyTreeLabel",
                contents: "blocklyToolboxContents",
                selected: "blocklyTreeSelected",
                openicon: "blocklyTreeIconOpen",
                closedicon: "blocklyTreeIconClosed"
            }
        }
        ;
        da.ToolboxCategory.prototype.parseContents_ = function(a) {
            var b = a.contents;
            if (a.custom)
                this.flyoutItems_ = a.custom;
            else if (b)
                for (a = 0; a < b.length; a++)
                    this.flyoutItems_.push(b[a])
        }
        ;
        da.ToolboxCategory.prototype.init = function() {
            this.createDom_();
            "true" === this.toolboxItemDef_.hidden && this.hide()
        }
        ;
        da.ToolboxCategory.prototype.createDom_ = function() {
            this.htmlDiv_ = this.createContainer_();
            (0,
            Q.setRole)(this.htmlDiv_, Q.Role.TREEITEM);
            (0,
            Q.setState)(this.htmlDiv_, Q.State.SELECTED, !1);
            (0,
            Q.setState)(this.htmlDiv_, Q.State.LEVEL, this.level_);
            this.rowDiv_ = this.createRowContainer_();
            this.rowDiv_.style.pointerEvents = "auto";
            this.htmlDiv_.appendChild(this.rowDiv_);
            this.rowContents_ = this.createRowContentsContainer_();
            this.rowContents_.style.pointerEvents = "none";
            this.rowDiv_.appendChild(this.rowContents_);
            this.iconDom_ = this.createIconDom_();
            (0,
            Q.setRole)(this.iconDom_, Q.Role.PRESENTATION);
            this.rowContents_.appendChild(this.iconDom_);
            this.labelDom_ = this.createLabelDom_(this.name_);
            this.rowContents_.appendChild(this.labelDom_);
            (0,
            Q.setState)(this.htmlDiv_, Q.State.LABELLEDBY, this.labelDom_.getAttribute("id"));
            this.addColourBorder_(this.colour_);
            return this.htmlDiv_
        }
        ;
        da.ToolboxCategory.prototype.createContainer_ = function() {
            var a = document.createElement("div");
            (0,
            n.addClass)(a, this.cssConfig_.container);
            return a
        }
        ;
        da.ToolboxCategory.prototype.createRowContainer_ = function() {
            var a = document.createElement("div");
            (0,
            n.addClass)(a, this.cssConfig_.row);
            var b = da.ToolboxCategory.nestedPadding * this.getLevel();
            b = b.toString() + "px";
            this.workspace_.RTL ? a.style.paddingRight = b : a.style.paddingLeft = b;
            return a
        }
        ;
        da.ToolboxCategory.prototype.createRowContentsContainer_ = function() {
            var a = document.createElement("div");
            (0,
            n.addClass)(a, this.cssConfig_.rowcontentcontainer);
            return a
        }
        ;
        da.ToolboxCategory.prototype.createIconDom_ = function() {
            var a = document.createElement("span");
            this.parentToolbox_.isHorizontal() || (0,
            n.addClass)(a, this.cssConfig_.icon);
            a.style.display = "inline-block";
            return a
        }
        ;
        da.ToolboxCategory.prototype.createLabelDom_ = function(a) {
            var b = document.createElement("span");
            b.setAttribute("id", this.getId() + ".label");
            b.textContent = a;
            (0,
            n.addClass)(b, this.cssConfig_.label);
            return b
        }
        ;
        da.ToolboxCategory.prototype.refreshTheme = function() {
            this.colour_ = this.getColour_(this.toolboxItemDef_);
            this.addColourBorder_(this.colour_)
        }
        ;
        da.ToolboxCategory.prototype.addColourBorder_ = function(a) {
            a && (a = da.ToolboxCategory.borderWidth + "px solid " + (a || "#ddd"),
            this.workspace_.RTL ? this.rowDiv_.style.borderRight = a : this.rowDiv_.style.borderLeft = a)
        }
        ;
        da.ToolboxCategory.prototype.getColour_ = function(a) {
            var b = a.categorystyle || a.categoryStyle;
            if ((a = a.colour) && b)
                console.warn('Toolbox category "' + this.name_ + '" must not have both a style and a colour');
            else
                return b ? this.getColourfromStyle_(b) : this.parseColour_(a);
            return ""
        }
        ;
        da.ToolboxCategory.prototype.getColourfromStyle_ = function(a) {
            var b = this.workspace_.getTheme();
            if (a && b) {
                if ((b = b.categoryStyles[a]) && b.colour)
                    return this.parseColour_(b.colour);
                console.warn('Style "' + a + '" must exist and contain a colour value')
            }
            return ""
        }
        ;
        da.ToolboxCategory.prototype.getClickTarget = function() {
            return this.rowDiv_
        }
        ;
        da.ToolboxCategory.prototype.parseColour_ = function(a) {
            a = (0,
            ka.replaceMessageReferences)(a);
            if (null == a || "" === a)
                return "";
            var b = Number(a);
            if (isNaN(b)) {
                if (b = (0,
                na.parse)(a))
                    return b;
                console.warn('Toolbox category "' + this.name_ + '" has unrecognized colour attribute: ' + a);
                return ""
            }
            return (0,
            na.hueToHex)(b)
        }
        ;
        da.ToolboxCategory.prototype.openIcon_ = function(a) {
            a && ((0,
            n.removeClasses)(a, this.cssConfig_.closedicon),
            (0,
            n.addClass)(a, this.cssConfig_.openicon))
        }
        ;
        da.ToolboxCategory.prototype.closeIcon_ = function(a) {
            a && ((0,
            n.removeClasses)(a, this.cssConfig_.openicon),
            (0,
            n.addClass)(a, this.cssConfig_.closedicon))
        }
        ;
        da.ToolboxCategory.prototype.setVisible_ = function(a) {
            this.htmlDiv_.style.display = a ? "block" : "none";
            this.isHidden_ = !a;
            this.parentToolbox_.getSelectedItem() === this && this.parentToolbox_.clearSelection()
        }
        ;
        da.ToolboxCategory.prototype.hide = function() {
            this.setVisible_(!1)
        }
        ;
        da.ToolboxCategory.prototype.show = function() {
            this.setVisible_(!0)
        }
        ;
        da.ToolboxCategory.prototype.isVisible = function() {
            return !this.isHidden_ && this.allAncestorsExpanded_()
        }
        ;
        da.ToolboxCategory.prototype.allAncestorsExpanded_ = function() {
            for (var a = this; a.getParent(); )
                if (a = a.getParent(),
                !a.isExpanded())
                    return !1;
            return !0
        }
        ;
        da.ToolboxCategory.prototype.isSelectable = function() {
            return this.isVisible() && !this.isDisabled_
        }
        ;
        da.ToolboxCategory.prototype.onClick = function(a) {}
        ;
        da.ToolboxCategory.prototype.setSelected = function(a) {
            if (a) {
                var b = this.parseColour_(da.ToolboxCategory.defaultBackgroundColour);
                this.rowDiv_.style.backgroundColor = this.colour_ || b;
                (0,
                n.addClass)(this.rowDiv_, this.cssConfig_.selected)
            } else
                this.rowDiv_.style.backgroundColor = "",
                (0,
                n.removeClass)(this.rowDiv_, this.cssConfig_.selected);
            (0,
            Q.setState)(this.htmlDiv_, Q.State.SELECTED, a)
        }
        ;
        da.ToolboxCategory.prototype.setDisabled = function(a) {
            this.isDisabled_ = a;
            this.getDiv().setAttribute("disabled", a);
            a ? this.getDiv().setAttribute("disabled", "true") : this.getDiv().removeAttribute("disabled")
        }
        ;
        da.ToolboxCategory.prototype.getName = function() {
            return this.name_
        }
        ;
        da.ToolboxCategory.prototype.getParent = function() {
            return this.parent_
        }
        ;
        da.ToolboxCategory.prototype.getDiv = function() {
            return this.htmlDiv_
        }
        ;
        da.ToolboxCategory.prototype.getContents = function() {
            return this.flyoutItems_
        }
        ;
        da.ToolboxCategory.prototype.updateFlyoutContents = function(a) {
            this.flyoutItems_ = [];
            "string" === typeof a ? this.toolboxItemDef_.custom = a : (delete this.toolboxItemDef_.custom,
            this.toolboxItemDef_.contents = (0,
            X.convertFlyoutDefToJsonArray)(a));
            this.parseContents_(this.toolboxItemDef_)
        }
        ;
        da.ToolboxCategory.prototype.dispose = function() {
            (0,
            n.removeNode)(this.htmlDiv_)
        }
        ;
        (0,
        v.register)('\n  .blocklyTreeRow:not(.blocklyTreeSelected):hover {\n    background-color: rgba(255, 255, 255, 0.2);\n  }\n\n  .blocklyToolboxDiv[layout="h"] .blocklyToolboxCategory {\n    margin: 1px 5px 1px 0;\n  }\n\n  .blocklyToolboxDiv[dir="RTL"][layout="h"] .blocklyToolboxCategory {\n    margin: 1px 0 1px 5px;\n  }\n\n  .blocklyTreeRow {\n    height: 22px;\n    line-height: 22px;\n    margin-bottom: 3px;\n    padding-right: 8px;\n    white-space: nowrap;\n  }\n\n  .blocklyToolboxDiv[dir="RTL"] .blocklyTreeRow {\n    margin-left: 8px;\n    padding-right: 0;\n  }\n\n  .blocklyTreeIcon {\n    background-image: url(<<<PATH>>>/sprites.png);\n    height: 16px;\n    vertical-align: middle;\n    visibility: hidden;\n    width: 16px;\n  }\n\n  .blocklyTreeIconClosed {\n    background-position: -32px -1px;\n  }\n\n  .blocklyToolboxDiv[dir="RTL"] .blocklyTreeIconClosed {\n    background-position: 0 -1px;\n  }\n\n  .blocklyTreeSelected>.blocklyTreeIconClosed {\n    background-position: -32px -17px;\n  }\n\n  .blocklyToolboxDiv[dir="RTL"] .blocklyTreeSelected>.blocklyTreeIconClosed {\n    background-position: 0 -17px;\n  }\n\n  .blocklyTreeIconOpen {\n    background-position: -16px -1px;\n  }\n\n  .blocklyTreeSelected>.blocklyTreeIconOpen {\n    background-position: -16px -17px;\n  }\n\n  .blocklyTreeLabel {\n    cursor: default;\n    font: 16px sans-serif;\n    padding: 0 3px;\n    vertical-align: middle;\n  }\n\n  .blocklyToolboxDelete .blocklyTreeLabel {\n    cursor: url("<<<PATH>>>/handdelete.cur"), auto;\n  }\n\n  .blocklyTreeSelected .blocklyTreeLabel {\n    color: #fff;\n  }\n');
        (0,
        w.register)(w.Type.TOOLBOX_ITEM, da.ToolboxCategory.registrationName, da.ToolboxCategory);
        var Sb = {
            ToolboxSeparator: function(a, b) {
                Sb.ToolboxSeparator.superClass_.constructor.call(this, a, b);
                this.cssConfig_ = {
                    container: "blocklyTreeSeparator"
                };
                (0,
                e.module$exports$Blockly$utils$object.mixin)(this.cssConfig_, a.cssconfig || a.cssConfig)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Sb.ToolboxSeparator, Rb);
        Sb.ToolboxSeparator.registrationName = "sep";
        Sb.ToolboxSeparator.prototype.init = function() {
            this.createDom_()
        }
        ;
        Sb.ToolboxSeparator.prototype.createDom_ = function() {
            var a = document.createElement("div");
            (0,
            n.addClass)(a, this.cssConfig_.container);
            return this.htmlDiv_ = a
        }
        ;
        Sb.ToolboxSeparator.prototype.getDiv = function() {
            return this.htmlDiv_
        }
        ;
        Sb.ToolboxSeparator.prototype.dispose = function() {
            (0,
            n.removeNode)(this.htmlDiv_)
        }
        ;
        (0,
        v.register)('\n  .blocklyTreeSeparator {\n    border-bottom: solid #e5e5e5 1px;\n    height: 0;\n    margin: 5px 0;\n  }\n\n  .blocklyToolboxDiv[layout="h"] .blocklyTreeSeparator {\n    border-right: solid #e5e5e5 1px;\n    border-bottom: none;\n    height: auto;\n    margin: 0 5px 0 5px;\n    padding: 5px 0;\n    width: 0;\n  }\n');
        (0,
        w.register)(w.Type.TOOLBOX_ITEM, Sb.ToolboxSeparator.registrationName, Sb.ToolboxSeparator);
        var za = {
            CollapsibleToolboxCategory: function(a, b, c) {
                this.subcategoriesDiv_ = null;
                this.expanded_ = !1;
                this.toolboxItems_ = [];
                za.CollapsibleToolboxCategory.superClass_.constructor.call(this, a, b, c)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(za.CollapsibleToolboxCategory, da.ToolboxCategory);
        za.CollapsibleToolboxCategory.registrationName = "collapsibleCategory";
        za.CollapsibleToolboxCategory.prototype.makeDefaultCssConfig_ = function() {
            var a = za.CollapsibleToolboxCategory.superClass_.makeDefaultCssConfig_.call(this);
            a.contents = "blocklyToolboxContents";
            return a
        }
        ;
        za.CollapsibleToolboxCategory.prototype.parseContents_ = function(a) {
            var b = a.contents
              , c = !0;
            if (a.custom)
                this.flyoutItems_ = a.custom;
            else if (b)
                for (a = 0; a < b.length; a++) {
                    var d = b[a];
                    !(0,
                    w.hasItem)(w.Type.TOOLBOX_ITEM, d.kind) || d.kind.toLowerCase() === Sb.ToolboxSeparator.registrationName && c ? (this.flyoutItems_.push(d),
                    c = !0) : (this.createToolboxItem_(d),
                    c = !1)
                }
        }
        ;
        za.CollapsibleToolboxCategory.prototype.createToolboxItem_ = function(a) {
            var b = a.kind;
            "CATEGORY" == b.toUpperCase() && (0,
            X.isCategoryCollapsible)(a) && (b = za.CollapsibleToolboxCategory.registrationName);
            a = new ((0,
            w.getClass)(w.Type.TOOLBOX_ITEM, b))(a,this.parentToolbox_,this);
            this.toolboxItems_.push(a)
        }
        ;
        za.CollapsibleToolboxCategory.prototype.init = function() {
            za.CollapsibleToolboxCategory.superClass_.init.call(this);
            this.setExpanded("true" === this.toolboxItemDef_.expanded || this.toolboxItemDef_.expanded)
        }
        ;
        za.CollapsibleToolboxCategory.prototype.createDom_ = function() {
            za.CollapsibleToolboxCategory.superClass_.createDom_.call(this);
            var a = this.getChildToolboxItems();
            this.subcategoriesDiv_ = this.createSubCategoriesDom_(a);
            (0,
            Q.setRole)(this.subcategoriesDiv_, Q.Role.GROUP);
            this.htmlDiv_.appendChild(this.subcategoriesDiv_);
            return this.htmlDiv_
        }
        ;
        za.CollapsibleToolboxCategory.prototype.createIconDom_ = function() {
            var a = document.createElement("span");
            this.parentToolbox_.isHorizontal() || ((0,
            n.addClass)(a, this.cssConfig_.icon),
            a.style.visibility = "visible");
            a.style.display = "inline-block";
            return a
        }
        ;
        za.CollapsibleToolboxCategory.prototype.createSubCategoriesDom_ = function(a) {
            var b = document.createElement("div");
            (0,
            n.addClass)(b, this.cssConfig_.contents);
            for (var c = 0; c < a.length; c++) {
                var d = a[c];
                d.init();
                var f = d.getDiv();
                b.appendChild(f);
                d.getClickTarget && d.getClickTarget().setAttribute("id", d.getId())
            }
            return b
        }
        ;
        za.CollapsibleToolboxCategory.prototype.setExpanded = function(a) {
            this.expanded_ !== a && ((this.expanded_ = a) ? (this.subcategoriesDiv_.style.display = "block",
            this.openIcon_(this.iconDom_)) : (this.subcategoriesDiv_.style.display = "none",
            this.closeIcon_(this.iconDom_)),
            (0,
            Q.setState)(this.htmlDiv_, Q.State.EXPANDED, a),
            this.parentToolbox_.handleToolboxItemResize())
        }
        ;
        za.CollapsibleToolboxCategory.prototype.setVisible_ = function(a) {
            this.htmlDiv_.style.display = a ? "block" : "none";
            for (var b = this.getChildToolboxItems(), c = 0; c < b.length; c++)
                b[c].setVisible_(a);
            this.isHidden_ = !a;
            this.parentToolbox_.getSelectedItem() === this && this.parentToolbox_.clearSelection()
        }
        ;
        za.CollapsibleToolboxCategory.prototype.isExpanded = function() {
            return this.expanded_
        }
        ;
        za.CollapsibleToolboxCategory.prototype.isCollapsible = function() {
            return !0
        }
        ;
        za.CollapsibleToolboxCategory.prototype.onClick = function(a) {
            this.toggleExpanded()
        }
        ;
        za.CollapsibleToolboxCategory.prototype.toggleExpanded = function() {
            this.setExpanded(!this.expanded_)
        }
        ;
        za.CollapsibleToolboxCategory.prototype.getDiv = function() {
            return this.htmlDiv_
        }
        ;
        za.CollapsibleToolboxCategory.prototype.getChildToolboxItems = function() {
            return this.toolboxItems_
        }
        ;
        (0,
        w.register)(w.Type.TOOLBOX_ITEM, za.CollapsibleToolboxCategory.registrationName, za.CollapsibleToolboxCategory);
        var wc = {
            ToolboxItemSelect: function(a, b, c) {
                wc.ToolboxItemSelect.superClass_.constructor.call(this, c);
                this.oldItem = a;
                this.newItem = b
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(wc.ToolboxItemSelect, vb.UiBase);
        wc.ToolboxItemSelect.prototype.type = k.TOOLBOX_ITEM_SELECT;
        wc.ToolboxItemSelect.prototype.toJson = function() {
            var a = wc.ToolboxItemSelect.superClass_.toJson.call(this);
            a.oldItem = this.oldItem;
            a.newItem = this.newItem;
            return a
        }
        ;
        wc.ToolboxItemSelect.prototype.fromJson = function(a) {
            wc.ToolboxItemSelect.superClass_.fromJson.call(this, a);
            this.oldItem = a.oldItem;
            this.newItem = a.newItem
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.TOOLBOX_ITEM_SELECT, wc.ToolboxItemSelect);
        var Z = {
            Toolbox: function(a) {
                Z.Toolbox.superClass_.constructor.call(this);
                this.workspace_ = a;
                this.id = "toolbox";
                this.toolboxDef_ = a.options.languageTree || {
                    contents: []
                };
                this.horizontalLayout_ = a.options.horizontalLayout;
                this.contentsDiv_ = this.HtmlDiv = null;
                this.isVisible_ = !1;
                this.contents_ = [];
                this.height_ = this.width_ = 0;
                this.RTL = a.options.RTL;
                this.flyout_ = null;
                this.contentMap_ = Object.create(null);
                this.toolboxPosition = a.options.toolboxPosition;
                this.previouslySelectedItem_ = this.selectedItem_ = null;
                this.boundEvents_ = []
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Z.Toolbox, Ec.DeleteArea);
        Z.Toolbox.prototype.onShortcut = function(a) {
            return !1
        }
        ;
        Z.Toolbox.prototype.init = function() {
            var a = this.workspace_
              , b = a.getParentSvg();
            this.flyout_ = this.createFlyout_();
            this.HtmlDiv = this.createDom_(this.workspace_);
            (0,
            n.insertAfter)(this.flyout_.createDom("svg"), b);
            this.setVisible(!0);
            this.flyout_.init(a);
            this.render(this.toolboxDef_);
            a = a.getThemeManager();
            a.subscribe(this.HtmlDiv, "toolboxBackgroundColour", "background-color");
            a.subscribe(this.HtmlDiv, "toolboxForegroundColour", "color");
            this.workspace_.getComponentManager().addComponent({
                component: this,
                weight: 1,
                capabilities: [oa.Capability.AUTOHIDEABLE, oa.Capability.DELETE_AREA, oa.Capability.DRAG_TARGET]
            })
        }
        ;
        Z.Toolbox.prototype.createDom_ = function(a) {
            a = a.getParentSvg();
            var b = this.createContainer_();
            this.contentsDiv_ = this.createContentsContainer_();
            this.contentsDiv_.tabIndex = 0;
            (0,
            Q.setRole)(this.contentsDiv_, Q.Role.TREE);
            b.appendChild(this.contentsDiv_);
            a.parentNode.insertBefore(b, a);
            this.attachEvents_(b, this.contentsDiv_);
            return b
        }
        ;
        Z.Toolbox.prototype.createContainer_ = function() {
            var a = document.createElement("div");
            a.setAttribute("layout", this.isHorizontal() ? "h" : "v");
            (0,
            n.addClass)(a, "blocklyToolboxDiv");
            (0,
            n.addClass)(a, "blocklyNonSelectable");
            a.setAttribute("dir", this.RTL ? "RTL" : "LTR");
            return a
        }
        ;
        Z.Toolbox.prototype.createContentsContainer_ = function() {
            var a = document.createElement("div");
            (0,
            n.addClass)(a, "blocklyToolboxContents");
            this.isHorizontal() && (a.style.flexDirection = "row");
            return a
        }
        ;
        Z.Toolbox.prototype.attachEvents_ = function(a, b) {
            a = (0,
            y.conditionalBind)(a, "click", this, this.onClick_, !1, !0);
            this.boundEvents_.push(a);
            b = (0,
            y.conditionalBind)(b, "keydown", this, this.onKeyDown_, !1, !0);
            this.boundEvents_.push(b)
        }
        ;
        Z.Toolbox.prototype.onClick_ = function(a) {
            if ((0,
            y.isRightButton)(a) || a.target === this.HtmlDiv)
                (0,
                e.module$exports$Blockly$common.getMainWorkspace)().hideChaff(!1);
            else {
                var b = a.target.getAttribute("id");
                b && (b = this.getToolboxItemById(b),
                b.isSelectable() && (this.setSelectedItem(b),
                b.onClick(a)));
                (0,
                e.module$exports$Blockly$common.getMainWorkspace)().hideChaff(!0)
            }
            (0,
            O.clearTouchIdentifier)()
        }
        ;
        Z.Toolbox.prototype.onKeyDown_ = function(a) {
            var b = !1;
            switch (a.keyCode) {
            case M.DOWN:
                b = this.selectNext_();
                break;
            case M.UP:
                b = this.selectPrevious_();
                break;
            case M.LEFT:
                b = this.selectParent_();
                break;
            case M.RIGHT:
                b = this.selectChild_();
                break;
            case M.ENTER:
            case M.SPACE:
                this.selectedItem_ && this.selectedItem_.isCollapsible() && (this.selectedItem_.toggleExpanded(),
                b = !0);
                break;
            default:
                b = !1
            }
            !b && this.selectedItem_ && this.selectedItem_.onKeyDown && (b = this.selectedItem_.onKeyDown(a));
            b && a.preventDefault()
        }
        ;
        Z.Toolbox.prototype.createFlyout_ = function() {
            var a = this.workspace_
              , b = new nb.Options({
                parentWorkspace: a,
                rtl: a.RTL,
                oneBasedIndex: a.options.oneBasedIndex,
                horizontalLayout: a.horizontalLayout,
                renderer: a.options.renderer,
                rendererOverrides: a.options.rendererOverrides,
                move: {
                    scrollbars: !0
                }
            });
            b.toolboxPosition = a.options.toolboxPosition;
            return new (a.horizontalLayout ? (0,
            w.getClassFromOptions)(w.Type.FLYOUTS_HORIZONTAL_TOOLBOX, a.options, !0) : (0,
            w.getClassFromOptions)(w.Type.FLYOUTS_VERTICAL_TOOLBOX, a.options, !0))(b)
        }
        ;
        Z.Toolbox.prototype.render = function(a) {
            this.toolboxDef_ = a;
            for (var b = 0; b < this.contents_.length; b++) {
                var c = this.contents_[b];
                c && c.dispose()
            }
            this.contents_ = [];
            this.contentMap_ = Object.create(null);
            this.renderContents_(a.contents);
            this.position();
            this.handleToolboxItemResize()
        }
        ;
        Z.Toolbox.prototype.renderContents_ = function(a) {
            for (var b = document.createDocumentFragment(), c = 0; c < a.length; c++)
                this.createToolboxItem_(a[c], b);
            this.contentsDiv_.appendChild(b)
        }
        ;
        Z.Toolbox.prototype.createToolboxItem_ = function(a, b) {
            var c = a.kind;
            "CATEGORY" === c.toUpperCase() && (0,
            X.isCategoryCollapsible)(a) && (c = za.CollapsibleToolboxCategory.registrationName);
            if (c = (0,
            w.getClass)(w.Type.TOOLBOX_ITEM, c.toLowerCase()))
                a = new c(a,this),
                this.addToolboxItem_(a),
                a.init(),
                (c = a.getDiv()) && b.appendChild(c),
                a.getClickTarget && a.getClickTarget().setAttribute("id", a.getId())
        }
        ;
        Z.Toolbox.prototype.addToolboxItem_ = function(a) {
            this.contents_.push(a);
            this.contentMap_[a.getId()] = a;
            if (a.isCollapsible()) {
                a = a.getChildToolboxItems();
                for (var b = 0; b < a.length; b++)
                    this.addToolboxItem_(a[b])
            }
        }
        ;
        Z.Toolbox.prototype.getToolboxItems = function() {
            return this.contents_
        }
        ;
        Z.Toolbox.prototype.addStyle = function(a) {
            (0,
            n.addClass)(this.HtmlDiv, a)
        }
        ;
        Z.Toolbox.prototype.removeStyle = function(a) {
            (0,
            n.removeClass)(this.HtmlDiv, a)
        }
        ;
        Z.Toolbox.prototype.getClientRect = function() {
            if (!this.HtmlDiv || !this.isVisible_)
                return null;
            var a = this.HtmlDiv.getBoundingClientRect()
              , b = a.top
              , c = b + a.height
              , d = a.left;
            a = d + a.width;
            return this.toolboxPosition === X.Position.TOP ? new Ha(-1E7,c,-1E7,1E7) : this.toolboxPosition === X.Position.BOTTOM ? new Ha(b,1E7,-1E7,1E7) : this.toolboxPosition === X.Position.LEFT ? new Ha(-1E7,1E7,-1E7,a) : new Ha(-1E7,1E7,d,1E7)
        }
        ;
        Z.Toolbox.prototype.wouldDelete = function(a, b) {
            a instanceof E.BlockSvg ? this.updateWouldDelete_(!a.getParent() && a.isDeletable()) : this.updateWouldDelete_(a.isDeletable());
            return this.wouldDelete_
        }
        ;
        Z.Toolbox.prototype.onDragEnter = function(a) {
            this.updateCursorDeleteStyle_(!0)
        }
        ;
        Z.Toolbox.prototype.onDragExit = function(a) {
            this.updateCursorDeleteStyle_(!1)
        }
        ;
        Z.Toolbox.prototype.onDrop = function(a) {
            this.updateCursorDeleteStyle_(!1)
        }
        ;
        Z.Toolbox.prototype.updateWouldDelete_ = function(a) {
            a !== this.wouldDelete_ && (this.updateCursorDeleteStyle_(!1),
            this.wouldDelete_ = a,
            this.updateCursorDeleteStyle_(!0))
        }
        ;
        Z.Toolbox.prototype.updateCursorDeleteStyle_ = function(a) {
            var b = this.wouldDelete_ ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
            a ? this.addStyle(b) : this.removeStyle(b)
        }
        ;
        Z.Toolbox.prototype.getToolboxItemById = function(a) {
            return this.contentMap_[a] || null
        }
        ;
        Z.Toolbox.prototype.getWidth = function() {
            return this.width_
        }
        ;
        Z.Toolbox.prototype.getHeight = function() {
            return this.height_
        }
        ;
        Z.Toolbox.prototype.getFlyout = function() {
            return this.flyout_
        }
        ;
        Z.Toolbox.prototype.getWorkspace = function() {
            return this.workspace_
        }
        ;
        Z.Toolbox.prototype.getSelectedItem = function() {
            return this.selectedItem_
        }
        ;
        Z.Toolbox.prototype.getPreviouslySelectedItem = function() {
            return this.previouslySelectedItem_
        }
        ;
        Z.Toolbox.prototype.isHorizontal = function() {
            return this.horizontalLayout_
        }
        ;
        Z.Toolbox.prototype.position = function() {
            var a = this.workspace_.getMetrics()
              , b = this.HtmlDiv;
            b && (this.horizontalLayout_ ? (b.style.left = "0",
            b.style.height = "auto",
            b.style.width = "100%",
            this.height_ = b.offsetHeight,
            this.width_ = a.viewWidth,
            this.toolboxPosition === X.Position.TOP ? b.style.top = "0" : b.style.bottom = "0") : (this.toolboxPosition === X.Position.RIGHT ? b.style.right = "0" : b.style.left = "0",
            b.style.height = "100%",
            this.width_ = b.offsetWidth,
            this.height_ = a.viewHeight),
            this.flyout_.position())
        }
        ;
        Z.Toolbox.prototype.handleToolboxItemResize = function() {
            var a = this.workspace_
              , b = this.HtmlDiv.getBoundingClientRect();
            a.translate(this.toolboxPosition === X.Position.LEFT ? a.scrollX + b.width : a.scrollX, this.toolboxPosition === X.Position.TOP ? a.scrollY + b.height : a.scrollY);
            (0,
            e.module$exports$Blockly$common.svgResize)(a)
        }
        ;
        Z.Toolbox.prototype.clearSelection = function() {
            this.setSelectedItem(null)
        }
        ;
        Z.Toolbox.prototype.refreshTheme = function() {
            for (var a = 0; a < this.contents_.length; a++) {
                var b = this.contents_[a];
                b.refreshTheme && b.refreshTheme()
            }
        }
        ;
        Z.Toolbox.prototype.refreshSelection = function() {
            this.selectedItem_ && this.selectedItem_.isSelectable() && this.selectedItem_.getContents().length && this.flyout_.show(this.selectedItem_.getContents())
        }
        ;
        Z.Toolbox.prototype.setVisible = function(a) {
            this.isVisible_ !== a && (this.HtmlDiv.style.display = a ? "block" : "none",
            this.isVisible_ = a,
            this.workspace_.recordDragTargets())
        }
        ;
        Z.Toolbox.prototype.autoHide = function(a) {
            !a && this.flyout_ && this.flyout_.autoClose && this.clearSelection()
        }
        ;
        Z.Toolbox.prototype.setSelectedItem = function(a) {
            var b = this.selectedItem_;
            !a && !b || a && !a.isSelectable() || (this.shouldDeselectItem_(b, a) && null !== b && this.deselectItem_(b),
            this.shouldSelectItem_(b, a) && null !== a && this.selectItem_(b, a),
            this.updateFlyout_(b, a),
            this.fireSelectEvent_(b, a))
        }
        ;
        Z.Toolbox.prototype.shouldDeselectItem_ = function(a, b) {
            return null !== a && (!a.isCollapsible() || a !== b)
        }
        ;
        Z.Toolbox.prototype.shouldSelectItem_ = function(a, b) {
            return null !== b && b !== a
        }
        ;
        Z.Toolbox.prototype.deselectItem_ = function(a) {
            this.selectedItem_ = null;
            this.previouslySelectedItem_ = a;
            a.setSelected(!1);
            (0,
            Q.setState)(this.contentsDiv_, Q.State.ACTIVEDESCENDANT, "")
        }
        ;
        Z.Toolbox.prototype.selectItem_ = function(a, b) {
            this.selectedItem_ = b;
            this.previouslySelectedItem_ = a;
            b.setSelected(!0);
            (0,
            Q.setState)(this.contentsDiv_, Q.State.ACTIVEDESCENDANT, b.getId())
        }
        ;
        Z.Toolbox.prototype.selectItemByPosition = function(a) {
            -1 < a && a < this.contents_.length && (a = this.contents_[a],
            a.isSelectable() && this.setSelectedItem(a))
        }
        ;
        Z.Toolbox.prototype.updateFlyout_ = function(a, b) {
            b && (a !== b || b.isCollapsible()) && b.getContents().length ? (this.flyout_.show(b.getContents()),
            this.flyout_.scrollToStart()) : this.flyout_.hide()
        }
        ;
        Z.Toolbox.prototype.fireSelectEvent_ = function(a, b) {
            var c = a && a.getName()
              , d = b && b.getName();
            a === b && (d = null);
            a = new ((0,
            k.get)(k.TOOLBOX_ITEM_SELECT))(c,d,this.workspace_.id);
            (0,
            k.fire)(a)
        }
        ;
        Z.Toolbox.prototype.selectParent_ = function() {
            return this.selectedItem_ ? this.selectedItem_.isCollapsible() && this.selectedItem_.isExpanded() ? (this.selectedItem_.setExpanded(!1),
            !0) : this.selectedItem_.getParent() && this.selectedItem_.getParent().isSelectable() ? (this.setSelectedItem(this.selectedItem_.getParent()),
            !0) : !1 : !1
        }
        ;
        Z.Toolbox.prototype.selectChild_ = function() {
            if (!this.selectedItem_ || !this.selectedItem_.isCollapsible())
                return !1;
            var a = this.selectedItem_;
            a.isExpanded() ? this.selectNext_() : a.setExpanded(!0);
            return !0
        }
        ;
        Z.Toolbox.prototype.selectNext_ = function() {
            if (!this.selectedItem_)
                return !1;
            var a = this.contents_.indexOf(this.selectedItem_) + 1;
            if (-1 < a && a < this.contents_.length) {
                for (var b = this.contents_[a]; b && !b.isSelectable(); )
                    b = this.contents_[++a];
                if (b && b.isSelectable())
                    return this.setSelectedItem(b),
                    !0
            }
            return !1
        }
        ;
        Z.Toolbox.prototype.selectPrevious_ = function() {
            if (!this.selectedItem_)
                return !1;
            var a = this.contents_.indexOf(this.selectedItem_) - 1;
            if (-1 < a && a < this.contents_.length) {
                for (var b = this.contents_[a]; b && !b.isSelectable(); )
                    b = this.contents_[--a];
                if (b && b.isSelectable())
                    return this.setSelectedItem(b),
                    !0
            }
            return !1
        }
        ;
        Z.Toolbox.prototype.dispose = function() {
            this.workspace_.getComponentManager().removeComponent("toolbox");
            this.flyout_.dispose();
            for (var a = 0; a < this.contents_.length; a++)
                this.contents_[a].dispose();
            for (a = 0; a < this.boundEvents_.length; a++)
                (0,
                y.unbind)(this.boundEvents_[a]);
            this.boundEvents_ = [];
            this.contents_ = [];
            this.workspace_.getThemeManager().unsubscribe(this.HtmlDiv);
            (0,
            n.removeNode)(this.HtmlDiv)
        }
        ;
        (0,
        v.register)('\n  .blocklyToolboxDelete {\n    cursor: url("<<<PATH>>>/handdelete.cur"), auto;\n  }\n\n  .blocklyToolboxGrab {\n    cursor: url("<<<PATH>>>/handclosed.cur"), auto;\n    cursor: grabbing;\n    cursor: -webkit-grabbing;\n  }\n\n  /* Category tree in Toolbox. */\n  .blocklyToolboxDiv {\n    background-color: #ddd;\n    overflow-x: visible;\n    overflow-y: auto;\n    padding: 4px 0 4px 0;\n    position: absolute;\n    z-index: 70;  /* so blocks go under toolbox when dragging */\n    -webkit-tap-highlight-color: transparent;  /* issue #1345 */\n  }\n\n  .blocklyToolboxContents {\n    display: flex;\n    flex-wrap: wrap;\n    flex-direction: column;\n  }\n\n  .blocklyToolboxContents:focus {\n    outline: none;\n  }\n');
        (0,
        w.register)(w.Type.TOOLBOX, w.DEFAULT, Z.Toolbox);
        var qb = {
            HorizontalFlyout: function(a) {
                qb.HorizontalFlyout.superClass_.constructor.call(this, a);
                this.horizontalLayout = !0
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(qb.HorizontalFlyout, Y.Flyout);
        qb.HorizontalFlyout.prototype.setMetrics_ = function(a) {
            if (this.isVisible()) {
                var b = this.workspace_.getMetricsManager()
                  , c = b.getScrollMetrics()
                  , d = b.getViewMetrics();
                b = b.getAbsoluteMetrics();
                "number" === typeof a.x && (this.workspace_.scrollX = -(c.left + (c.width - d.width) * a.x));
                this.workspace_.translate(this.workspace_.scrollX + b.left, this.workspace_.scrollY + b.top)
            }
        }
        ;
        qb.HorizontalFlyout.prototype.getX = function() {
            return 0
        }
        ;
        qb.HorizontalFlyout.prototype.getY = function() {
            if (!this.isVisible())
                return 0;
            var a = this.targetWorkspace.getMetricsManager()
              , b = a.getAbsoluteMetrics()
              , c = a.getViewMetrics();
            a = a.getToolboxMetrics();
            var d = this.toolboxPosition_ === X.Position.TOP;
            return this.targetWorkspace.toolboxPosition === this.toolboxPosition_ ? this.targetWorkspace.getToolbox() ? d ? a.height : c.height - this.height_ : d ? 0 : c.height : d ? 0 : c.height + b.top - this.height_
        }
        ;
        qb.HorizontalFlyout.prototype.position = function() {
            if (this.isVisible() && this.targetWorkspace.isVisible()) {
                var a = this.targetWorkspace.getMetricsManager().getViewMetrics();
                this.width_ = a.width;
                this.setBackgroundPath_(a.width - 2 * this.CORNER_RADIUS, this.height_ - this.CORNER_RADIUS);
                a = this.getX();
                var b = this.getY();
                this.positionAt_(this.width_, this.height_, a, b)
            }
        }
        ;
        qb.HorizontalFlyout.prototype.setBackgroundPath_ = function(a, b) {
            var c = this.toolboxPosition_ === X.Position.TOP
              , d = ["M 0," + (c ? 0 : this.CORNER_RADIUS)];
            c ? (d.push("h", a + 2 * this.CORNER_RADIUS),
            d.push("v", b),
            d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, this.CORNER_RADIUS),
            d.push("h", -a),
            d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, -this.CORNER_RADIUS)) : (d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, -this.CORNER_RADIUS),
            d.push("h", a),
            d.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, this.CORNER_RADIUS),
            d.push("v", b),
            d.push("h", -a - 2 * this.CORNER_RADIUS));
            d.push("z");
            this.svgBackground_.setAttribute("d", d.join(" "))
        }
        ;
        qb.HorizontalFlyout.prototype.scrollToStart = function() {
            this.workspace_.scrollbar.setX(this.RTL ? Infinity : 0)
        }
        ;
        qb.HorizontalFlyout.prototype.wheel_ = function(a) {
            var b = (0,
            y.getScrollDeltaPixels)(a);
            if (b = b.x || b.y) {
                var c = this.workspace_.getMetricsManager()
                  , d = c.getScrollMetrics();
                b = c.getViewMetrics().left - d.left + b;
                this.workspace_.scrollbar.setX(b);
                (0,
                sa.hide)();
                C.hideWithoutAnimation()
            }
            a.preventDefault();
            a.stopPropagation()
        }
        ;
        qb.HorizontalFlyout.prototype.layout_ = function(a, b) {
            this.workspace_.scale = this.targetWorkspace.scale;
            var c = this.MARGIN
              , d = c + this.tabWidth_;
            this.RTL && (a = a.reverse());
            for (var f = 0, g; g = a[f]; f++)
                if ("block" === g.type) {
                    g = g.block;
                    for (var m = g.getDescendants(!1), r = 0, B; B = m[r]; r++)
                        B.isInFlyout = !0;
                    g.render();
                    m = g.getSvgRoot();
                    r = g.getHeightWidth();
                    B = g.outputConnection ? this.tabWidth_ : 0;
                    B = this.RTL ? d + r.width : d - B;
                    g.moveBy(B, c);
                    B = this.createRect_(g, B, c, r, f);
                    d += r.width + b[f];
                    this.addBlockListeners_(m, g, B)
                } else
                    "button" === g.type && (this.initFlyoutButton_(g.button, d, c),
                    d += g.button.width + b[f])
        }
        ;
        qb.HorizontalFlyout.prototype.isDragTowardWorkspace = function(a) {
            a = Math.atan2(a.y, a.x) / Math.PI * 180;
            var b = this.dragAngleRange_;
            return a < 90 + b && a > 90 - b || a > -90 - b && a < -90 + b ? !0 : !1
        }
        ;
        qb.HorizontalFlyout.prototype.getClientRect = function() {
            if (!this.svgGroup_ || this.autoClose || !this.isVisible())
                return null;
            var a = this.svgGroup_.getBoundingClientRect()
              , b = a.top;
            return this.toolboxPosition_ === X.Position.TOP ? new Ha(-1E9,b + a.height,-1E9,1E9) : new Ha(b,1E9,-1E9,1E9)
        }
        ;
        qb.HorizontalFlyout.prototype.reflowInternal_ = function() {
            this.workspace_.scale = this.getFlyoutScale();
            for (var a = 0, b = this.workspace_.getTopBlocks(!1), c = 0, d; d = b[c]; c++)
                a = Math.max(a, d.getHeightWidth().height);
            c = this.buttons_;
            d = 0;
            for (var f; f = c[d]; d++)
                a = Math.max(a, f.height);
            a += 1.5 * this.MARGIN;
            a *= this.workspace_.scale;
            a += L.Scrollbar.scrollbarThickness;
            if (this.height_ !== a) {
                for (c = 0; d = b[c]; c++)
                    d.flyoutRect_ && this.moveRectToBlock_(d.flyoutRect_, d);
                this.targetWorkspace.toolboxPosition !== this.toolboxPosition_ || this.toolboxPosition_ !== X.Position.TOP || this.targetWorkspace.getToolbox() || this.targetWorkspace.translate(this.targetWorkspace.scrollX, this.targetWorkspace.scrollY + a);
                this.height_ = a;
                this.position();
                this.targetWorkspace.recordDragTargets()
            }
        }
        ;
        (0,
        w.register)(w.Type.FLYOUTS_HORIZONTAL_TOOLBOX, w.DEFAULT, qb.HorizontalFlyout);
        e.module$exports$Blockly$Generator = {
            Generator: function(a) {
                this.name_ = a;
                this.FUNCTION_NAME_PLACEHOLDER_REGEXP_ = new RegExp(this.FUNCTION_NAME_PLACEHOLDER_,"g")
            }
        };
        e.module$exports$Blockly$Generator.Generator.prototype.INFINITE_LOOP_TRAP = null;
        e.module$exports$Blockly$Generator.Generator.prototype.STATEMENT_PREFIX = null;
        e.module$exports$Blockly$Generator.Generator.prototype.STATEMENT_SUFFIX = null;
        e.module$exports$Blockly$Generator.Generator.prototype.INDENT = "  ";
        e.module$exports$Blockly$Generator.Generator.prototype.COMMENT_WRAP = 60;
        e.module$exports$Blockly$Generator.Generator.prototype.ORDER_OVERRIDES = [];
        e.module$exports$Blockly$Generator.Generator.prototype.isInitialized = null;
        e.module$exports$Blockly$Generator.Generator.prototype.workspaceToCode = function(a) {
            a || (console.warn("No workspace specified in workspaceToCode call.  Guessing."),
            a = (0,
            e.module$exports$Blockly$common.getMainWorkspace)());
            var b = [];
            this.init(a);
            a = a.getTopBlocks(!0);
            for (var c = 0, d; d = a[c]; c++) {
                var f = this.blockToCode(d);
                Array.isArray(f) && (f = f[0]);
                f && (d.outputConnection && (f = this.scrubNakedValue(f),
                this.STATEMENT_PREFIX && !d.suppressPrefixSuffix && (f = this.injectId(this.STATEMENT_PREFIX, d) + f),
                this.STATEMENT_SUFFIX && !d.suppressPrefixSuffix && (f += this.injectId(this.STATEMENT_SUFFIX, d))),
                b.push(f))
            }
            b = b.join("\n");
            b = this.finish(b);
            b = b.replace(/^\s+\n/, "");
            b = b.replace(/\n\s+$/, "\n");
            return b.replace(/[ \t]+\n/g, "\n")
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.prefixLines = function(a, b) {
            return b + a.replace(/(?!\n$)\n/g, "\n" + b)
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.allNestedComments = function(a) {
            var b = [];
            a = a.getDescendants(!0);
            for (var c = 0; c < a.length; c++) {
                var d = a[c].getCommentText();
                d && b.push(d)
            }
            b.length && b.push("");
            return b.join("\n")
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.blockToCode = function(a, b) {
            !1 === this.isInitialized && console.warn("Generator init was not called before blockToCode was called.");
            if (!a)
                return "";
            if (!a.isEnabled())
                return b ? "" : this.blockToCode(a.getNextBlock());
            if (a.isInsertionMarker())
                return b ? "" : this.blockToCode(a.getChildren(!1)[0]);
            var c = this[a.type];
            if ("function" !== typeof c)
                throw Error('Language "' + this.name_ + '" does not know how to generate code for block type "' + a.type + '".');
            c = c.call(a, a);
            if (Array.isArray(c)) {
                if (!a.outputConnection)
                    throw TypeError("Expecting string from statement block: " + a.type);
                return [this.scrub_(a, c[0], b), c[1]]
            }
            if ("string" === typeof c)
                return this.STATEMENT_PREFIX && !a.suppressPrefixSuffix && (c = this.injectId(this.STATEMENT_PREFIX, a) + c),
                this.STATEMENT_SUFFIX && !a.suppressPrefixSuffix && (c += this.injectId(this.STATEMENT_SUFFIX, a)),
                this.scrub_(a, c, b);
            if (null === c)
                return "";
            throw SyntaxError("Invalid code generated: " + c);
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.valueToCode = function(a, b, c) {
            if (isNaN(c))
                throw TypeError("Expecting valid order from block: " + a.type);
            var d = a.getInputTargetBlock(b);
            if (!d)
                return "";
            b = this.blockToCode(d);
            if ("" === b)
                return "";
            if (!Array.isArray(b))
                throw TypeError("Expecting tuple from value block: " + d.type);
            a = b[0];
            b = b[1];
            if (isNaN(b))
                throw TypeError("Expecting valid order from value block: " + d.type);
            if (!a)
                return "";
            d = !1;
            var f = Math.floor(c)
              , g = Math.floor(b);
            if (f <= g && (f !== g || 0 !== f && 99 !== f))
                for (d = !0,
                f = 0; f < this.ORDER_OVERRIDES.length; f++)
                    if (this.ORDER_OVERRIDES[f][0] === c && this.ORDER_OVERRIDES[f][1] === b) {
                        d = !1;
                        break
                    }
            d && (a = "(" + a + ")");
            return a
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.statementToCode = function(a, b) {
            a = a.getInputTargetBlock(b);
            b = this.blockToCode(a);
            if ("string" !== typeof b)
                throw TypeError("Expecting code from statement block: " + (a && a.type));
            b && (b = this.prefixLines(b, this.INDENT));
            return b
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.addLoopTrap = function(a, b) {
            this.INFINITE_LOOP_TRAP && (a = this.prefixLines(this.injectId(this.INFINITE_LOOP_TRAP, b), this.INDENT) + a);
            this.STATEMENT_SUFFIX && !b.suppressPrefixSuffix && (a = this.prefixLines(this.injectId(this.STATEMENT_SUFFIX, b), this.INDENT) + a);
            this.STATEMENT_PREFIX && !b.suppressPrefixSuffix && (a += this.prefixLines(this.injectId(this.STATEMENT_PREFIX, b), this.INDENT));
            return a
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.injectId = function(a, b) {
            b = b.id.replace(/\$/g, "$$$$");
            return a.replace(/%1/g, "'" + b + "'")
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.RESERVED_WORDS_ = "";
        e.module$exports$Blockly$Generator.Generator.prototype.addReservedWords = function(a) {
            this.RESERVED_WORDS_ += a + ","
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.FUNCTION_NAME_PLACEHOLDER_ = "{leCUI8hutHZI4480Dc}";
        Object.defineProperties(e.module$exports$Blockly$Generator.Generator.prototype, {
            variableDB_: {
                get: function() {
                    (0,
                    q.warn)("variableDB_", "May 2021", "May 2026", "nameDB_");
                    return this.nameDB_
                },
                set: function(a) {
                    (0,
                    q.warn)("variableDB_", "May 2021", "May 2026", "nameDB_");
                    this.nameDB_ = a
                }
            }
        });
        e.module$exports$Blockly$Generator.Generator.prototype.provideFunction_ = function(a, b) {
            if (!this.definitions_[a]) {
                var c = this.nameDB_.getDistinctName(a, e.module$exports$Blockly$Names.NameType.PROCEDURE);
                this.functionNames_[a] = c;
                b = b.join("\n").replace(this.FUNCTION_NAME_PLACEHOLDER_REGEXP_, c);
                for (var d; d !== b; )
                    d = b,
                    b = b.replace(/^(( {2})*) {2}/gm, "$1\x00");
                b = b.replace(/\0/g, this.INDENT);
                this.definitions_[a] = b
            }
            return this.functionNames_[a]
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.init = function(a) {
            this.definitions_ = Object.create(null);
            this.functionNames_ = Object.create(null)
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.scrub_ = function(a, b, c) {
            return b
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.finish = function(a) {
            delete this.definitions_;
            delete this.functionNames_;
            return a
        }
        ;
        e.module$exports$Blockly$Generator.Generator.prototype.scrubNakedValue = function(a) {
            return a
        }
        ;
        e.module$exports$Blockly$FieldDropdown = {
            FieldDropdown: function(a, b, c) {
                "function" !== typeof a && Pe(a);
                this.menuGenerator_ = a;
                this.suffixField = this.prefixField = this.generatedOptions_ = null;
                this.trimOptions_();
                this.selectedOption_ = this.getOptions(!1)[0];
                e.module$exports$Blockly$FieldDropdown.FieldDropdown.superClass_.constructor.call(this, this.selectedOption_[1], b, c);
                this.svgArrow_ = this.arrow_ = this.imageElement_ = this.menu_ = this.selectedMenuItem_ = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(e.module$exports$Blockly$FieldDropdown.FieldDropdown, I);
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.fromJson = function(a) {
            return new this(a.options,void 0,a)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.fromXml = function(a) {
            this.isOptionListDynamic() && this.getOptions(!1);
            this.setValue(a.textContent)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.loadState = function(a) {
            this.loadLegacyState(e.module$exports$Blockly$FieldDropdown.FieldDropdown, a) || (this.isOptionListDynamic() && this.getOptions(!1),
            this.setValue(a))
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.SERIALIZABLE = !0;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.CHECKMARK_OVERHANG = 25;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.MAX_MENU_HEIGHT_VH = .45;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.ARROW_CHAR = V.ANDROID ? "\u25bc" : "\u25be";
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.CURSOR = "default";
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.initView = function() {
            this.shouldAddBorderRect_() ? this.createBorderRect_() : this.clickTarget_ = this.sourceBlock_.getSvgRoot();
            this.createTextElement_();
            this.imageElement_ = (0,
            n.createSvgElement)(u.IMAGE, {}, this.fieldGroup_);
            this.getConstants().FIELD_DROPDOWN_SVG_ARROW ? this.createSVGArrow_() : this.createTextArrow_();
            this.borderRect_ && (0,
            n.addClass)(this.borderRect_, "blocklyDropdownRect")
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.shouldAddBorderRect_ = function() {
            return !this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW || this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW && !this.sourceBlock_.isShadow()
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.createTextArrow_ = function() {
            this.arrow_ = (0,
            n.createSvgElement)(u.TSPAN, {}, this.textElement_);
            this.arrow_.appendChild(document.createTextNode(this.sourceBlock_.RTL ? e.module$exports$Blockly$FieldDropdown.FieldDropdown.ARROW_CHAR + " " : " " + e.module$exports$Blockly$FieldDropdown.FieldDropdown.ARROW_CHAR));
            this.sourceBlock_.RTL ? this.textElement_.insertBefore(this.arrow_, this.textContent_) : this.textElement_.appendChild(this.arrow_)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.createSVGArrow_ = function() {
            this.svgArrow_ = (0,
            n.createSvgElement)(u.IMAGE, {
                height: this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + "px",
                width: this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + "px"
            }, this.fieldGroup_);
            this.svgArrow_.setAttributeNS(n.XLINK_NS, "xlink:href", this.getConstants().FIELD_DROPDOWN_SVG_ARROW_DATAURI)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.showEditor_ = function(a) {
            this.dropdownCreate_();
            this.menu_.openingCoords = a && "number" === typeof a.clientX ? new J(a.clientX,a.clientY) : null;
            C.clearContent();
            this.menu_.render(C.getContentDiv());
            a = this.menu_.getElement();
            (0,
            n.addClass)(a, "blocklyDropdownMenu");
            if (this.getConstants().FIELD_DROPDOWN_COLOURED_DIV) {
                a = this.sourceBlock_.isShadow() ? this.sourceBlock_.getParent().getColour() : this.sourceBlock_.getColour();
                var b = this.sourceBlock_.isShadow() ? this.sourceBlock_.getParent().style.colourTertiary : this.sourceBlock_.style.colourTertiary;
                C.setColour(a, b)
            }
            C.showPositionedByField(this, this.dropdownDispose_.bind(this));
            this.menu_.focus();
            this.selectedMenuItem_ && this.menu_.setHighlighted(this.selectedMenuItem_);
            this.applyColour()
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.dropdownCreate_ = function() {
            var a = new Ma;
            a.setRole(Q.Role.LISTBOX);
            this.menu_ = a;
            var b = this.getOptions(!1);
            this.selectedMenuItem_ = null;
            for (var c = 0; c < b.length; c++) {
                var d = b[c][0]
                  , f = b[c][1];
                if ("object" === typeof d) {
                    var g = new Image(d.width,d.height);
                    g.src = d.src;
                    g.alt = d.alt || "";
                    d = g
                }
                d = new eb(d,f);
                d.setRole(Q.Role.OPTION);
                d.setRightToLeft(this.sourceBlock_.RTL);
                d.setCheckable(!0);
                a.addChild(d);
                d.setChecked(f === this.value_);
                f === this.value_ && (this.selectedMenuItem_ = d);
                d.onAction(this.handleMenuActionEvent_, this)
            }
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.dropdownDispose_ = function() {
            this.menu_ && this.menu_.dispose();
            this.selectedMenuItem_ = this.menu_ = null;
            this.applyColour()
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.handleMenuActionEvent_ = function(a) {
            C.hideIfOwner(this, !0);
            this.onItemSelected_(this.menu_, a)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.onItemSelected_ = function(a, b) {
            this.setValue(b.getValue())
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.trimOptions_ = function() {
            var a = this.menuGenerator_;
            if (Array.isArray(a)) {
                for (var b = !1, c = 0; c < a.length; c++) {
                    var d = a[c][0];
                    "string" === typeof d ? a[c][0] = (0,
                    ka.replaceMessageReferences)(d) : (null !== d.alt && (a[c][0].alt = (0,
                    ka.replaceMessageReferences)(d.alt)),
                    b = !0)
                }
                if (!(b || 2 > a.length)) {
                    b = [];
                    for (c = 0; c < a.length; c++)
                        b.push(a[c][0]);
                    c = (0,
                    e.module$exports$Blockly$utils$string.shortestStringLength)(b);
                    d = (0,
                    e.module$exports$Blockly$utils$string.commonWordPrefix)(b, c);
                    var f = (0,
                    e.module$exports$Blockly$utils$string.commonWordSuffix)(b, c);
                    !d && !f || c <= d + f || (d && (this.prefixField = b[0].substring(0, d - 1)),
                    f && (this.suffixField = b[0].substr(1 - f)),
                    this.menuGenerator_ = e.module$exports$Blockly$FieldDropdown.FieldDropdown.applyTrim_(a, d, f))
                }
            }
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.applyTrim_ = function(a, b, c) {
            for (var d = [], f = 0; f < a.length; f++) {
                var g = a[f][0]
                  , m = a[f][1];
                g = g.substring(b, g.length - c);
                d[f] = [g, m]
            }
            return d
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.isOptionListDynamic = function() {
            return "function" === typeof this.menuGenerator_
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.getOptions = function(a) {
            return this.isOptionListDynamic() ? (this.generatedOptions_ && a || (this.generatedOptions_ = this.menuGenerator_.call(this),
            Pe(this.generatedOptions_)),
            this.generatedOptions_) : this.menuGenerator_
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.doClassValidation_ = function(a) {
            for (var b = !1, c = this.getOptions(!0), d = 0, f; f = c[d]; d++)
                if (f[1] === a) {
                    b = !0;
                    break
                }
            return b ? a : (this.sourceBlock_ && console.warn("Cannot set the dropdown's value to an unavailable option. Block type: " + this.sourceBlock_.type + ", Field name: " + this.name + ", Value: " + a),
            null)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.doValueUpdate_ = function(a) {
            e.module$exports$Blockly$FieldDropdown.FieldDropdown.superClass_.doValueUpdate_.call(this, a);
            a = this.getOptions(!0);
            for (var b = 0, c; c = a[b]; b++)
                c[1] === this.value_ && (this.selectedOption_ = c)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.applyColour = function() {
            this.borderRect_ && (this.borderRect_.setAttribute("stroke", this.sourceBlock_.style.colourTertiary),
            this.menu_ ? this.borderRect_.setAttribute("fill", this.sourceBlock_.style.colourTertiary) : this.borderRect_.setAttribute("fill", "transparent"));
            this.sourceBlock_ && this.arrow_ && (this.sourceBlock_.isShadow() ? this.arrow_.style.fill = this.sourceBlock_.style.colourSecondary : this.arrow_.style.fill = this.sourceBlock_.style.colourPrimary)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.render_ = function() {
            this.textContent_.nodeValue = "";
            this.imageElement_.style.display = "none";
            var a = this.selectedOption_ && this.selectedOption_[0];
            a && "object" === typeof a ? this.renderSelectedImage_(a) : this.renderSelectedText_();
            this.positionBorderRect_()
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.renderSelectedImage_ = function(a) {
            this.imageElement_.style.display = "";
            this.imageElement_.setAttributeNS(n.XLINK_NS, "xlink:href", a.src);
            this.imageElement_.setAttribute("height", a.height);
            this.imageElement_.setAttribute("width", a.width);
            var b = Number(a.height);
            a = Number(a.width);
            var c = !!this.borderRect_
              , d = Math.max(c ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0, b + 10);
            c = c ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;
            var f = this.svgArrow_ ? this.positionSVGArrow_(a + c, d / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2) : (0,
            n.getFastTextWidth)(this.arrow_, this.getConstants().FIELD_TEXT_FONTSIZE, this.getConstants().FIELD_TEXT_FONTWEIGHT, this.getConstants().FIELD_TEXT_FONTFAMILY);
            this.size_.width = a + f + 2 * c;
            this.size_.height = d;
            var g = 0;
            this.sourceBlock_.RTL ? this.imageElement_.setAttribute("x", c + f) : (g = a + f,
            this.textElement_.setAttribute("text-anchor", "end"),
            this.imageElement_.setAttribute("x", c));
            this.imageElement_.setAttribute("y", d / 2 - b / 2);
            this.positionTextElement_(g + c, a + f)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.renderSelectedText_ = function() {
            this.textContent_.nodeValue = this.getDisplayText_();
            (0,
            n.addClass)(this.textElement_, "blocklyDropdownText");
            this.textElement_.setAttribute("text-anchor", "start");
            var a = !!this.borderRect_
              , b = Math.max(a ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0, this.getConstants().FIELD_TEXT_HEIGHT)
              , c = (0,
            n.getFastTextWidth)(this.textElement_, this.getConstants().FIELD_TEXT_FONTSIZE, this.getConstants().FIELD_TEXT_FONTWEIGHT, this.getConstants().FIELD_TEXT_FONTFAMILY);
            a = a ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;
            var d = 0;
            this.svgArrow_ && (d = this.positionSVGArrow_(c + a, b / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2));
            this.size_.width = c + d + 2 * a;
            this.size_.height = b;
            this.positionTextElement_(a, c)
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.positionSVGArrow_ = function(a, b) {
            if (!this.svgArrow_)
                return 0;
            var c = this.borderRect_ ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0
              , d = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_PADDING
              , f = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE;
            this.svgArrow_.setAttribute("transform", "translate(" + (this.sourceBlock_.RTL ? c : a + d) + "," + b + ")");
            return f + d
        }
        ;
        e.module$exports$Blockly$FieldDropdown.FieldDropdown.prototype.getText_ = function() {
            if (!this.selectedOption_)
                return null;
            var a = this.selectedOption_[0];
            return "object" === typeof a ? a.alt : a
        }
        ;
        var Pe = function(a) {
            if (!Array.isArray(a))
                throw TypeError("FieldDropdown options must be an array.");
            if (!a.length)
                throw TypeError("FieldDropdown options must not be an empty array.");
            for (var b = !1, c = 0; c < a.length; c++) {
                var d = a[c];
                Array.isArray(d) ? "string" !== typeof d[1] ? (b = !0,
                console.error("Invalid option[" + c + "]: Each FieldDropdown option id must be a string. Found " + d[1] + " in: ", d)) : d[0] && "string" !== typeof d[0] && "string" !== typeof d[0].src && (b = !0,
                console.error("Invalid option[" + c + "]: Each FieldDropdown option must have a string label or image description. Found" + d[0] + " in: ", d)) : (b = !0,
                console.error("Invalid option[" + c + "]: Each FieldDropdown option must be an array. Found: ", d))
            }
            if (b)
                throw TypeError("Found invalid FieldDropdown options.");
        };
        (0,
        tb.register)("field_dropdown", e.module$exports$Blockly$FieldDropdown.FieldDropdown);
        var qa = {
            FieldVariable: function(a, b, c, d, f) {
                this.menuGenerator_ = qa.FieldVariable.dropdownCreate;
                this.defaultVariableName = "string" === typeof a ? a : "";
                this.size_ = new Pa(0,0);
                f && this.configure_(f);
                b && this.setValidator(b);
                f || this.setTypes_(c, d)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(qa.FieldVariable, e.module$exports$Blockly$FieldDropdown.FieldDropdown);
        qa.FieldVariable.fromJson = function(a) {
            return new this((0,
            ka.replaceMessageReferences)(a.variable),void 0,void 0,void 0,a)
        }
        ;
        qa.FieldVariable.prototype.SERIALIZABLE = !0;
        qa.FieldVariable.prototype.configure_ = function(a) {
            qa.FieldVariable.superClass_.configure_.call(this, a);
            this.setTypes_(a.variableTypes, a.defaultType)
        }
        ;
        qa.FieldVariable.prototype.initModel = function() {
            if (!this.variable_) {
                var a = (0,
                e.module$exports$Blockly$Variables.getOrCreateVariablePackage)(this.sourceBlock_.workspace, null, this.defaultVariableName, this.defaultType_);
                this.doValueUpdate_(a.getId())
            }
        }
        ;
        qa.FieldVariable.prototype.shouldAddBorderRect_ = function() {
            return qa.FieldVariable.superClass_.shouldAddBorderRect_.call(this) && (!this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW || "variables_get" !== this.sourceBlock_.type)
        }
        ;
        qa.FieldVariable.prototype.fromXml = function(a) {
            var b = a.getAttribute("id")
              , c = a.textContent
              , d = a.getAttribute("variabletype") || a.getAttribute("variableType") || "";
            b = (0,
            e.module$exports$Blockly$Variables.getOrCreateVariablePackage)(this.sourceBlock_.workspace, b, c, d);
            if (null !== d && d !== b.type)
                throw Error("Serialized variable type with id '" + b.getId() + "' had type " + b.type + ", and does not match variable field that references it: " + (0,
                e.module$exports$Blockly$Xml.domToText)(a) + ".");
            this.setValue(b.getId())
        }
        ;
        qa.FieldVariable.prototype.toXml = function(a) {
            this.initModel();
            a.id = this.variable_.getId();
            a.textContent = this.variable_.name;
            this.variable_.type && a.setAttribute("variabletype", this.variable_.type);
            return a
        }
        ;
        qa.FieldVariable.prototype.saveState = function(a) {
            var b = this.saveLegacyState(qa.FieldVariable);
            if (null !== b)
                return b;
            this.initModel();
            b = {
                id: this.variable_.getId()
            };
            a && (b.name = this.variable_.name,
            b.type = this.variable_.type);
            return b
        }
        ;
        qa.FieldVariable.prototype.loadState = function(a) {
            this.loadLegacyState(qa.FieldVariable, a) || (a = (0,
            e.module$exports$Blockly$Variables.getOrCreateVariablePackage)(this.sourceBlock_.workspace, a.id || null, a.name, a.type || ""),
            this.setValue(a.getId()))
        }
        ;
        qa.FieldVariable.prototype.setSourceBlock = function(a) {
            if (a.isShadow())
                throw Error("Variable fields are not allowed to exist on shadow blocks.");
            qa.FieldVariable.superClass_.setSourceBlock.call(this, a)
        }
        ;
        qa.FieldVariable.prototype.getValue = function() {
            return this.variable_ ? this.variable_.getId() : null
        }
        ;
        qa.FieldVariable.prototype.getText = function() {
            return this.variable_ ? this.variable_.name : ""
        }
        ;
        qa.FieldVariable.prototype.getVariable = function() {
            return this.variable_
        }
        ;
        qa.FieldVariable.prototype.getValidator = function() {
            return this.variable_ ? this.validator_ : null
        }
        ;
        qa.FieldVariable.prototype.doClassValidation_ = function(a) {
            if (null === a)
                return null;
            var b = (0,
            e.module$exports$Blockly$Variables.getVariable)(this.sourceBlock_.workspace, a);
            if (!b)
                return console.warn("Variable id doesn't point to a real variable! ID was " + a),
                null;
            b = b.type;
            return this.typeIsAllowed_(b) ? a : (console.warn("Variable type doesn't match this field!  Type was " + b),
            null)
        }
        ;
        qa.FieldVariable.prototype.doValueUpdate_ = function(a) {
            this.variable_ = (0,
            e.module$exports$Blockly$Variables.getVariable)(this.sourceBlock_.workspace, a);
            qa.FieldVariable.superClass_.doValueUpdate_.call(this, a)
        }
        ;
        qa.FieldVariable.prototype.typeIsAllowed_ = function(a) {
            var b = this.getVariableTypes_();
            if (!b)
                return !0;
            for (var c = 0; c < b.length; c++)
                if (a === b[c])
                    return !0;
            return !1
        }
        ;
        qa.FieldVariable.prototype.getVariableTypes_ = function() {
            var a = this.variableTypes;
            if (null === a && this.sourceBlock_ && this.sourceBlock_.workspace)
                return this.sourceBlock_.workspace.getVariableTypes();
            a = a || [""];
            if (0 === a.length)
                throw a = this.getText(),
                Error("'variableTypes' of field variable " + a + " was an empty list");
            return a
        }
        ;
        qa.FieldVariable.prototype.setTypes_ = function(a, b) {
            b = b || "";
            if (null === a || void 0 === a)
                a = null;
            else if (Array.isArray(a)) {
                for (var c = !1, d = 0; d < a.length; d++)
                    a[d] === b && (c = !0);
                if (!c)
                    throw Error("Invalid default type '" + b + "' in the definition of a FieldVariable");
            } else
                throw Error("'variableTypes' was not an array in the definition of a FieldVariable");
            this.defaultType_ = b;
            this.variableTypes = a
        }
        ;
        qa.FieldVariable.prototype.refreshVariableName = function() {
            this.forceRerender()
        }
        ;
        qa.FieldVariable.dropdownCreate = function() {
            if (!this.variable_)
                throw Error("Tried to call dropdownCreate on a variable field with no variable selected.");
            var a = this.getText()
              , b = [];
            if (this.sourceBlock_ && this.sourceBlock_.workspace)
                for (var c = this.getVariableTypes_(), d = 0; d < c.length; d++) {
                    var f = this.sourceBlock_.workspace.getVariablesOfType(c[d]);
                    b = b.concat(f)
                }
            b.sort(Hc.compareByName);
            c = [];
            for (d = 0; d < b.length; d++)
                c[d] = [b[d].name, b[d].getId()];
            c.push([e.module$exports$Blockly$Msg.Msg.RENAME_VARIABLE, e.module$exports$Blockly$internalConstants.RENAME_VARIABLE_ID]);
            e.module$exports$Blockly$Msg.Msg.DELETE_VARIABLE && c.push([e.module$exports$Blockly$Msg.Msg.DELETE_VARIABLE.replace("%1", a), e.module$exports$Blockly$internalConstants.DELETE_VARIABLE_ID]);
            return c
        }
        ;
        qa.FieldVariable.prototype.onItemSelected_ = function(a, b) {
            a = b.getValue();
            if (this.sourceBlock_ && this.sourceBlock_.workspace) {
                if (a === e.module$exports$Blockly$internalConstants.RENAME_VARIABLE_ID) {
                    (0,
                    e.module$exports$Blockly$Variables.renameVariable)(this.sourceBlock_.workspace, this.variable_);
                    return
                }
                if (a === e.module$exports$Blockly$internalConstants.DELETE_VARIABLE_ID) {
                    this.sourceBlock_.workspace.deleteVariableById(this.variable_.getId());
                    return
                }
            }
            this.setValue(a)
        }
        ;
        qa.FieldVariable.prototype.referencesVariables = function() {
            return !0
        }
        ;
        (0,
        tb.register)("field_variable", qa.FieldVariable);
        e.module$exports$Blockly$FieldTextInput = {
            FieldTextInput: function(a, b, c) {
                this.spellcheck_ = !0;
                e.module$exports$Blockly$FieldTextInput.FieldTextInput.superClass_.constructor.call(this, a, b, c);
                this.onKeyInputWrapper_ = this.onKeyDownWrapper_ = this.htmlInput_ = null;
                this.fullBlockClickTarget_ = !1;
                this.workspace_ = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(e.module$exports$Blockly$FieldTextInput.FieldTextInput, I);
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.DEFAULT_VALUE = "";
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.fromJson = function(a) {
            return new this((0,
            ka.replaceMessageReferences)(a.text),void 0,a)
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.SERIALIZABLE = !0;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.BORDERRADIUS = 4;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.CURSOR = "text";
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.configure_ = function(a) {
            e.module$exports$Blockly$FieldTextInput.FieldTextInput.superClass_.configure_.call(this, a);
            "boolean" === typeof a.spellcheck && (this.spellcheck_ = a.spellcheck)
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.initView = function() {
            if (this.getConstants().FULL_BLOCK_FIELDS) {
                for (var a = 0, b = 0, c = 0, d; d = this.sourceBlock_.inputList[c]; c++) {
                    for (var f = 0; d.fieldRow[f]; f++)
                        a++;
                    d.connection && b++
                }
                this.fullBlockClickTarget_ = 1 >= a && this.sourceBlock_.outputConnection && !b
            } else
                this.fullBlockClickTarget_ = !1;
            this.fullBlockClickTarget_ ? this.clickTarget_ = this.sourceBlock_.getSvgRoot() : this.createBorderRect_();
            this.createTextElement_()
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.doClassValidation_ = function(a) {
            return null === a || void 0 === a ? null : String(a)
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.doValueInvalid_ = function(a) {
            this.isBeingEdited_ && (this.isTextValid_ = !1,
            a = this.value_,
            this.value_ = this.htmlInput_.untypedDefaultValue_,
            this.sourceBlock_ && (0,
            k.isEnabled)() && (0,
            k.fire)(new ((0,
            k.get)(k.CHANGE))(this.sourceBlock_,"field",this.name || null,a,this.value_)))
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.doValueUpdate_ = function(a) {
            this.isTextValid_ = !0;
            this.value_ = a;
            this.isBeingEdited_ || (this.isDirty_ = !0)
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.applyColour = function() {
            this.sourceBlock_ && this.getConstants().FULL_BLOCK_FIELDS && (this.borderRect_ ? this.borderRect_.setAttribute("stroke", this.sourceBlock_.style.colourTertiary) : this.sourceBlock_.pathObject.svgPath.setAttribute("fill", this.getConstants().FIELD_BORDER_RECT_COLOUR))
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.render_ = function() {
            e.module$exports$Blockly$FieldTextInput.FieldTextInput.superClass_.render_.call(this);
            if (this.isBeingEdited_) {
                this.resizeEditor_();
                var a = this.htmlInput_;
                this.isTextValid_ ? ((0,
                n.removeClass)(a, "blocklyInvalidInput"),
                (0,
                Q.setState)(a, Q.State.INVALID, !1)) : ((0,
                n.addClass)(a, "blocklyInvalidInput"),
                (0,
                Q.setState)(a, Q.State.INVALID, !0))
            }
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.setSpellcheck = function(a) {
            a !== this.spellcheck_ && (this.spellcheck_ = a,
            this.htmlInput_ && this.htmlInput_.setAttribute("spellcheck", this.spellcheck_))
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.showEditor_ = function(a, b) {
            this.workspace_ = this.sourceBlock_.workspace;
            a = b || !1;
            !a && (V.MOBILE || V.ANDROID || V.IPAD) ? this.showPromptEditor_() : this.showInlineEditor_(a)
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.showPromptEditor_ = function() {
            (0,
            Ua.prompt)(e.module$exports$Blockly$Msg.Msg.CHANGE_VALUE_TITLE, this.getText(), function(a) {
                null !== a && this.setValue(this.getValueFromEditorText_(a))
            }
            .bind(this))
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.showInlineEditor_ = function(a) {
            (0,
            sa.show)(this, this.sourceBlock_.RTL, this.widgetDispose_.bind(this));
            this.htmlInput_ = this.widgetCreate_();
            this.isBeingEdited_ = !0;
            a || (this.htmlInput_.focus({
                preventScroll: !0
            }),
            this.htmlInput_.select())
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.widgetCreate_ = function() {
            (0,
            k.setGroup)(!0);
            var a = (0,
            sa.getDiv)();
            (0,
            n.addClass)(this.getClickTarget_(), "editing");
            var b = document.createElement("input");
            b.className = "blocklyHtmlInput";
            b.setAttribute("spellcheck", this.spellcheck_);
            var c = this.workspace_.getScale()
              , d = this.getConstants().FIELD_TEXT_FONTSIZE * c + "pt";
            a.style.fontSize = d;
            b.style.fontSize = d;
            d = e.module$exports$Blockly$FieldTextInput.FieldTextInput.BORDERRADIUS * c + "px";
            if (this.fullBlockClickTarget_) {
                d = this.getScaledBBox();
                d = (d.bottom - d.top) / 2 + "px";
                var f = this.sourceBlock_.getParent() ? this.sourceBlock_.getParent().style.colourTertiary : this.sourceBlock_.style.colourTertiary;
                b.style.border = 1 * c + "px solid " + f;
                a.style.borderRadius = d;
                a.style.transition = "box-shadow 0.25s ease 0s";
                this.getConstants().FIELD_TEXTINPUT_BOX_SHADOW && (a.style.boxShadow = "rgba(255, 255, 255, 0.3) 0 0 0 " + 4 * c + "px")
            }
            b.style.borderRadius = d;
            a.appendChild(b);
            b.value = b.defaultValue = this.getEditorText_(this.value_);
            b.untypedDefaultValue_ = this.value_;
            b.oldValue_ = null;
            this.resizeEditor_();
            this.bindInputEvents_(b);
            return b
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.widgetDispose_ = function() {
            this.isBeingEdited_ = !1;
            this.isTextValid_ = !0;
            this.forceRerender();
            if (this.onFinishEditing_)
                this.onFinishEditing_(this.value_);
            (0,
            k.setGroup)(!1);
            this.unbindInputEvents_();
            var a = (0,
            sa.getDiv)().style;
            a.width = "auto";
            a.height = "auto";
            a.fontSize = "";
            a.transition = "";
            a.boxShadow = "";
            this.htmlInput_ = null;
            (0,
            n.removeClass)(this.getClickTarget_(), "editing")
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.bindInputEvents_ = function(a) {
            this.onKeyDownWrapper_ = (0,
            y.conditionalBind)(a, "keydown", this, this.onHtmlInputKeyDown_);
            this.onKeyInputWrapper_ = (0,
            y.conditionalBind)(a, "input", this, this.onHtmlInputChange_)
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.unbindInputEvents_ = function() {
            this.onKeyDownWrapper_ && ((0,
            y.unbind)(this.onKeyDownWrapper_),
            this.onKeyDownWrapper_ = null);
            this.onKeyInputWrapper_ && ((0,
            y.unbind)(this.onKeyInputWrapper_),
            this.onKeyInputWrapper_ = null)
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.onHtmlInputKeyDown_ = function(a) {
            a.keyCode === M.ENTER ? ((0,
            sa.hide)(),
            C.hideWithoutAnimation()) : a.keyCode === M.ESC ? (this.setValue(this.htmlInput_.untypedDefaultValue_),
            (0,
            sa.hide)(),
            C.hideWithoutAnimation()) : a.keyCode === M.TAB && ((0,
            sa.hide)(),
            C.hideWithoutAnimation(),
            this.sourceBlock_.tab(this, !a.shiftKey),
            a.preventDefault())
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.onHtmlInputChange_ = function(a) {
            a = this.htmlInput_.value;
            a !== this.htmlInput_.oldValue_ && (this.htmlInput_.oldValue_ = a,
            a = this.getValueFromEditorText_(a),
            this.setValue(a),
            this.forceRerender(),
            this.resizeEditor_())
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.setEditorValue_ = function(a) {
            this.isDirty_ = !0;
            this.isBeingEdited_ && (this.htmlInput_.value = this.getEditorText_(a));
            this.setValue(a)
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.resizeEditor_ = function() {
            var a = (0,
            sa.getDiv)()
              , b = this.getScaledBBox();
            a.style.width = b.right - b.left + "px";
            a.style.height = b.bottom - b.top + "px";
            b = new J(this.sourceBlock_.RTL ? b.right - a.offsetWidth : b.left,b.top);
            a.style.left = b.x + "px";
            a.style.top = b.y + "px"
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.isTabNavigable = function() {
            return !0
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.getText_ = function() {
            return this.isBeingEdited_ && this.htmlInput_ ? this.htmlInput_.value : null
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.getEditorText_ = function(a) {
            return String(a)
        }
        ;
        e.module$exports$Blockly$FieldTextInput.FieldTextInput.prototype.getValueFromEditorText_ = function(a) {
            return a
        }
        ;
        (0,
        tb.register)("field_input", e.module$exports$Blockly$FieldTextInput.FieldTextInput);
        var Oa = {
            FieldNumber: function(a, b, c, d, f, g) {
                this.min_ = -Infinity;
                this.max_ = Infinity;
                this.precision_ = 0;
                this.decimalPlaces_ = null;
                Oa.FieldNumber.superClass_.constructor.call(this, a, f, g);
                g || this.setConstraints(b, c, d)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Oa.FieldNumber, e.module$exports$Blockly$FieldTextInput.FieldTextInput);
        Oa.FieldNumber.prototype.DEFAULT_VALUE = 0;
        Oa.FieldNumber.fromJson = function(a) {
            return new this(a.value,void 0,void 0,void 0,void 0,a)
        }
        ;
        Oa.FieldNumber.prototype.SERIALIZABLE = !0;
        Oa.FieldNumber.prototype.configure_ = function(a) {
            Oa.FieldNumber.superClass_.configure_.call(this, a);
            this.setMinInternal_(a.min);
            this.setMaxInternal_(a.max);
            this.setPrecisionInternal_(a.precision)
        }
        ;
        Oa.FieldNumber.prototype.setConstraints = function(a, b, c) {
            this.setMinInternal_(a);
            this.setMaxInternal_(b);
            this.setPrecisionInternal_(c);
            this.setValue(this.getValue())
        }
        ;
        Oa.FieldNumber.prototype.setMin = function(a) {
            this.setMinInternal_(a);
            this.setValue(this.getValue())
        }
        ;
        Oa.FieldNumber.prototype.setMinInternal_ = function(a) {
            null == a ? this.min_ = -Infinity : (a = Number(a),
            isNaN(a) || (this.min_ = a))
        }
        ;
        Oa.FieldNumber.prototype.getMin = function() {
            return this.min_
        }
        ;
        Oa.FieldNumber.prototype.setMax = function(a) {
            this.setMaxInternal_(a);
            this.setValue(this.getValue())
        }
        ;
        Oa.FieldNumber.prototype.setMaxInternal_ = function(a) {
            null == a ? this.max_ = Infinity : (a = Number(a),
            isNaN(a) || (this.max_ = a))
        }
        ;
        Oa.FieldNumber.prototype.getMax = function() {
            return this.max_
        }
        ;
        Oa.FieldNumber.prototype.setPrecision = function(a) {
            this.setPrecisionInternal_(a);
            this.setValue(this.getValue())
        }
        ;
        Oa.FieldNumber.prototype.setPrecisionInternal_ = function(a) {
            this.precision_ = Number(a) || 0;
            var b = String(this.precision_);
            -1 !== b.indexOf("e") && (b = this.precision_.toLocaleString("en-US", {
                maximumFractionDigits: 20
            }));
            var c = b.indexOf(".");
            this.decimalPlaces_ = -1 === c ? a ? 0 : null : b.length - c - 1
        }
        ;
        Oa.FieldNumber.prototype.getPrecision = function() {
            return this.precision_
        }
        ;
        Oa.FieldNumber.prototype.doClassValidation_ = function(a) {
            if (null === a)
                return null;
            a = String(a);
            a = a.replace(/O/ig, "0");
            a = a.replace(/,/g, "");
            a = a.replace(/infinity/i, "Infinity");
            a = Number(a || 0);
            if (isNaN(a))
                return null;
            a = Math.min(Math.max(a, this.min_), this.max_);
            this.precision_ && isFinite(a) && (a = Math.round(a / this.precision_) * this.precision_);
            null !== this.decimalPlaces_ && (a = Number(a.toFixed(this.decimalPlaces_)));
            return a
        }
        ;
        Oa.FieldNumber.prototype.widgetCreate_ = function() {
            var a = Oa.FieldNumber.superClass_.widgetCreate_.call(this);
            -Infinity < this.min_ && (0,
            Q.setState)(a, Q.State.VALUEMIN, this.min_);
            Infinity > this.max_ && (0,
            Q.setState)(a, Q.State.VALUEMAX, this.max_);
            return a
        }
        ;
        (0,
        tb.register)("field_number", Oa.FieldNumber);
        var Da = {
            FieldMultilineInput: function(a, b, c) {
                Da.FieldMultilineInput.superClass_.constructor.call(this, a, b, c);
                this.textGroup_ = null;
                this.maxLines_ = Infinity;
                this.isOverflowedY_ = !1
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Da.FieldMultilineInput, e.module$exports$Blockly$FieldTextInput.FieldTextInput);
        Da.FieldMultilineInput.prototype.configure_ = function(a) {
            Da.FieldMultilineInput.superClass_.configure_.call(this, a);
            a.maxLines && this.setMaxLines(a.maxLines)
        }
        ;
        Da.FieldMultilineInput.fromJson = function(a) {
            return new this((0,
            ka.replaceMessageReferences)(a.text),void 0,a)
        }
        ;
        Da.FieldMultilineInput.prototype.toXml = function(a) {
            a.textContent = this.getValue().replace(/\n/g, "&#10;");
            return a
        }
        ;
        Da.FieldMultilineInput.prototype.fromXml = function(a) {
            this.setValue(a.textContent.replace(/&#10;/g, "\n"))
        }
        ;
        Da.FieldMultilineInput.prototype.saveState = function() {
            var a = this.saveLegacyState(Da.FieldMultilineInput);
            return null !== a ? a : this.getValue()
        }
        ;
        Da.FieldMultilineInput.prototype.loadState = function(a) {
            this.loadLegacyState(I, a) || this.setValue(a)
        }
        ;
        Da.FieldMultilineInput.prototype.initView = function() {
            this.createBorderRect_();
            this.textGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyEditableText"
            }, this.fieldGroup_)
        }
        ;
        Da.FieldMultilineInput.prototype.getDisplayText_ = function() {
            var a = this.getText();
            if (!a)
                return I.NBSP;
            var b = a.split("\n");
            a = "";
            for (var c = this.isOverflowedY_ ? this.maxLines_ : b.length, d = 0; d < c; d++) {
                var f = b[d];
                f.length > this.maxDisplayLength ? f = f.substring(0, this.maxDisplayLength - 4) + "..." : this.isOverflowedY_ && d === c - 1 && (f = f.substring(0, f.length - 3) + "...");
                f = f.replace(/\s/g, I.NBSP);
                a += f;
                d !== c - 1 && (a += "\n")
            }
            this.sourceBlock_.RTL && (a += "\u200f");
            return a
        }
        ;
        Da.FieldMultilineInput.prototype.doValueUpdate_ = function(a) {
            Da.FieldMultilineInput.superClass_.doValueUpdate_.call(this, a);
            this.isOverflowedY_ = this.value_.split("\n").length > this.maxLines_
        }
        ;
        Da.FieldMultilineInput.prototype.render_ = function() {
            for (var a; a = this.textGroup_.firstChild; )
                this.textGroup_.removeChild(a);
            a = this.getDisplayText_().split("\n");
            for (var b = 0, c = 0; c < a.length; c++) {
                var d = this.getConstants().FIELD_TEXT_HEIGHT + this.getConstants().FIELD_BORDER_RECT_Y_PADDING;
                (0,
                n.createSvgElement)(u.TEXT, {
                    "class": "blocklyText blocklyMultilineText",
                    x: this.getConstants().FIELD_BORDER_RECT_X_PADDING,
                    y: b + this.getConstants().FIELD_BORDER_RECT_Y_PADDING,
                    dy: this.getConstants().FIELD_TEXT_BASELINE
                }, this.textGroup_).appendChild(document.createTextNode(a[c]));
                b += d
            }
            this.isBeingEdited_ && (a = this.htmlInput_,
            this.isOverflowedY_ ? (0,
            n.addClass)(a, "blocklyHtmlTextAreaInputOverflowedY") : (0,
            n.removeClass)(a, "blocklyHtmlTextAreaInputOverflowedY"));
            this.updateSize_();
            this.isBeingEdited_ && (this.sourceBlock_.RTL ? setTimeout(this.resizeEditor_.bind(this), 0) : this.resizeEditor_(),
            a = this.htmlInput_,
            this.isTextValid_ ? ((0,
            n.removeClass)(a, "blocklyInvalidInput"),
            (0,
            Q.setState)(a, Q.State.INVALID, !1)) : ((0,
            n.addClass)(a, "blocklyInvalidInput"),
            (0,
            Q.setState)(a, Q.State.INVALID, !0)))
        }
        ;
        Da.FieldMultilineInput.prototype.updateSize_ = function() {
            for (var a = this.textGroup_.childNodes, b = 0, c = 0, d = 0; d < a.length; d++) {
                var f = (0,
                n.getTextWidth)(a[d]);
                f > b && (b = f);
                c += this.getConstants().FIELD_TEXT_HEIGHT + (0 < d ? this.getConstants().FIELD_BORDER_RECT_Y_PADDING : 0)
            }
            if (this.isBeingEdited_) {
                a = this.value_.split("\n");
                d = (0,
                n.createSvgElement)(u.TEXT, {
                    "class": "blocklyText blocklyMultilineText"
                });
                f = this.getConstants().FIELD_TEXT_FONTSIZE;
                for (var g = this.getConstants().FIELD_TEXT_FONTWEIGHT, m = this.getConstants().FIELD_TEXT_FONTFAMILY, r = 0; r < a.length; r++) {
                    a[r].length > this.maxDisplayLength && (a[r] = a[r].substring(0, this.maxDisplayLength));
                    d.textContent = a[r];
                    var B = (0,
                    n.getFastTextWidth)(d, f, g, m);
                    B > b && (b = B)
                }
                b += this.htmlInput_.offsetWidth - this.htmlInput_.clientWidth
            }
            this.borderRect_ && (c += 2 * this.getConstants().FIELD_BORDER_RECT_Y_PADDING,
            b += 2 * this.getConstants().FIELD_BORDER_RECT_X_PADDING,
            this.borderRect_.setAttribute("width", b),
            this.borderRect_.setAttribute("height", c));
            this.size_.width = b;
            this.size_.height = c;
            this.positionBorderRect_()
        }
        ;
        Da.FieldMultilineInput.prototype.showEditor_ = function(a, b) {
            Da.FieldMultilineInput.superClass_.showEditor_.call(this, a, b);
            this.forceRerender()
        }
        ;
        Da.FieldMultilineInput.prototype.widgetCreate_ = function() {
            var a = (0,
            sa.getDiv)()
              , b = this.workspace_.getScale()
              , c = document.createElement("textarea");
            c.className = "blocklyHtmlInput blocklyHtmlTextAreaInput";
            c.setAttribute("spellcheck", this.spellcheck_);
            var d = this.getConstants().FIELD_TEXT_FONTSIZE * b + "pt";
            a.style.fontSize = d;
            c.style.fontSize = d;
            c.style.borderRadius = e.module$exports$Blockly$FieldTextInput.FieldTextInput.BORDERRADIUS * b + "px";
            d = this.getConstants().FIELD_BORDER_RECT_X_PADDING * b;
            var f = this.getConstants().FIELD_BORDER_RECT_Y_PADDING * b / 2;
            c.style.padding = f + "px " + d + "px " + f + "px " + d + "px";
            d = this.getConstants().FIELD_TEXT_HEIGHT + this.getConstants().FIELD_BORDER_RECT_Y_PADDING;
            c.style.lineHeight = d * b + "px";
            a.appendChild(c);
            c.value = c.defaultValue = this.getEditorText_(this.value_);
            c.untypedDefaultValue_ = this.value_;
            c.oldValue_ = null;
            V.GECKO ? setTimeout(this.resizeEditor_.bind(this), 0) : this.resizeEditor_();
            this.bindInputEvents_(c);
            return c
        }
        ;
        Da.FieldMultilineInput.prototype.setMaxLines = function(a) {
            "number" === typeof a && 0 < a && a !== this.maxLines_ && (this.maxLines_ = a,
            this.forceRerender())
        }
        ;
        Da.FieldMultilineInput.prototype.getMaxLines = function() {
            return this.maxLines_
        }
        ;
        Da.FieldMultilineInput.prototype.onHtmlInputKeyDown_ = function(a) {
            a.keyCode !== M.ENTER && Da.FieldMultilineInput.superClass_.onHtmlInputKeyDown_.call(this, a)
        }
        ;
        (0,
        v.register)("\n  .blocklyHtmlTextAreaInput {\n    font-family: monospace;\n    resize: none;\n    overflow: hidden;\n    height: 100%;\n    text-align: left;\n  }\n\n  .blocklyHtmlTextAreaInputOverflowedY {\n    overflow-y: scroll;\n  }\n");
        (0,
        tb.register)("field_multilinetext", Da.FieldMultilineInput);
        var Pc = {
            FieldLabelSerializable: function(a, b, c) {
                Pc.FieldLabelSerializable.superClass_.constructor.call(this, a, b, c)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Pc.FieldLabelSerializable, e.module$exports$Blockly$FieldLabel.FieldLabel);
        Pc.FieldLabelSerializable.fromJson = function(a) {
            return new this((0,
            ka.replaceMessageReferences)(a.text),void 0,a)
        }
        ;
        Pc.FieldLabelSerializable.prototype.EDITABLE = !1;
        Pc.FieldLabelSerializable.prototype.SERIALIZABLE = !0;
        (0,
        tb.register)("field_label_serializable", Pc.FieldLabelSerializable);
        var fa = {
            FieldColour: function(a, b, c) {
                fa.FieldColour.superClass_.constructor.call(this, a, b, c);
                this.onKeyDownWrapper_ = this.onMouseLeaveWrapper_ = this.onMouseEnterWrapper_ = this.onMouseMoveWrapper_ = this.onClickWrapper_ = this.highlightedIndex_ = this.picker_ = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(fa.FieldColour, I);
        fa.FieldColour.fromJson = function(a) {
            return new this(a.colour,void 0,a)
        }
        ;
        fa.FieldColour.prototype.SERIALIZABLE = !0;
        fa.FieldColour.prototype.CURSOR = "default";
        fa.FieldColour.prototype.isDirty_ = !1;
        fa.FieldColour.prototype.colours_ = null;
        fa.FieldColour.prototype.titles_ = null;
        fa.FieldColour.prototype.columns_ = 0;
        fa.FieldColour.prototype.configure_ = function(a) {
            fa.FieldColour.superClass_.configure_.call(this, a);
            a.colourOptions && (this.colours_ = a.colourOptions,
            this.titles_ = a.colourTitles);
            a.columns && (this.columns_ = a.columns)
        }
        ;
        fa.FieldColour.prototype.initView = function() {
            this.size_ = new Pa(this.getConstants().FIELD_COLOUR_DEFAULT_WIDTH,this.getConstants().FIELD_COLOUR_DEFAULT_HEIGHT);
            this.getConstants().FIELD_COLOUR_FULL_BLOCK ? this.clickTarget_ = this.sourceBlock_.getSvgRoot() : (this.createBorderRect_(),
            this.borderRect_.style.fillOpacity = "1")
        }
        ;
        fa.FieldColour.prototype.applyColour = function() {
            this.getConstants().FIELD_COLOUR_FULL_BLOCK ? (this.sourceBlock_.pathObject.svgPath.setAttribute("fill", this.getValue()),
            this.sourceBlock_.pathObject.svgPath.setAttribute("stroke", "#fff")) : this.borderRect_ && (this.borderRect_.style.fill = this.getValue())
        }
        ;
        fa.FieldColour.prototype.doClassValidation_ = function(a) {
            return "string" !== typeof a ? null : (0,
            na.parse)(a)
        }
        ;
        fa.FieldColour.prototype.doValueUpdate_ = function(a) {
            this.value_ = a;
            this.borderRect_ ? this.borderRect_.style.fill = a : this.sourceBlock_ && this.sourceBlock_.rendered && (this.sourceBlock_.pathObject.svgPath.setAttribute("fill", a),
            this.sourceBlock_.pathObject.svgPath.setAttribute("stroke", "#fff"))
        }
        ;
        fa.FieldColour.prototype.getText = function() {
            var a = this.value_;
            /^#(.)\1(.)\2(.)\3$/.test(a) && (a = "#" + a[1] + a[3] + a[5]);
            return a
        }
        ;
        fa.FieldColour.COLOURS = "#ffffff #cccccc #c0c0c0 #999999 #666666 #333333 #000000 #ffcccc #ff6666 #ff0000 #cc0000 #990000 #660000 #330000 #ffcc99 #ff9966 #ff9900 #ff6600 #cc6600 #993300 #663300 #ffff99 #ffff66 #ffcc66 #ffcc33 #cc9933 #996633 #663333 #ffffcc #ffff33 #ffff00 #ffcc00 #999900 #666600 #333300 #99ff99 #66ff99 #33ff33 #33cc00 #009900 #006600 #003300 #99ffff #33ffff #66cccc #00cccc #339999 #336666 #003333 #ccffff #66ffff #33ccff #3366ff #3333ff #000099 #000066 #ccccff #9999ff #6666cc #6633ff #6600cc #333399 #330099 #ffccff #ff99ff #cc66cc #cc33cc #993399 #663366 #330033".split(" ");
        fa.FieldColour.prototype.DEFAULT_VALUE = fa.FieldColour.COLOURS[0];
        fa.FieldColour.TITLES = [];
        fa.FieldColour.COLUMNS = 7;
        fa.FieldColour.prototype.setColours = function(a, b) {
            this.colours_ = a;
            b && (this.titles_ = b);
            return this
        }
        ;
        fa.FieldColour.prototype.setColumns = function(a) {
            this.columns_ = a;
            return this
        }
        ;
        fa.FieldColour.prototype.showEditor_ = function() {
            this.dropdownCreate_();
            C.getContentDiv().appendChild(this.picker_);
            C.showPositionedByField(this, this.dropdownDispose_.bind(this));
            this.picker_.focus({
                preventScroll: !0
            })
        }
        ;
        fa.FieldColour.prototype.onClick_ = function(a) {
            a = (a = a.target) && a.label;
            null !== a && (this.setValue(a),
            C.hideIfOwner(this))
        }
        ;
        fa.FieldColour.prototype.onKeyDown_ = function(a) {
            var b = !1;
            if (a.keyCode === M.UP)
                this.moveHighlightBy_(0, -1),
                b = !0;
            else if (a.keyCode === M.DOWN)
                this.moveHighlightBy_(0, 1),
                b = !0;
            else if (a.keyCode === M.LEFT)
                this.moveHighlightBy_(-1, 0),
                b = !0;
            else if (a.keyCode === M.RIGHT)
                this.moveHighlightBy_(1, 0),
                b = !0;
            else if (a.keyCode === M.ENTER) {
                if (b = this.getHighlighted_())
                    b = b && b.label,
                    null !== b && this.setValue(b);
                C.hideWithoutAnimation();
                b = !0
            }
            b && a.stopPropagation()
        }
        ;
        fa.FieldColour.prototype.moveHighlightBy_ = function(a, b) {
            var c = this.colours_ || fa.FieldColour.COLOURS
              , d = this.columns_ || fa.FieldColour.COLUMNS
              , f = this.highlightedIndex_ % d
              , g = Math.floor(this.highlightedIndex_ / d);
            f += a;
            g += b;
            0 > a ? 0 > f && 0 < g ? (f = d - 1,
            g--) : 0 > f && (f = 0) : 0 < a ? f > d - 1 && g < Math.floor(c.length / d) - 1 ? (f = 0,
            g++) : f > d - 1 && f-- : 0 > b ? 0 > g && (g = 0) : 0 < b && g > Math.floor(c.length / d) - 1 && (g = Math.floor(c.length / d) - 1);
            this.setHighlightedCell_(this.picker_.childNodes[g].childNodes[f], g * d + f)
        }
        ;
        fa.FieldColour.prototype.onMouseMove_ = function(a) {
            var b = (a = a.target) && Number(a.getAttribute("data-index"));
            null !== b && b !== this.highlightedIndex_ && this.setHighlightedCell_(a, b)
        }
        ;
        fa.FieldColour.prototype.onMouseEnter_ = function() {
            this.picker_.focus({
                preventScroll: !0
            })
        }
        ;
        fa.FieldColour.prototype.onMouseLeave_ = function() {
            this.picker_.blur();
            var a = this.getHighlighted_();
            a && (0,
            n.removeClass)(a, "blocklyColourHighlighted")
        }
        ;
        fa.FieldColour.prototype.getHighlighted_ = function() {
            var a = this.columns_ || fa.FieldColour.COLUMNS
              , b = this.picker_.childNodes[Math.floor(this.highlightedIndex_ / a)];
            return b ? b.childNodes[this.highlightedIndex_ % a] : null
        }
        ;
        fa.FieldColour.prototype.setHighlightedCell_ = function(a, b) {
            var c = this.getHighlighted_();
            c && (0,
            n.removeClass)(c, "blocklyColourHighlighted");
            (0,
            n.addClass)(a, "blocklyColourHighlighted");
            this.highlightedIndex_ = b;
            (0,
            Q.setState)(this.picker_, Q.State.ACTIVEDESCENDANT, a.getAttribute("id"))
        }
        ;
        fa.FieldColour.prototype.dropdownCreate_ = function() {
            var a = this.columns_ || fa.FieldColour.COLUMNS
              , b = this.colours_ || fa.FieldColour.COLOURS
              , c = this.titles_ || fa.FieldColour.TITLES
              , d = this.getValue()
              , f = document.createElement("table");
            f.className = "blocklyColourTable";
            f.tabIndex = 0;
            f.dir = "ltr";
            (0,
            Q.setRole)(f, Q.Role.GRID);
            (0,
            Q.setState)(f, Q.State.EXPANDED, !0);
            (0,
            Q.setState)(f, Q.State.ROWCOUNT, Math.floor(b.length / a));
            (0,
            Q.setState)(f, Q.State.COLCOUNT, a);
            for (var g, m = 0; m < b.length; m++) {
                0 === m % a && (g = document.createElement("tr"),
                (0,
                Q.setRole)(g, Q.Role.ROW),
                f.appendChild(g));
                var r = document.createElement("td");
                g.appendChild(r);
                r.label = b[m];
                r.title = c[m] || b[m];
                r.id = (0,
                bb.getNextUniqueId)();
                r.setAttribute("data-index", m);
                (0,
                Q.setRole)(r, Q.Role.GRIDCELL);
                (0,
                Q.setState)(r, Q.State.LABEL, b[m]);
                (0,
                Q.setState)(r, Q.State.SELECTED, b[m] === d);
                r.style.backgroundColor = b[m];
                b[m] === d && (r.className = "blocklyColourSelected",
                this.highlightedIndex_ = m)
            }
            this.onClickWrapper_ = (0,
            y.conditionalBind)(f, "click", this, this.onClick_, !0);
            this.onMouseMoveWrapper_ = (0,
            y.conditionalBind)(f, "mousemove", this, this.onMouseMove_, !0);
            this.onMouseEnterWrapper_ = (0,
            y.conditionalBind)(f, "mouseenter", this, this.onMouseEnter_, !0);
            this.onMouseLeaveWrapper_ = (0,
            y.conditionalBind)(f, "mouseleave", this, this.onMouseLeave_, !0);
            this.onKeyDownWrapper_ = (0,
            y.conditionalBind)(f, "keydown", this, this.onKeyDown_);
            this.picker_ = f
        }
        ;
        fa.FieldColour.prototype.dropdownDispose_ = function() {
            this.onClickWrapper_ && ((0,
            y.unbind)(this.onClickWrapper_),
            this.onClickWrapper_ = null);
            this.onMouseMoveWrapper_ && ((0,
            y.unbind)(this.onMouseMoveWrapper_),
            this.onMouseMoveWrapper_ = null);
            this.onMouseEnterWrapper_ && ((0,
            y.unbind)(this.onMouseEnterWrapper_),
            this.onMouseEnterWrapper_ = null);
            this.onMouseLeaveWrapper_ && ((0,
            y.unbind)(this.onMouseLeaveWrapper_),
            this.onMouseLeaveWrapper_ = null);
            this.onKeyDownWrapper_ && ((0,
            y.unbind)(this.onKeyDownWrapper_),
            this.onKeyDownWrapper_ = null);
            this.highlightedIndex_ = this.picker_ = null
        }
        ;
        (0,
        v.register)("\n  .blocklyColourTable {\n    border-collapse: collapse;\n    display: block;\n    outline: none;\n    padding: 1px;\n  }\n\n  .blocklyColourTable>tr>td {\n    border: .5px solid #888;\n    box-sizing: border-box;\n    cursor: pointer;\n    display: inline-block;\n    height: 20px;\n    padding: 0;\n    width: 20px;\n  }\n\n  .blocklyColourTable>tr>td.blocklyColourHighlighted {\n    border-color: #eee;\n    box-shadow: 2px 2px 7px 2px rgba(0,0,0,.3);\n    position: relative;\n  }\n\n  .blocklyColourSelected, .blocklyColourSelected:hover {\n    border-color: #eee !important;\n    outline: 1px solid #333;\n    position: relative;\n  }\n");
        (0,
        tb.register)("field_colour", fa.FieldColour);
        e.module$exports$Blockly$FieldCheckbox = {
            FieldCheckbox: function(a, b, c) {
                this.checkChar_ = null;
                e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.superClass_.constructor.call(this, a, b, c)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(e.module$exports$Blockly$FieldCheckbox.FieldCheckbox, I);
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.DEFAULT_VALUE = !1;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.fromJson = function(a) {
            return new this(a.checked,void 0,a)
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.CHECK_CHAR = "\u2713";
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.SERIALIZABLE = !0;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.CURSOR = "default";
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.configure_ = function(a) {
            e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.superClass_.configure_.call(this, a);
            a.checkCharacter && (this.checkChar_ = a.checkCharacter)
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.saveState = function() {
            var a = this.saveLegacyState(e.module$exports$Blockly$FieldCheckbox.FieldCheckbox);
            return null !== a ? a : this.getValueBoolean()
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.initView = function() {
            e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.superClass_.initView.call(this);
            (0,
            n.addClass)(this.textElement_, "blocklyCheckbox");
            this.textElement_.style.display = this.value_ ? "block" : "none"
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.render_ = function() {
            this.textContent_ && (this.textContent_.nodeValue = this.getDisplayText_());
            this.updateSize_(this.getConstants().FIELD_CHECKBOX_X_OFFSET)
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.getDisplayText_ = function() {
            return this.checkChar_ || e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.CHECK_CHAR
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.setCheckCharacter = function(a) {
            this.checkChar_ = a;
            this.forceRerender()
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.showEditor_ = function() {
            this.setValue(!this.value_)
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.doClassValidation_ = function(a) {
            return !0 === a || "TRUE" === a ? "TRUE" : !1 === a || "FALSE" === a ? "FALSE" : null
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.doValueUpdate_ = function(a) {
            this.value_ = this.convertValueToBool_(a);
            this.textElement_ && (this.textElement_.style.display = this.value_ ? "block" : "none")
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.getValue = function() {
            return this.value_ ? "TRUE" : "FALSE"
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.getValueBoolean = function() {
            return this.value_
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.getText = function() {
            return String(this.convertValueToBool_(this.value_))
        }
        ;
        e.module$exports$Blockly$FieldCheckbox.FieldCheckbox.prototype.convertValueToBool_ = function(a) {
            return "string" === typeof a ? "TRUE" === a : !!a
        }
        ;
        (0,
        tb.register)("field_checkbox", e.module$exports$Blockly$FieldCheckbox.FieldCheckbox);
        var T = {
            FieldAngle: function(a, b, c) {
                this.clockwise_ = T.FieldAngle.CLOCKWISE;
                this.offset_ = T.FieldAngle.OFFSET;
                this.wrap_ = T.FieldAngle.WRAP;
                this.round_ = T.FieldAngle.ROUND;
                T.FieldAngle.superClass_.constructor.call(this, a, b, c);
                this.moveSurfaceWrapper_ = this.clickSurfaceWrapper_ = this.clickWrapper_ = this.line_ = this.gauge_ = this.editor_ = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(T.FieldAngle, e.module$exports$Blockly$FieldTextInput.FieldTextInput);
        T.FieldAngle.prototype.DEFAULT_VALUE = 0;
        T.FieldAngle.fromJson = function(a) {
            return new this(a.angle,void 0,a)
        }
        ;
        T.FieldAngle.prototype.SERIALIZABLE = !0;
        T.FieldAngle.ROUND = 15;
        T.FieldAngle.HALF = 50;
        T.FieldAngle.CLOCKWISE = !1;
        T.FieldAngle.OFFSET = 0;
        T.FieldAngle.WRAP = 360;
        T.FieldAngle.RADIUS = T.FieldAngle.HALF - 1;
        T.FieldAngle.prototype.configure_ = function(a) {
            T.FieldAngle.superClass_.configure_.call(this, a);
            switch (a.mode) {
            case "compass":
                this.clockwise_ = !0;
                this.offset_ = 90;
                break;
            case "protractor":
                this.clockwise_ = !1,
                this.offset_ = 0
            }
            var b = a.clockwise;
            "boolean" === typeof b && (this.clockwise_ = b);
            b = a.offset;
            null !== b && (b = Number(b),
            isNaN(b) || (this.offset_ = b));
            b = a.wrap;
            null !== b && (b = Number(b),
            isNaN(b) || (this.wrap_ = b));
            a = a.round;
            null !== a && (a = Number(a),
            isNaN(a) || (this.round_ = a))
        }
        ;
        T.FieldAngle.prototype.initView = function() {
            T.FieldAngle.superClass_.initView.call(this);
            this.symbol_ = (0,
            n.createSvgElement)(u.TSPAN, {}, null);
            this.symbol_.appendChild(document.createTextNode("\u00b0"));
            this.textElement_.appendChild(this.symbol_)
        }
        ;
        T.FieldAngle.prototype.render_ = function() {
            T.FieldAngle.superClass_.render_.call(this);
            this.updateGraph_()
        }
        ;
        T.FieldAngle.prototype.showEditor_ = function(a) {
            T.FieldAngle.superClass_.showEditor_.call(this, a, V.MOBILE || V.ANDROID || V.IPAD);
            this.dropdownCreate_();
            C.getContentDiv().appendChild(this.editor_);
            C.setColour(this.sourceBlock_.style.colourPrimary, this.sourceBlock_.style.colourTertiary);
            C.showPositionedByField(this, this.dropdownDispose_.bind(this));
            this.updateGraph_()
        }
        ;
        T.FieldAngle.prototype.dropdownCreate_ = function() {
            var a = (0,
            n.createSvgElement)(u.SVG, {
                xmlns: n.SVG_NS,
                "xmlns:html": n.HTML_NS,
                "xmlns:xlink": n.XLINK_NS,
                version: "1.1",
                height: 2 * T.FieldAngle.HALF + "px",
                width: 2 * T.FieldAngle.HALF + "px",
                style: "touch-action: none"
            }, null)
              , b = (0,
            n.createSvgElement)(u.CIRCLE, {
                cx: T.FieldAngle.HALF,
                cy: T.FieldAngle.HALF,
                r: T.FieldAngle.RADIUS,
                "class": "blocklyAngleCircle"
            }, a);
            this.gauge_ = (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyAngleGauge"
            }, a);
            this.line_ = (0,
            n.createSvgElement)(u.LINE, {
                x1: T.FieldAngle.HALF,
                y1: T.FieldAngle.HALF,
                "class": "blocklyAngleLine"
            }, a);
            for (var c = 0; 360 > c; c += 15)
                (0,
                n.createSvgElement)(u.LINE, {
                    x1: T.FieldAngle.HALF + T.FieldAngle.RADIUS,
                    y1: T.FieldAngle.HALF,
                    x2: T.FieldAngle.HALF + T.FieldAngle.RADIUS - (0 === c % 45 ? 10 : 5),
                    y2: T.FieldAngle.HALF,
                    "class": "blocklyAngleMarks",
                    transform: "rotate(" + c + "," + T.FieldAngle.HALF + "," + T.FieldAngle.HALF + ")"
                }, a);
            this.clickWrapper_ = (0,
            y.conditionalBind)(a, "click", this, this.hide_);
            this.clickSurfaceWrapper_ = (0,
            y.conditionalBind)(b, "click", this, this.onMouseMove_, !0, !0);
            this.moveSurfaceWrapper_ = (0,
            y.conditionalBind)(b, "mousemove", this, this.onMouseMove_, !0, !0);
            this.editor_ = a
        }
        ;
        T.FieldAngle.prototype.dropdownDispose_ = function() {
            this.clickWrapper_ && ((0,
            y.unbind)(this.clickWrapper_),
            this.clickWrapper_ = null);
            this.clickSurfaceWrapper_ && ((0,
            y.unbind)(this.clickSurfaceWrapper_),
            this.clickSurfaceWrapper_ = null);
            this.moveSurfaceWrapper_ && ((0,
            y.unbind)(this.moveSurfaceWrapper_),
            this.moveSurfaceWrapper_ = null);
            this.line_ = this.gauge_ = null
        }
        ;
        T.FieldAngle.prototype.hide_ = function() {
            C.hideIfOwner(this);
            (0,
            sa.hide)()
        }
        ;
        T.FieldAngle.prototype.onMouseMove_ = function(a) {
            var b = this.gauge_.ownerSVGElement.getBoundingClientRect()
              , c = a.clientX - b.left - T.FieldAngle.HALF;
            a = a.clientY - b.top - T.FieldAngle.HALF;
            b = Math.atan(-a / c);
            isNaN(b) || (b = (0,
            Eb.toDegrees)(b),
            0 > c ? b += 180 : 0 < a && (b += 360),
            b = this.clockwise_ ? this.offset_ + 360 - b : 360 - (this.offset_ - b),
            this.displayMouseOrKeyboardValue_(b))
        }
        ;
        T.FieldAngle.prototype.displayMouseOrKeyboardValue_ = function(a) {
            this.round_ && (a = Math.round(a / this.round_) * this.round_);
            a = this.wrapValue_(a);
            a !== this.value_ && this.setEditorValue_(a)
        }
        ;
        T.FieldAngle.prototype.updateGraph_ = function() {
            if (this.gauge_) {
                var a = Number(this.getText()) + this.offset_
                  , b = (0,
                Eb.toRadians)(a % 360);
                a = ["M ", T.FieldAngle.HALF, ",", T.FieldAngle.HALF];
                var c = T.FieldAngle.HALF
                  , d = T.FieldAngle.HALF;
                if (!isNaN(b)) {
                    var f = Number(this.clockwise_)
                      , g = (0,
                    Eb.toRadians)(this.offset_)
                      , m = Math.cos(g) * T.FieldAngle.RADIUS
                      , r = Math.sin(g) * -T.FieldAngle.RADIUS;
                    f && (b = 2 * g - b);
                    c += Math.cos(b) * T.FieldAngle.RADIUS;
                    d -= Math.sin(b) * T.FieldAngle.RADIUS;
                    b = Math.abs(Math.floor((b - g) / Math.PI) % 2);
                    f && (b = 1 - b);
                    a.push(" l ", m, ",", r, " A ", T.FieldAngle.RADIUS, ",", T.FieldAngle.RADIUS, " 0 ", b, " ", f, " ", c, ",", d, " z")
                }
                this.gauge_.setAttribute("d", a.join(""));
                this.line_.setAttribute("x2", c);
                this.line_.setAttribute("y2", d)
            }
        }
        ;
        T.FieldAngle.prototype.onHtmlInputKeyDown_ = function(a) {
            T.FieldAngle.superClass_.onHtmlInputKeyDown_.call(this, a);
            var b;
            a.keyCode === M.LEFT ? b = this.sourceBlock_.RTL ? 1 : -1 : a.keyCode === M.RIGHT ? b = this.sourceBlock_.RTL ? -1 : 1 : a.keyCode === M.DOWN ? b = -1 : a.keyCode === M.UP && (b = 1);
            if (b) {
                var c = this.getValue();
                this.displayMouseOrKeyboardValue_(c + b * this.round_);
                a.preventDefault();
                a.stopPropagation()
            }
        }
        ;
        T.FieldAngle.prototype.doClassValidation_ = function(a) {
            a = Number(a);
            return isNaN(a) || !isFinite(a) ? null : this.wrapValue_(a)
        }
        ;
        T.FieldAngle.prototype.wrapValue_ = function(a) {
            a %= 360;
            0 > a && (a += 360);
            a > this.wrap_ && (a -= 360);
            return a
        }
        ;
        (0,
        v.register)("\n  .blocklyAngleCircle {\n    stroke: #444;\n    stroke-width: 1;\n    fill: #ddd;\n    fill-opacity: .8;\n  }\n\n  .blocklyAngleMarks {\n    stroke: #444;\n    stroke-width: 1;\n  }\n\n  .blocklyAngleGauge {\n    fill: #f88;\n    fill-opacity: .8;\n    pointer-events: none;\n  }\n\n  .blocklyAngleLine {\n    stroke: #f00;\n    stroke-width: 2;\n    stroke-linecap: round;\n    pointer-events: none;\n  }\n");
        (0,
        tb.register)("field_angle", T.FieldAngle);
        var Qc = {
            TopRow: function(a) {
                Qc.TopRow.superClass_.constructor.call(this, a)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Qc.TopRow, dc.TopRow);
        Qc.TopRow.prototype.endsWithElemSpacer = function() {
            return !1
        }
        ;
        Qc.TopRow.prototype.hasLeftSquareCorner = function(a) {
            var b = (a.hat ? "cap" === a.hat : this.constants_.ADD_START_HATS) && !a.outputConnection && !a.previousConnection;
            return !!a.outputConnection || b
        }
        ;
        Qc.TopRow.prototype.hasRightSquareCorner = function(a) {
            return !!a.outputConnection && !a.statementInputCount && !a.nextConnection
        }
        ;
        var Jd = {
            StatementInput: function(a, b) {
                Jd.StatementInput.superClass_.constructor.call(this, a, b);
                if (this.connectedBlock) {
                    for (a = this.connectedBlock; b = a.getNextBlock(); )
                        a = b;
                    a.nextConnection || (this.height = this.connectedBlockHeight,
                    this.connectedBottomNextConnection = !0)
                }
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Jd.StatementInput, Xc.StatementInput);
        var Kd = {
            RightConnectionShape: function(a) {
                Kd.RightConnectionShape.superClass_.constructor.call(this, a);
                this.type |= p.getType("RIGHT_CONNECTION");
                this.width = this.height = 0
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Kd.RightConnectionShape, Zb);
        var rb = {
            MarkerSvg: function(a, b, c) {
                rb.MarkerSvg.superClass_.constructor.call(this, a, b, c)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(rb.MarkerSvg, pa);
        rb.MarkerSvg.prototype.showWithInputOutput_ = function(a) {
            var b = a.getSourceBlock();
            a = a.getLocation().getOffsetInBlock();
            this.positionCircle_(a.x, a.y);
            this.setParent_(b);
            this.showCurrent_()
        }
        ;
        rb.MarkerSvg.prototype.showWithOutput_ = function(a) {
            this.showWithInputOutput_(a)
        }
        ;
        rb.MarkerSvg.prototype.showWithInput_ = function(a) {
            this.showWithInputOutput_(a)
        }
        ;
        rb.MarkerSvg.prototype.showWithBlock_ = function(a) {
            a = a.getLocation();
            var b = a.getHeightWidth();
            this.positionRect_(0, 0, b.width, b.height);
            this.setParent_(a);
            this.showCurrent_()
        }
        ;
        rb.MarkerSvg.prototype.positionCircle_ = function(a, b) {
            this.markerCircle_.setAttribute("cx", a);
            this.markerCircle_.setAttribute("cy", b);
            this.currentMarkerSvg = this.markerCircle_
        }
        ;
        rb.MarkerSvg.prototype.hide = function() {
            rb.MarkerSvg.superClass_.hide.call(this);
            this.markerCircle_.style.display = "none"
        }
        ;
        rb.MarkerSvg.prototype.createDomInternal_ = function() {
            rb.MarkerSvg.superClass_.createDomInternal_.call(this);
            this.markerCircle_ = (0,
            n.createSvgElement)(u.CIRCLE, {
                r: this.constants_.CURSOR_RADIUS,
                style: "display: none",
                "stroke-width": this.constants_.CURSOR_STROKE_WIDTH
            }, this.markerSvg_);
            if (this.isCursor()) {
                var a = this.getBlinkProperties_();
                (0,
                n.createSvgElement)(u.ANIMATE, a, this.markerCircle_)
            }
            return this.markerSvg_
        }
        ;
        rb.MarkerSvg.prototype.applyColour_ = function(a) {
            rb.MarkerSvg.superClass_.applyColour_.call(this, a);
            this.markerCircle_.setAttribute("fill", this.colour_);
            this.markerCircle_.setAttribute("stroke", this.colour_);
            this.isCursor() && this.markerCircle_.firstChild.setAttribute("values", this.colour_ + ";transparent;transparent;")
        }
        ;
        var Ja = {
            ConstantProvider: function() {
                Ja.ConstantProvider.superClass_.constructor.call(this);
                this.SMALL_PADDING = this.GRID_UNIT = 4;
                this.MEDIUM_PADDING = 2 * this.GRID_UNIT;
                this.MEDIUM_LARGE_PADDING = 3 * this.GRID_UNIT;
                this.LARGE_PADDING = 4 * this.GRID_UNIT;
                this.CORNER_RADIUS = 1 * this.GRID_UNIT;
                this.NOTCH_WIDTH = 9 * this.GRID_UNIT;
                this.NOTCH_HEIGHT = 2 * this.GRID_UNIT;
                this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT = 3 * this.GRID_UNIT;
                this.MIN_BLOCK_WIDTH = 2 * this.GRID_UNIT;
                this.MIN_BLOCK_HEIGHT = 12 * this.GRID_UNIT;
                this.EMPTY_STATEMENT_INPUT_HEIGHT = 6 * this.GRID_UNIT;
                this.TAB_OFFSET_FROM_TOP = 0;
                this.TOP_ROW_MIN_HEIGHT = this.CORNER_RADIUS;
                this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING;
                this.BOTTOM_ROW_MIN_HEIGHT = this.CORNER_RADIUS;
                this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = 6 * this.GRID_UNIT;
                this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT;
                this.STATEMENT_INPUT_SPACER_MIN_WIDTH = 40 * this.GRID_UNIT;
                this.STATEMENT_INPUT_PADDING_LEFT = 4 * this.GRID_UNIT;
                this.EMPTY_INLINE_INPUT_PADDING = 4 * this.GRID_UNIT;
                this.EMPTY_INLINE_INPUT_HEIGHT = 8 * this.GRID_UNIT;
                this.DUMMY_INPUT_MIN_HEIGHT = 8 * this.GRID_UNIT;
                this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = 6 * this.GRID_UNIT;
                this.CURSOR_WS_WIDTH = 20 * this.GRID_UNIT;
                this.CURSOR_COLOUR = "#ffa200";
                this.CURSOR_RADIUS = 5;
                this.JAGGED_TEETH_WIDTH = this.JAGGED_TEETH_HEIGHT = 0;
                this.START_HAT_HEIGHT = 22;
                this.START_HAT_WIDTH = 96;
                this.SHAPES = {
                    HEXAGONAL: 1,
                    ROUND: 2,
                    SQUARE: 3,
                    PUZZLE: 4,
                    NOTCH: 5
                };
                this.SHAPE_IN_SHAPE_PADDING = {
                    1: {
                        0: 5 * this.GRID_UNIT,
                        1: 2 * this.GRID_UNIT,
                        2: 5 * this.GRID_UNIT,
                        3: 5 * this.GRID_UNIT
                    },
                    2: {
                        0: 3 * this.GRID_UNIT,
                        1: 3 * this.GRID_UNIT,
                        2: 1 * this.GRID_UNIT,
                        3: 2 * this.GRID_UNIT
                    },
                    3: {
                        0: 2 * this.GRID_UNIT,
                        1: 2 * this.GRID_UNIT,
                        2: 2 * this.GRID_UNIT,
                        3: 2 * this.GRID_UNIT
                    }
                };
                this.FULL_BLOCK_FIELDS = !0;
                this.FIELD_TEXT_FONTSIZE = 3 * this.GRID_UNIT;
                this.FIELD_TEXT_FONTWEIGHT = "bold";
                this.FIELD_TEXT_FONTFAMILY = '"Helvetica Neue", "Segoe UI", Helvetica, sans-serif';
                this.FIELD_BORDER_RECT_RADIUS = this.CORNER_RADIUS;
                this.FIELD_BORDER_RECT_X_PADDING = 2 * this.GRID_UNIT;
                this.FIELD_BORDER_RECT_Y_PADDING = 1.625 * this.GRID_UNIT;
                this.FIELD_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT;
                this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT;
                this.FIELD_DROPDOWN_SVG_ARROW = this.FIELD_DROPDOWN_COLOURED_DIV = this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = !0;
                this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING;
                this.FIELD_COLOUR_FULL_BLOCK = this.FIELD_TEXTINPUT_BOX_SHADOW = !0;
                this.FIELD_COLOUR_DEFAULT_WIDTH = 2 * this.GRID_UNIT;
                this.FIELD_COLOUR_DEFAULT_HEIGHT = 4 * this.GRID_UNIT;
                this.FIELD_CHECKBOX_X_OFFSET = 1 * this.GRID_UNIT;
                this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH = 12 * this.GRID_UNIT;
                this.SELECTED_GLOW_COLOUR = "#fff200";
                this.SELECTED_GLOW_SIZE = .5;
                this.REPLACEMENT_GLOW_COLOUR = "#fff200";
                this.REPLACEMENT_GLOW_SIZE = 2;
                this.selectedGlowFilterId = "";
                this.selectedGlowFilter_ = null;
                this.replacementGlowFilterId = "";
                this.replacementGlowFilter_ = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Ja.ConstantProvider, va);
        Ja.ConstantProvider.prototype.setFontConstants_ = function(a) {
            Ja.ConstantProvider.superClass_.setFontConstants_.call(this, a);
            this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT = this.FIELD_TEXT_HEIGHT + 2 * this.FIELD_BORDER_RECT_Y_PADDING
        }
        ;
        Ja.ConstantProvider.prototype.init = function() {
            Ja.ConstantProvider.superClass_.init.call(this);
            this.HEXAGONAL = this.makeHexagonal();
            this.ROUNDED = this.makeRounded();
            this.SQUARED = this.makeSquared();
            this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT + this.INSIDE_CORNERS.rightWidth
        }
        ;
        Ja.ConstantProvider.prototype.setDynamicProperties_ = function(a) {
            Ja.ConstantProvider.superClass_.setDynamicProperties_.call(this, a);
            this.SELECTED_GLOW_COLOUR = a.getComponentStyle("selectedGlowColour") || this.SELECTED_GLOW_COLOUR;
            var b = Number(a.getComponentStyle("selectedGlowSize"));
            this.SELECTED_GLOW_SIZE = b && !isNaN(b) ? b : this.SELECTED_GLOW_SIZE;
            this.REPLACEMENT_GLOW_COLOUR = a.getComponentStyle("replacementGlowColour") || this.REPLACEMENT_GLOW_COLOUR;
            this.REPLACEMENT_GLOW_SIZE = (a = Number(a.getComponentStyle("replacementGlowSize"))) && !isNaN(a) ? a : this.REPLACEMENT_GLOW_SIZE
        }
        ;
        Ja.ConstantProvider.prototype.dispose = function() {
            Ja.ConstantProvider.superClass_.dispose.call(this);
            this.selectedGlowFilter_ && (0,
            n.removeNode)(this.selectedGlowFilter_);
            this.replacementGlowFilter_ && (0,
            n.removeNode)(this.replacementGlowFilter_)
        }
        ;
        Ja.ConstantProvider.prototype.makeStartHat = function() {
            var a = this.START_HAT_HEIGHT
              , b = this.START_HAT_WIDTH
              , c = (0,
            t.curve)("c", [(0,
            t.point)(25, -a), (0,
            t.point)(71, -a), (0,
            t.point)(b, 0)]);
            return {
                height: a,
                width: b,
                path: c
            }
        }
        ;
        Ja.ConstantProvider.prototype.makeHexagonal = function() {
            function a(c, d, f) {
                var g = c / 2;
                g = g > b ? b : g;
                f = f ? -1 : 1;
                c = (d ? -1 : 1) * c / 2;
                return (0,
                t.lineTo)(-f * g, c) + (0,
                t.lineTo)(f * g, c)
            }
            var b = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH;
            return {
                type: this.SHAPES.HEXAGONAL,
                isDynamic: !0,
                width: function(c) {
                    c /= 2;
                    return c > b ? b : c
                },
                height: function(c) {
                    return c
                },
                connectionOffsetY: function(c) {
                    return c / 2
                },
                connectionOffsetX: function(c) {
                    return -c
                },
                pathDown: function(c) {
                    return a(c, !1, !1)
                },
                pathUp: function(c) {
                    return a(c, !0, !1)
                },
                pathRightDown: function(c) {
                    return a(c, !1, !0)
                },
                pathRightUp: function(c) {
                    return a(c, !1, !0)
                }
            }
        }
        ;
        Ja.ConstantProvider.prototype.makeRounded = function() {
            function a(d, f, g) {
                var m = d > c ? d - c : 0;
                d = (d > c ? c : d) / 2;
                return (0,
                t.arc)("a", "0 0,1", d, (0,
                t.point)((f ? -1 : 1) * d, (f ? -1 : 1) * d)) + (0,
                t.lineOnAxis)("v", (g ? 1 : -1) * m) + (0,
                t.arc)("a", "0 0,1", d, (0,
                t.point)((f ? 1 : -1) * d, (f ? -1 : 1) * d))
            }
            var b = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH
              , c = 2 * b;
            return {
                type: this.SHAPES.ROUND,
                isDynamic: !0,
                width: function(d) {
                    d /= 2;
                    return d > b ? b : d
                },
                height: function(d) {
                    return d
                },
                connectionOffsetY: function(d) {
                    return d / 2
                },
                connectionOffsetX: function(d) {
                    return -d
                },
                pathDown: function(d) {
                    return a(d, !1, !1)
                },
                pathUp: function(d) {
                    return a(d, !0, !1)
                },
                pathRightDown: function(d) {
                    return a(d, !1, !0)
                },
                pathRightUp: function(d) {
                    return a(d, !1, !0)
                }
            }
        }
        ;
        Ja.ConstantProvider.prototype.makeSquared = function() {
            function a(c, d, f) {
                c -= 2 * b;
                return (0,
                t.arc)("a", "0 0,1", b, (0,
                t.point)((d ? -1 : 1) * b, (d ? -1 : 1) * b)) + (0,
                t.lineOnAxis)("v", (f ? 1 : -1) * c) + (0,
                t.arc)("a", "0 0,1", b, (0,
                t.point)((d ? 1 : -1) * b, (d ? -1 : 1) * b))
            }
            var b = this.CORNER_RADIUS;
            return {
                type: this.SHAPES.SQUARE,
                isDynamic: !0,
                width: function(c) {
                    return b
                },
                height: function(c) {
                    return c
                },
                connectionOffsetY: function(c) {
                    return c / 2
                },
                connectionOffsetX: function(c) {
                    return -c
                },
                pathDown: function(c) {
                    return a(c, !1, !1)
                },
                pathUp: function(c) {
                    return a(c, !0, !1)
                },
                pathRightDown: function(c) {
                    return a(c, !1, !0)
                },
                pathRightUp: function(c) {
                    return a(c, !1, !0)
                }
            }
        }
        ;
        Ja.ConstantProvider.prototype.shapeFor = function(a) {
            var b = a.getCheck();
            !b && a.targetConnection && (b = a.targetConnection.getCheck());
            switch (a.type) {
            case e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE:
            case e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE:
                a = a.getSourceBlock().getOutputShape();
                if (null !== a)
                    switch (a) {
                    case this.SHAPES.HEXAGONAL:
                        return this.HEXAGONAL;
                    case this.SHAPES.ROUND:
                        return this.ROUNDED;
                    case this.SHAPES.SQUARE:
                        return this.SQUARED
                    }
                if (b && -1 !== b.indexOf("Boolean"))
                    return this.HEXAGONAL;
                if (b && -1 !== b.indexOf("Number"))
                    return this.ROUNDED;
                b && b.indexOf("String");
                return this.ROUNDED;
            case e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT:
            case e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT:
                return this.NOTCH;
            default:
                throw Error("Unknown type");
            }
        }
        ;
        Ja.ConstantProvider.prototype.makeNotch = function() {
            function a(G) {
                return (0,
                t.curve)("c", [(0,
                t.point)(G * f / 2, 0), (0,
                t.point)(G * f * 3 / 4, m / 2), (0,
                t.point)(G * f, m)]) + (0,
                t.line)([(0,
                t.point)(G * f, g)]) + (0,
                t.curve)("c", [(0,
                t.point)(G * f / 4, m / 2), (0,
                t.point)(G * f / 2, m), (0,
                t.point)(G * f, m)]) + (0,
                t.lineOnAxis)("h", G * d) + (0,
                t.curve)("c", [(0,
                t.point)(G * f / 2, 0), (0,
                t.point)(G * f * 3 / 4, -(m / 2)), (0,
                t.point)(G * f, -m)]) + (0,
                t.line)([(0,
                t.point)(G * f, -g)]) + (0,
                t.curve)("c", [(0,
                t.point)(G * f / 4, -(m / 2)), (0,
                t.point)(G * f / 2, -m), (0,
                t.point)(G * f, -m)])
            }
            var b = this.NOTCH_WIDTH
              , c = this.NOTCH_HEIGHT
              , d = b / 3
              , f = d / 3
              , g = c / 2
              , m = g / 2
              , r = a(1)
              , B = a(-1);
            return {
                type: this.SHAPES.NOTCH,
                width: b,
                height: c,
                pathLeft: r,
                pathRight: B
            }
        }
        ;
        Ja.ConstantProvider.prototype.makeInsideCorners = function() {
            var a = this.CORNER_RADIUS
              , b = (0,
            t.arc)("a", "0 0,0", a, (0,
            t.point)(-a, a))
              , c = (0,
            t.arc)("a", "0 0,1", a, (0,
            t.point)(-a, a))
              , d = (0,
            t.arc)("a", "0 0,0", a, (0,
            t.point)(a, a))
              , f = (0,
            t.arc)("a", "0 0,1", a, (0,
            t.point)(a, a));
            return {
                width: a,
                height: a,
                pathTop: b,
                pathBottom: d,
                rightWidth: a,
                rightHeight: a,
                pathTopRight: c,
                pathBottomRight: f
            }
        }
        ;
        Ja.ConstantProvider.prototype.generateSecondaryColour_ = function(a) {
            return (0,
            na.blend)("#000", a, .15) || a
        }
        ;
        Ja.ConstantProvider.prototype.generateTertiaryColour_ = function(a) {
            return (0,
            na.blend)("#000", a, .25) || a
        }
        ;
        Ja.ConstantProvider.prototype.createDom = function(a, b, c) {
            Ja.ConstantProvider.superClass_.createDom.call(this, a, b, c);
            a = (0,
            n.createSvgElement)(u.DEFS, {}, a);
            b = (0,
            n.createSvgElement)(u.FILTER, {
                id: "blocklySelectedGlowFilter" + this.randomIdentifier,
                height: "160%",
                width: "180%",
                y: "-30%",
                x: "-40%"
            }, a);
            (0,
            n.createSvgElement)(u.FEGAUSSIANBLUR, {
                "in": "SourceGraphic",
                stdDeviation: this.SELECTED_GLOW_SIZE
            }, b);
            c = (0,
            n.createSvgElement)(u.FECOMPONENTTRANSFER, {
                result: "outBlur"
            }, b);
            (0,
            n.createSvgElement)(u.FEFUNCA, {
                type: "table",
                tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
            }, c);
            (0,
            n.createSvgElement)(u.FEFLOOD, {
                "flood-color": this.SELECTED_GLOW_COLOUR,
                "flood-opacity": 1,
                result: "outColor"
            }, b);
            (0,
            n.createSvgElement)(u.FECOMPOSITE, {
                "in": "outColor",
                in2: "outBlur",
                operator: "in",
                result: "outGlow"
            }, b);
            this.selectedGlowFilterId = b.id;
            this.selectedGlowFilter_ = b;
            a = (0,
            n.createSvgElement)(u.FILTER, {
                id: "blocklyReplacementGlowFilter" + this.randomIdentifier,
                height: "160%",
                width: "180%",
                y: "-30%",
                x: "-40%"
            }, a);
            (0,
            n.createSvgElement)(u.FEGAUSSIANBLUR, {
                "in": "SourceGraphic",
                stdDeviation: this.REPLACEMENT_GLOW_SIZE
            }, a);
            b = (0,
            n.createSvgElement)(u.FECOMPONENTTRANSFER, {
                result: "outBlur"
            }, a);
            (0,
            n.createSvgElement)(u.FEFUNCA, {
                type: "table",
                tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
            }, b);
            (0,
            n.createSvgElement)(u.FEFLOOD, {
                "flood-color": this.REPLACEMENT_GLOW_COLOUR,
                "flood-opacity": 1,
                result: "outColor"
            }, a);
            (0,
            n.createSvgElement)(u.FECOMPOSITE, {
                "in": "outColor",
                in2: "outBlur",
                operator: "in",
                result: "outGlow"
            }, a);
            (0,
            n.createSvgElement)(u.FECOMPOSITE, {
                "in": "SourceGraphic",
                in2: "outGlow",
                operator: "over"
            }, a);
            this.replacementGlowFilterId = a.id;
            this.replacementGlowFilter_ = a
        }
        ;
        Ja.ConstantProvider.prototype.getCSS_ = function(a) {
            return [a + " .blocklyText,", a + " .blocklyFlyoutLabelText {", "font: " + this.FIELD_TEXT_FONTWEIGHT + " " + this.FIELD_TEXT_FONTSIZE + "pt " + this.FIELD_TEXT_FONTFAMILY + ";", "}", a + " .blocklyText {", "fill: #fff;", "}", a + " .blocklyNonEditableText>rect:not(.blocklyDropdownRect),", a + " .blocklyEditableText>rect:not(.blocklyDropdownRect) {", "fill: " + this.FIELD_BORDER_RECT_COLOUR + ";", "}", a + " .blocklyNonEditableText>text,", a + " .blocklyEditableText>text,", a + " .blocklyNonEditableText>g>text,", a + " .blocklyEditableText>g>text {", "fill: #575E75;", "}", a + " .blocklyFlyoutLabelText {", "fill: #575E75;", "}", a + " .blocklyText.blocklyBubbleText {", "fill: #575E75;", "}", a + " .blocklyDraggable:not(.blocklyDisabled)", " .blocklyEditableText:not(.editing):hover>rect,", a + " .blocklyDraggable:not(.blocklyDisabled)", " .blocklyEditableText:not(.editing):hover>.blocklyPath {", "stroke: #fff;", "stroke-width: 2;", "}", a + " .blocklyHtmlInput {", "font-family: " + this.FIELD_TEXT_FONTFAMILY + ";", "font-weight: " + this.FIELD_TEXT_FONTWEIGHT + ";", "color: #575E75;", "}", a + " .blocklyDropdownText {", "fill: #fff !important;", "}", a + ".blocklyWidgetDiv .goog-menuitem,", a + ".blocklyDropDownDiv .goog-menuitem {", "font-family: " + this.FIELD_TEXT_FONTFAMILY + ";", "}", a + ".blocklyDropDownDiv .goog-menuitem-content {", "color: #fff;", "}", a + " .blocklyHighlightedConnectionPath {", "stroke: " + this.SELECTED_GLOW_COLOUR + ";", "}", a + " .blocklyDisabled > .blocklyOutlinePath {", "fill: url(#blocklyDisabledPattern" + this.randomIdentifier + ")", "}", a + " .blocklyInsertionMarker>.blocklyPath {", "fill-opacity: " + this.INSERTION_MARKER_OPACITY + ";", "stroke: none;", "}"]
        }
        ;
        var kb = {
            Drawer: function(a, b) {
                kb.Drawer.superClass_.constructor.call(this, a, b)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(kb.Drawer, Ca);
        kb.Drawer.prototype.draw = function() {
            var a = this.block_.pathObject;
            a.beginDrawing();
            this.hideHiddenIcons_();
            this.drawOutline_();
            this.drawInternals_();
            a.setPath(this.outlinePath_ + "\n" + this.inlinePath_);
            this.info_.RTL && a.flipRTL();
            (0,
            Nb.isDebuggerEnabled)() && this.block_.renderingDebugger.drawDebug(this.block_, this.info_);
            this.recordSizeOnBlock_();
            this.info_.outputConnection && (a.outputShapeType = this.info_.outputConnection.shape.type);
            a.endDrawing()
        }
        ;
        kb.Drawer.prototype.drawOutline_ = function() {
            this.info_.outputConnection && this.info_.outputConnection.isDynamicShape && !this.info_.hasStatementInput && !this.info_.bottomRow.hasNextConnection ? (this.drawFlatTop_(),
            this.drawRightDynamicConnection_(),
            this.drawFlatBottom_(),
            this.drawLeftDynamicConnection_()) : kb.Drawer.superClass_.drawOutline_.call(this)
        }
        ;
        kb.Drawer.prototype.drawLeft_ = function() {
            this.info_.outputConnection && this.info_.outputConnection.isDynamicShape ? this.drawLeftDynamicConnection_() : kb.Drawer.superClass_.drawLeft_.call(this)
        }
        ;
        kb.Drawer.prototype.drawRightSideRow_ = function(a) {
            if (!(0 >= a.height))
                if (a.precedesStatement || a.followsStatement) {
                    var b = this.constants_.INSIDE_CORNERS.rightHeight;
                    b = a.height - (a.precedesStatement ? b : 0);
                    this.outlinePath_ += (a.followsStatement ? this.constants_.INSIDE_CORNERS.pathBottomRight : "") + (0 < b ? (0,
                    t.lineOnAxis)("V", a.yPos + b) : "") + (a.precedesStatement ? this.constants_.INSIDE_CORNERS.pathTopRight : "")
                } else
                    this.outlinePath_ += (0,
                    t.lineOnAxis)("V", a.yPos + a.height)
        }
        ;
        kb.Drawer.prototype.drawRightDynamicConnection_ = function() {
            this.outlinePath_ += this.info_.outputConnection.shape.pathRightDown(this.info_.outputConnection.height)
        }
        ;
        kb.Drawer.prototype.drawLeftDynamicConnection_ = function() {
            this.positionOutputConnection_();
            this.outlinePath_ += this.info_.outputConnection.shape.pathUp(this.info_.outputConnection.height);
            this.outlinePath_ += "z"
        }
        ;
        kb.Drawer.prototype.drawFlatTop_ = function() {
            var a = this.info_.topRow;
            this.positionPreviousConnection_();
            this.outlinePath_ += (0,
            t.moveBy)(a.xPos, this.info_.startY);
            this.outlinePath_ += (0,
            t.lineOnAxis)("h", a.width)
        }
        ;
        kb.Drawer.prototype.drawFlatBottom_ = function() {
            var a = this.info_.bottomRow;
            this.positionNextConnection_();
            this.outlinePath_ += (0,
            t.lineOnAxis)("V", a.baseline);
            this.outlinePath_ += (0,
            t.lineOnAxis)("h", -a.width)
        }
        ;
        kb.Drawer.prototype.drawInlineInput_ = function(a) {
            this.positionInlineInputConnection_(a);
            var b = a.input.name;
            if (!a.connectedBlock && !this.info_.isInsertionMarker) {
                var c = a.width - 2 * a.connectionWidth;
                a = (0,
                t.moveTo)(a.xPos + a.connectionWidth, a.centerline - a.height / 2) + (0,
                t.lineOnAxis)("h", c) + a.shape.pathRightDown(a.height) + (0,
                t.lineOnAxis)("h", -c) + a.shape.pathUp(a.height) + "z";
                this.block_.pathObject.setOutlinePath(b, a)
            }
        }
        ;
        kb.Drawer.prototype.drawStatementInput_ = function(a) {
            var b = a.getLastInput()
              , c = b.xPos + b.notchOffset + b.shape.width
              , d = b.shape.pathRight + (0,
            t.lineOnAxis)("h", -(b.notchOffset - this.constants_.INSIDE_CORNERS.width)) + this.constants_.INSIDE_CORNERS.pathTop
              , f = a.height - 2 * this.constants_.INSIDE_CORNERS.height;
            b = this.constants_.INSIDE_CORNERS.pathBottom + (0,
            t.lineOnAxis)("h", b.notchOffset - this.constants_.INSIDE_CORNERS.width) + (b.connectedBottomNextConnection ? "" : b.shape.pathLeft);
            this.outlinePath_ += (0,
            t.lineOnAxis)("H", c) + d + (0,
            t.lineOnAxis)("v", f) + b + (0,
            t.lineOnAxis)("H", a.xPos + a.width);
            this.positionStatementInputConnection_(a)
        }
        ;
        var db = {
            PathObject: function(a, b, c) {
                db.PathObject.superClass_.constructor.call(this, a, b, c);
                this.constants = c;
                this.svgPathSelected_ = null;
                this.outlines_ = Object.create(null);
                this.outputShapeType = this.remainingOutlines_ = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(db.PathObject, Va);
        db.PathObject.prototype.setPath = function(a) {
            db.PathObject.superClass_.setPath.call(this, a);
            this.svgPathSelected_ && this.svgPathSelected_.setAttribute("d", a)
        }
        ;
        db.PathObject.prototype.applyColour = function(a) {
            db.PathObject.superClass_.applyColour.call(this, a);
            a.isShadow() && a.getParent() && this.svgPath.setAttribute("stroke", a.getParent().style.colourTertiary);
            for (var b in this.outlines_)
                this.outlines_[b].setAttribute("fill", this.style.colourTertiary)
        }
        ;
        db.PathObject.prototype.flipRTL = function() {
            db.PathObject.superClass_.flipRTL.call(this);
            for (var a in this.outlines_)
                this.outlines_[a].setAttribute("transform", "scale(-1 1)")
        }
        ;
        db.PathObject.prototype.updateSelected = function(a) {
            this.setClass_("blocklySelected", a);
            a ? this.svgPathSelected_ || (this.svgPathSelected_ = this.svgPath.cloneNode(!0),
            this.svgPathSelected_.setAttribute("fill", "none"),
            this.svgPathSelected_.setAttribute("filter", "url(#" + this.constants.selectedGlowFilterId + ")"),
            this.svgRoot.appendChild(this.svgPathSelected_)) : this.svgPathSelected_ && (this.svgRoot.removeChild(this.svgPathSelected_),
            this.svgPathSelected_ = null)
        }
        ;
        db.PathObject.prototype.updateReplacementFade = function(a) {
            this.setClass_("blocklyReplaceable", a);
            a ? this.svgPath.setAttribute("filter", "url(#" + this.constants.replacementGlowFilterId + ")") : this.svgPath.removeAttribute("filter")
        }
        ;
        db.PathObject.prototype.updateShapeForInputHighlight = function(a, b) {
            a = a.getParentInput().name;
            (a = this.getOutlinePath_(a)) && (b ? a.setAttribute("filter", "url(#" + this.constants.replacementGlowFilterId + ")") : a.removeAttribute("filter"))
        }
        ;
        db.PathObject.prototype.beginDrawing = function() {
            this.remainingOutlines_ = Object.create(null);
            for (var a in this.outlines_)
                this.remainingOutlines_[a] = 1
        }
        ;
        db.PathObject.prototype.endDrawing = function() {
            if (this.remainingOutlines_)
                for (var a in this.remainingOutlines_)
                    this.removeOutlinePath_(a);
            this.remainingOutlines_ = null
        }
        ;
        db.PathObject.prototype.setOutlinePath = function(a, b) {
            a = this.getOutlinePath_(a);
            a.setAttribute("d", b);
            a.setAttribute("fill", this.style.colourTertiary)
        }
        ;
        db.PathObject.prototype.getOutlinePath_ = function(a) {
            this.outlines_[a] || (this.outlines_[a] = (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyOutlinePath",
                d: ""
            }, this.svgRoot));
            this.remainingOutlines_ && delete this.remainingOutlines_[a];
            return this.outlines_[a]
        }
        ;
        db.PathObject.prototype.removeOutlinePath_ = function(a) {
            this.outlines_[a].parentNode.removeChild(this.outlines_[a]);
            delete this.outlines_[a]
        }
        ;
        var Rc = {
            BottomRow: function(a) {
                Rc.BottomRow.superClass_.constructor.call(this, a)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Rc.BottomRow, Yb.BottomRow);
        Rc.BottomRow.prototype.endsWithElemSpacer = function() {
            return !1
        }
        ;
        Rc.BottomRow.prototype.hasLeftSquareCorner = function(a) {
            return !!a.outputConnection
        }
        ;
        Rc.BottomRow.prototype.hasRightSquareCorner = function(a) {
            return !!a.outputConnection && !a.statementInputCount && !a.nextConnection
        }
        ;
        e.module$exports$Blockly$FieldImage = {
            FieldImage: function(a, b, c, d, f, g, m) {
                if (!a)
                    throw Error("Src value of an image field is required");
                a = (0,
                ka.replaceMessageReferences)(a);
                c = Number((0,
                ka.replaceMessageReferences)(c));
                b = Number((0,
                ka.replaceMessageReferences)(b));
                if (isNaN(c) || isNaN(b))
                    throw Error("Height and width values of an image field must cast to numbers.");
                if (0 >= c || 0 >= b)
                    throw Error("Height and width values of an image field must be greater than 0.");
                this.flipRtl_ = !1;
                this.altText_ = "";
                e.module$exports$Blockly$FieldImage.FieldImage.superClass_.constructor.call(this, a, null, m);
                m || (this.flipRtl_ = !!g,
                this.altText_ = (0,
                ka.replaceMessageReferences)(d) || "");
                this.size_ = new Pa(b,c + e.module$exports$Blockly$FieldImage.FieldImage.Y_PADDING);
                this.imageHeight_ = c;
                this.clickHandler_ = null;
                "function" === typeof f && (this.clickHandler_ = f);
                this.imageElement_ = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(e.module$exports$Blockly$FieldImage.FieldImage, I);
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.DEFAULT_VALUE = "";
        e.module$exports$Blockly$FieldImage.FieldImage.fromJson = function(a) {
            return new this(a.src,a.width,a.height,void 0,void 0,void 0,a)
        }
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.Y_PADDING = 1;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.EDITABLE = !1;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.isDirty_ = !1;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.configure_ = function(a) {
            e.module$exports$Blockly$FieldImage.FieldImage.superClass_.configure_.call(this, a);
            this.flipRtl_ = !!a.flipRtl;
            this.altText_ = (0,
            ka.replaceMessageReferences)(a.alt) || ""
        }
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.initView = function() {
            this.imageElement_ = (0,
            n.createSvgElement)(u.IMAGE, {
                height: this.imageHeight_ + "px",
                width: this.size_.width + "px",
                alt: this.altText_
            }, this.fieldGroup_);
            this.imageElement_.setAttributeNS(n.XLINK_NS, "xlink:href", this.value_);
            this.clickHandler_ && (this.imageElement_.style.cursor = "pointer")
        }
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.updateSize_ = function() {}
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.doClassValidation_ = function(a) {
            return "string" !== typeof a ? null : a
        }
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.doValueUpdate_ = function(a) {
            this.value_ = a;
            this.imageElement_ && this.imageElement_.setAttributeNS(n.XLINK_NS, "xlink:href", String(this.value_))
        }
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.getFlipRtl = function() {
            return this.flipRtl_
        }
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.setAlt = function(a) {
            a !== this.altText_ && (this.altText_ = a || "",
            this.imageElement_ && this.imageElement_.setAttribute("alt", this.altText_))
        }
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.showEditor_ = function() {
            this.clickHandler_ && this.clickHandler_(this)
        }
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.setOnClickHandler = function(a) {
            this.clickHandler_ = a
        }
        ;
        e.module$exports$Blockly$FieldImage.FieldImage.prototype.getText_ = function() {
            return this.altText_
        }
        ;
        (0,
        tb.register)("field_image", e.module$exports$Blockly$FieldImage.FieldImage);
        var Ea = {
            RenderInfo: function(a, b) {
                Ea.RenderInfo.superClass_.constructor.call(this, a, b);
                this.topRow = new Qc.TopRow(this.constants_);
                this.bottomRow = new Rc.BottomRow(this.constants_);
                this.isInline = !0;
                this.isMultiRow = !b.getInputsInline() || b.isCollapsed();
                this.hasStatementInput = 0 < b.statementInputCount;
                this.rightSide = this.outputConnection ? new Kd.RightConnectionShape(this.constants_) : null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Ea.RenderInfo, wa);
        Ea.RenderInfo.prototype.getRenderer = function() {
            return this.renderer_
        }
        ;
        Ea.RenderInfo.prototype.measure = function() {
            this.createRows_();
            this.addElemSpacing_();
            this.addRowSpacing_();
            this.adjustXPosition_();
            this.computeBounds_();
            this.alignRowElements_();
            this.finalize_()
        }
        ;
        Ea.RenderInfo.prototype.shouldStartNewRow_ = function(a, b) {
            return b ? a.type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT || b.type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT ? !0 : a.type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE || a.type === e.module$exports$Blockly$inputTypes.inputTypes.DUMMY ? !this.isInline || this.isMultiRow : !1 : !1
        }
        ;
        Ea.RenderInfo.prototype.getDesiredRowWidth_ = function(a) {
            return a.hasStatement ? this.width - this.startX - (this.constants_.INSIDE_CORNERS.rightWidth || 0) : Ea.RenderInfo.superClass_.getDesiredRowWidth_.call(this, a)
        }
        ;
        Ea.RenderInfo.prototype.getInRowSpacing_ = function(a, b) {
            return a && b || !this.outputConnection || !this.outputConnection.isDynamicShape || this.hasStatementInput || this.bottomRow.hasNextConnection ? !a && b && p.isStatementInput(b) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : a && p.isLeftRoundedCorner(a) && b && (p.isPreviousConnection(b) || p.isNextConnection(b)) ? b.notchOffset - this.constants_.CORNER_RADIUS : a && p.isLeftSquareCorner(a) && b && p.isHat(b) ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING : this.constants_.NO_PADDING
        }
        ;
        Ea.RenderInfo.prototype.getSpacerRowHeight_ = function(a, b) {
            if (p.isTopRow(a) && p.isBottomRow(b))
                return this.constants_.EMPTY_BLOCK_SPACER_HEIGHT;
            var c = p.isInputRow(a) && a.hasStatement
              , d = p.isInputRow(b) && b.hasStatement;
            return d || c ? (a = Math.max(this.constants_.NOTCH_HEIGHT, this.constants_.INSIDE_CORNERS.rightHeight || 0),
            d && c ? Math.max(a, this.constants_.DUMMY_INPUT_MIN_HEIGHT) : a) : p.isTopRow(a) ? a.hasPreviousConnection || this.outputConnection && !this.hasStatementInput ? this.constants_.NO_PADDING : Math.abs(this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS) : p.isBottomRow(b) ? this.outputConnection ? !b.hasNextConnection && this.hasStatementInput ? Math.abs(this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS) : this.constants_.NO_PADDING : Math.max(this.topRow.minHeight, Math.max(this.constants_.NOTCH_HEIGHT, this.constants_.CORNER_RADIUS)) - this.constants_.CORNER_RADIUS : this.constants_.MEDIUM_PADDING
        }
        ;
        Ea.RenderInfo.prototype.getSpacerRowWidth_ = function(a, b) {
            var c = this.width - this.startX;
            return p.isInputRow(a) && a.hasStatement || p.isInputRow(b) && b.hasStatement ? Math.max(c, this.constants_.STATEMENT_INPUT_SPACER_MIN_WIDTH) : c
        }
        ;
        Ea.RenderInfo.prototype.getElemCenterline_ = function(a, b) {
            if (a.hasStatement && !p.isSpacer(b) && !p.isStatementInput(b))
                return a.yPos + this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT / 2;
            if (p.isInlineInput(b)) {
                var c = b.connectedBlock;
                if (c && c.outputConnection && c.nextConnection)
                    return a.yPos + c.height / 2
            }
            return Ea.RenderInfo.superClass_.getElemCenterline_.call(this, a, b)
        }
        ;
        Ea.RenderInfo.prototype.addInput_ = function(a, b) {
            if (a.type === e.module$exports$Blockly$inputTypes.inputTypes.DUMMY && b.hasDummyInput && b.align === e.module$exports$Blockly$Input.Align.LEFT && a.align === e.module$exports$Blockly$Input.Align.RIGHT)
                b.rightAlignedDummyInput = a;
            else if (a.type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT) {
                b.elements.push(new Jd.StatementInput(this.constants_,a));
                b.hasStatement = !0;
                null === b.align && (b.align = a.align);
                return
            }
            Ea.RenderInfo.superClass_.addInput_.call(this, a, b)
        }
        ;
        Ea.RenderInfo.prototype.addAlignmentPadding_ = function(a, b) {
            if (a.rightAlignedDummyInput) {
                for (var c, d = 0; d < a.elements.length; d++) {
                    var f = a.elements[d];
                    p.isSpacer(f) && (c = f);
                    if (p.isField(f) && f.parentInput === a.rightAlignedDummyInput)
                        break
                }
                if (c) {
                    c.width += b;
                    a.width += b;
                    return
                }
            }
            Ea.RenderInfo.superClass_.addAlignmentPadding_.call(this, a, b)
        }
        ;
        Ea.RenderInfo.prototype.adjustXPosition_ = function() {
            for (var a = this.constants_.NOTCH_OFFSET_LEFT + this.constants_.NOTCH_WIDTH, b = a, c = 2; c < this.rows.length - 1; c += 2) {
                var d = this.rows[c - 1]
                  , f = this.rows[c]
                  , g = this.rows[c + 1];
                d = 2 === c ? !!this.topRow.hasPreviousConnection : !!d.followsStatement;
                g = c + 2 >= this.rows.length - 1 ? !!this.bottomRow.hasNextConnection : !!g.precedesStatement;
                if (p.isInputRow(f) && f.hasStatement)
                    f.measure(),
                    b = f.width - f.getLastInput().width + a;
                else if (d && (2 === c || g) && p.isInputRow(f) && !f.hasStatement) {
                    g = f.xPos;
                    d = null;
                    for (var m = 0; m < f.elements.length; m++) {
                        var r = f.elements[m];
                        p.isSpacer(r) && (d = r);
                        !(d && (p.isField(r) || p.isInput(r)) && g < b) || p.isField(r) && (r.field instanceof e.module$exports$Blockly$FieldLabel.FieldLabel || r.field instanceof e.module$exports$Blockly$FieldImage.FieldImage) || (d.width += b - g);
                        g += r.width
                    }
                }
            }
        }
        ;
        Ea.RenderInfo.prototype.finalizeOutputConnection_ = function() {
            if (this.outputConnection && this.outputConnection.isDynamicShape) {
                for (var a = 0, b = 0; b < this.rows.length; b++) {
                    var c = this.rows[b];
                    c.yPos = a;
                    a += c.height
                }
                this.height = a;
                b = this.bottomRow.hasNextConnection ? this.height - this.bottomRow.descenderHeight : this.height;
                a = this.outputConnection.shape.height(b);
                b = this.outputConnection.shape.width(b);
                this.outputConnection.height = a;
                this.outputConnection.width = b;
                this.outputConnection.startX = b;
                this.outputConnection.connectionOffsetY = this.outputConnection.shape.connectionOffsetY(a);
                this.outputConnection.connectionOffsetX = this.outputConnection.shape.connectionOffsetX(b);
                c = 0;
                this.hasStatementInput || this.bottomRow.hasNextConnection || (c = b,
                this.rightSide.height = a,
                this.rightSide.width = c,
                this.rightSide.centerline = a / 2,
                this.rightSide.xPos = this.width + c);
                this.startX = b;
                this.width += b + c;
                this.widthWithChildren += b + c
            }
        }
        ;
        Ea.RenderInfo.prototype.finalizeHorizontalAlignment_ = function() {
            if (this.outputConnection && !this.hasStatementInput && !this.bottomRow.hasNextConnection) {
                for (var a = 0, b = 0; b < this.rows.length; b++) {
                    var c = this.rows[b];
                    if (p.isInputRow(c)) {
                        a = c.elements[c.elements.length - 2];
                        var d = this.getNegativeSpacing_(c.elements[1])
                          , f = this.getNegativeSpacing_(a);
                        a = d + f;
                        var g = this.constants_.MIN_BLOCK_WIDTH + 2 * this.outputConnection.width;
                        this.width - a < g && (a = this.width - g,
                        d = a / 2,
                        f = a / 2);
                        c.elements.unshift(new pb.InRowSpacer(this.constants_,-d));
                        c.elements.push(new pb.InRowSpacer(this.constants_,-f))
                    }
                }
                if (a)
                    for (this.width -= a,
                    this.widthWithChildren -= a,
                    this.rightSide.xPos -= a,
                    b = 0; b < this.rows.length; b++)
                        c = this.rows[b],
                        p.isTopOrBottomRow(c) && (c.elements[1].width -= a,
                        c.elements[1].widthWithConnectedBlocks -= a),
                        c.width -= a,
                        c.widthWithConnectedBlocks -= a
            }
        }
        ;
        Ea.RenderInfo.prototype.getNegativeSpacing_ = function(a) {
            if (!a)
                return 0;
            var b = this.outputConnection.width
              , c = this.outputConnection.shape.type
              , d = this.constants_;
            if (this.isMultiRow && 1 < this.inputRows.length)
                switch (c) {
                case d.SHAPES.ROUND:
                    return c = this.constants_.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH,
                    c = this.height / 2 > c ? c : this.height / 2,
                    b - c * (1 - Math.sin(Math.acos((c - this.constants_.SMALL_PADDING) / c)));
                default:
                    return 0
                }
            if (p.isInlineInput(a)) {
                var f = a.connectedBlock;
                a = f ? f.pathObject.outputShapeType : a.shape.type;
                return f && f.outputConnection && (f.statementInputCount || f.nextConnection) || c === d.SHAPES.HEXAGONAL && c !== a ? 0 : b - this.constants_.SHAPE_IN_SHAPE_PADDING[c][a]
            }
            return p.isField(a) ? c === d.SHAPES.ROUND && a.field instanceof e.module$exports$Blockly$FieldTextInput.FieldTextInput ? b - 2.75 * d.GRID_UNIT : b - this.constants_.SHAPE_IN_SHAPE_PADDING[c][0] : p.isIcon(a) ? this.constants_.SMALL_PADDING : 0
        }
        ;
        Ea.RenderInfo.prototype.finalizeVerticalAlignment_ = function() {
            if (!this.outputConnection)
                for (var a = 2; a < this.rows.length - 1; a += 2) {
                    var b = this.rows[a - 1]
                      , c = this.rows[a]
                      , d = this.rows[a + 1]
                      , f = 2 === a
                      , g = a + 2 >= this.rows.length - 1 ? !!this.bottomRow.hasNextConnection : !!d.precedesStatement;
                    if (f ? this.topRow.hasPreviousConnection : b.followsStatement) {
                        var m = 3 === c.elements.length && (c.elements[1].field instanceof e.module$exports$Blockly$FieldLabel.FieldLabel || c.elements[1].field instanceof e.module$exports$Blockly$FieldImage.FieldImage);
                        if (!f && m)
                            b.height -= this.constants_.SMALL_PADDING,
                            d.height -= this.constants_.SMALL_PADDING,
                            c.height -= this.constants_.MEDIUM_PADDING;
                        else if (!f && !g)
                            b.height += this.constants_.SMALL_PADDING;
                        else if (g) {
                            f = !1;
                            for (g = 0; g < c.elements.length; g++)
                                if (m = c.elements[g],
                                p.isInlineInput(m) && m.connectedBlock && !m.connectedBlock.isShadow() && 40 <= m.connectedBlock.getHeightWidth().height) {
                                    f = !0;
                                    break
                                }
                            f && (b.height -= this.constants_.SMALL_PADDING,
                            d.height -= this.constants_.SMALL_PADDING)
                        }
                    }
                }
        }
        ;
        Ea.RenderInfo.prototype.finalize_ = function() {
            this.finalizeOutputConnection_();
            this.finalizeHorizontalAlignment_();
            this.finalizeVerticalAlignment_();
            Ea.RenderInfo.superClass_.finalize_.call(this);
            this.rightSide && (this.widthWithChildren += this.rightSide.width)
        }
        ;
        var Ib = {
            Renderer: function(a) {
                Ib.Renderer.superClass_.constructor.call(this, a)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Ib.Renderer, Ra);
        Ib.Renderer.prototype.makeConstants_ = function() {
            return new Ja.ConstantProvider
        }
        ;
        Ib.Renderer.prototype.makeRenderInfo_ = function(a) {
            return new Ea.RenderInfo(this,a)
        }
        ;
        Ib.Renderer.prototype.makeDrawer_ = function(a, b) {
            return new kb.Drawer(a,b)
        }
        ;
        Ib.Renderer.prototype.makeMarkerDrawer = function(a, b) {
            return new rb.MarkerSvg(a,this.getConstants(),b)
        }
        ;
        Ib.Renderer.prototype.makePathObject = function(a, b) {
            return new db.PathObject(a,b,this.getConstants())
        }
        ;
        Ib.Renderer.prototype.shouldHighlightConnection = function(a) {
            return a.type !== e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE && a.type !== e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE
        }
        ;
        Ib.Renderer.prototype.getConnectionPreviewMethod = function(a, b, c) {
            return b.type === e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE ? a.isConnected() ? la.PREVIEW_TYPE.REPLACEMENT_FADE : la.PREVIEW_TYPE.INPUT_OUTLINE : Ib.Renderer.superClass_.getConnectionPreviewMethod(a, b, c)
        }
        ;
        (0,
        ma.register)("zelos", Ib.Renderer);
        var Tb = {};
        Tb.BottomRow = Rc.BottomRow;
        Tb.ConstantProvider = Ja.ConstantProvider;
        Tb.Drawer = kb.Drawer;
        Tb.MarkerSvg = rb.MarkerSvg;
        Tb.PathObject = db.PathObject;
        Tb.RenderInfo = Ea.RenderInfo;
        Tb.Renderer = Ib.Renderer;
        Tb.RightConnectionShape = Kd.RightConnectionShape;
        Tb.StatementInput = Jd.StatementInput;
        Tb.TopRow = Qc.TopRow;
        var fc = {
            RenderInfo: function(a, b) {
                fc.RenderInfo.superClass_.constructor.call(this, a, b)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(fc.RenderInfo, wa);
        fc.RenderInfo.prototype.getRenderer = function() {
            return this.renderer_
        }
        ;
        fc.RenderInfo.prototype.addElemSpacing_ = function() {
            for (var a = !1, b = 0; b < this.rows.length; b++)
                if (this.rows[b].hasExternalInput) {
                    a = !0;
                    break
                }
            for (b = 0; b < this.rows.length; b++) {
                var c = this.rows[b]
                  , d = c.elements;
                c.elements = [];
                c.startsWithElemSpacer() && c.elements.push(new pb.InRowSpacer(this.constants_,this.getInRowSpacing_(null, d[0])));
                for (var f = 0; f < d.length - 1; f++) {
                    c.elements.push(d[f]);
                    var g = this.getInRowSpacing_(d[f], d[f + 1]);
                    c.elements.push(new pb.InRowSpacer(this.constants_,g))
                }
                c.elements.push(d[d.length - 1]);
                c.endsWithElemSpacer() && (d = this.getInRowSpacing_(d[d.length - 1], null),
                a && c.hasDummyInput && (d += this.constants_.TAB_WIDTH),
                c.elements.push(new pb.InRowSpacer(this.constants_,d)))
            }
        }
        ;
        fc.RenderInfo.prototype.getInRowSpacing_ = function(a, b) {
            if (!a)
                return b && p.isField(b) && b.isEditable ? this.constants_.MEDIUM_PADDING : b && p.isInlineInput(b) ? this.constants_.MEDIUM_LARGE_PADDING : b && p.isStatementInput(b) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.LARGE_PADDING;
            if (!p.isInput(a) && !b)
                return p.isField(a) && a.isEditable ? this.constants_.MEDIUM_PADDING : p.isIcon(a) ? 2 * this.constants_.LARGE_PADDING + 1 : p.isHat(a) ? this.constants_.NO_PADDING : p.isPreviousOrNextConnection(a) ? this.constants_.LARGE_PADDING : p.isLeftRoundedCorner(a) ? this.constants_.MIN_BLOCK_WIDTH : p.isJaggedEdge(a) ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING;
            if (p.isInput(a) && !b) {
                if (p.isExternalInput(a))
                    return this.constants_.NO_PADDING;
                if (p.isInlineInput(a))
                    return this.constants_.LARGE_PADDING;
                if (p.isStatementInput(a))
                    return this.constants_.NO_PADDING
            }
            if (!p.isInput(a) && b && p.isInput(b)) {
                if (p.isField(a) && a.isEditable) {
                    if (p.isInlineInput(b) || p.isExternalInput(b))
                        return this.constants_.SMALL_PADDING
                } else {
                    if (p.isInlineInput(b) || p.isExternalInput(b))
                        return this.constants_.MEDIUM_LARGE_PADDING;
                    if (p.isStatementInput(b))
                        return this.constants_.LARGE_PADDING
                }
                return this.constants_.LARGE_PADDING - 1
            }
            if (p.isIcon(a) && b && !p.isInput(b))
                return this.constants_.LARGE_PADDING;
            if (p.isInlineInput(a) && b && p.isField(b))
                return b.isEditable ? this.constants_.MEDIUM_PADDING : this.constants_.LARGE_PADDING;
            if (p.isLeftSquareCorner(a) && b) {
                if (p.isHat(b))
                    return this.constants_.NO_PADDING;
                if (p.isPreviousConnection(b) || p.isNextConnection(b))
                    return b.notchOffset
            }
            return p.isLeftRoundedCorner(a) && b ? b.notchOffset - this.constants_.CORNER_RADIUS : p.isField(a) && b && p.isField(b) && a.isEditable === b.isEditable || b && p.isJaggedEdge(b) ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
        }
        ;
        fc.RenderInfo.prototype.getSpacerRowHeight_ = function(a, b) {
            return p.isTopRow(a) && p.isBottomRow(b) ? this.constants_.EMPTY_BLOCK_SPACER_HEIGHT : p.isTopRow(a) || p.isBottomRow(b) ? this.constants_.NO_PADDING : a.hasExternalInput && b.hasExternalInput ? this.constants_.LARGE_PADDING : !a.hasStatement && b.hasStatement ? this.constants_.BETWEEN_STATEMENT_PADDING_Y : a.hasStatement && b.hasStatement || a.hasDummyInput || b.hasDummyInput ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
        }
        ;
        fc.RenderInfo.prototype.getElemCenterline_ = function(a, b) {
            if (p.isSpacer(b))
                return a.yPos + b.height / 2;
            if (p.isBottomRow(a))
                return a = a.yPos + a.height - a.descenderHeight,
                p.isNextConnection(b) ? a + b.height / 2 : a - b.height / 2;
            if (p.isTopRow(a))
                return p.isHat(b) ? a.capline - b.height / 2 : a.capline + b.height / 2;
            var c = a.yPos;
            return p.isField(b) && a.hasStatement ? c + (this.constants_.TALL_INPUT_FIELD_OFFSET_Y + b.height / 2) : c + a.height / 2
        }
        ;
        fc.RenderInfo.prototype.finalize_ = function() {
            for (var a = 0, b = 0, c = 0; c < this.rows.length; c++) {
                var d = this.rows[c];
                d.yPos = b;
                d.xPos = this.startX;
                b += d.height;
                a = Math.max(a, d.widthWithConnectedBlocks);
                var f = b - this.topRow.ascenderHeight;
                d === this.bottomRow && f < this.constants_.MIN_BLOCK_HEIGHT && (f = this.constants_.MIN_BLOCK_HEIGHT - f,
                this.bottomRow.height += f,
                b += f);
                this.recordElemPositions_(d)
            }
            this.outputConnection && this.block_.nextConnection && this.block_.nextConnection.isConnected() && (a = Math.max(a, this.block_.nextConnection.targetBlock().getHeightWidth().width));
            this.bottomRow.baseline = b - this.bottomRow.descenderHeight;
            this.widthWithChildren = a + this.startX;
            this.height = b;
            this.startY = this.topRow.capline
        }
        ;
        var md = {
            Renderer: function(a) {
                md.Renderer.superClass_.constructor.call(this, a)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(md.Renderer, Ra);
        md.Renderer.prototype.makeRenderInfo_ = function(a) {
            return new fc.RenderInfo(this,a)
        }
        ;
        (0,
        ma.register)("thrasos", md.Renderer);
        var ee = {};
        ee.RenderInfo = fc.RenderInfo;
        ee.Renderer = md.Renderer;
        var Ld = function() {
            this.priority = Xd.VARIABLES
        };
        Ld.prototype.save = function(a) {
            var b = [];
            a = z.makeIterator(a.getAllVariables());
            for (var c = a.next(); !c.done; c = a.next()) {
                c = c.value;
                var d = {
                    name: c.name,
                    id: c.getId()
                };
                c.type && (d.type = c.type);
                b.push(d)
            }
            return b.length ? b : null
        }
        ;
        Ld.prototype.load = function(a, b) {
            a = z.makeIterator(a);
            for (var c = a.next(); !c.done; c = a.next())
                c = c.value,
                b.createVariable(c.name, c.type, c.id)
        }
        ;
        Ld.prototype.clear = function(a) {
            a.getVariableMap().clear()
        }
        ;
        (0,
        Yd.register)("variables", new Ld);
        var Md = {
            ConstantProvider: function() {
                Md.ConstantProvider.superClass_.constructor.call(this)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Md.ConstantProvider, va);
        var Nd = {
            Drawer: function(a, b) {
                Nd.Drawer.superClass_.constructor.call(this, a, b)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Nd.Drawer, Ca);
        var nd = {
            RenderInfo: function(a, b) {
                nd.RenderInfo.superClass_.constructor.call(this, a, b)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(nd.RenderInfo, wa);
        nd.RenderInfo.prototype.getRenderer = function() {
            return this.renderer_
        }
        ;
        var Sc = {
            Renderer: function(a) {
                Sc.Renderer.superClass_.constructor.call(this, a)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Sc.Renderer, Ra);
        Sc.Renderer.prototype.makeConstants_ = function() {
            return new Md.ConstantProvider
        }
        ;
        Sc.Renderer.prototype.makeRenderInfo_ = function(a) {
            return new nd.RenderInfo(this,a)
        }
        ;
        Sc.Renderer.prototype.makeDrawer_ = function(a, b) {
            return new Nd.Drawer(a,b)
        }
        ;
        (0,
        ma.register)("minimalist", Sc.Renderer);
        var od = {};
        od.ConstantProvider = Md.ConstantProvider;
        od.Drawer = Nd.Drawer;
        od.RenderInfo = nd.RenderInfo;
        od.Renderer = Sc.Renderer;
        var Od = {
            StatementInput: function(a, b) {
                Od.StatementInput.superClass_.constructor.call(this, a, b);
                this.connectedBlock && (this.height += this.constants_.DARK_PATH_OFFSET)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Od.StatementInput, Xc.StatementInput);
        var Db = function(a, b, c) {
            this.constants = c;
            this.svgRoot = a;
            this.svgPathDark = (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyPathDark",
                transform: "translate(1,1)"
            }, this.svgRoot);
            this.svgPath = (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyPath"
            }, this.svgRoot);
            this.svgPathLight = (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyPathLight"
            }, this.svgRoot);
            this.colourDark = "#000000";
            this.style = b
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Db, Va);
        Db.prototype.setPath = function(a) {
            this.svgPath.setAttribute("d", a);
            this.svgPathDark.setAttribute("d", a)
        }
        ;
        Db.prototype.setHighlightPath = function(a) {
            this.svgPathLight.setAttribute("d", a)
        }
        ;
        Db.prototype.flipRTL = function() {
            this.svgPath.setAttribute("transform", "scale(-1 1)");
            this.svgPathLight.setAttribute("transform", "scale(-1 1)");
            this.svgPathDark.setAttribute("transform", "translate(1,1) scale(-1 1)")
        }
        ;
        Db.prototype.applyColour = function(a) {
            this.svgPathLight.style.display = "";
            this.svgPathDark.style.display = "";
            this.svgPathLight.setAttribute("stroke", this.style.colourTertiary);
            this.svgPathDark.setAttribute("fill", this.colourDark);
            Db.superClass_.applyColour.call(this, a);
            this.svgPath.setAttribute("stroke", "none")
        }
        ;
        Db.prototype.setStyle = function(a) {
            this.style = a;
            this.colourDark = (0,
            na.blend)("#000", this.style.colourPrimary, .2) || this.colourDark
        }
        ;
        Db.prototype.updateHighlighted = function(a) {
            a ? (this.svgPath.setAttribute("filter", "url(#" + this.constants.embossFilterId + ")"),
            this.svgPathLight.style.display = "none") : (this.svgPath.setAttribute("filter", "none"),
            this.svgPathLight.style.display = "inline")
        }
        ;
        Db.prototype.updateShadow_ = function(a) {
            a && (this.svgPathLight.style.display = "none",
            this.svgPathDark.setAttribute("fill", this.style.colourSecondary),
            this.svgPath.setAttribute("stroke", "none"),
            this.svgPath.setAttribute("fill", this.style.colourSecondary))
        }
        ;
        Db.prototype.updateDisabled_ = function(a) {
            Db.superClass_.updateDisabled_.call(this, a);
            a && this.svgPath.setAttribute("stroke", "none")
        }
        ;
        var Zc = {
            ConstantProvider: function() {
                Zc.ConstantProvider.superClass_.constructor.call(this);
                this.FIELD_TEXT_BASELINE_CENTER = !1;
                this.DARK_PATH_OFFSET = 1;
                this.MAX_BOTTOM_WIDTH = 30;
                this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT / 2
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Zc.ConstantProvider, va);
        Zc.ConstantProvider.prototype.getCSS_ = function(a) {
            return Zc.ConstantProvider.superClass_.getCSS_.call(this, a).concat([a + " .blocklyInsertionMarker>.blocklyPathLight,", a + " .blocklyInsertionMarker>.blocklyPathDark {", "fill-opacity: " + this.INSERTION_MARKER_OPACITY + ";", "stroke: none;", "}"])
        }
        ;
        var Ub = function(a) {
            this.info_ = a;
            this.inlineSteps_ = this.steps_ = "";
            this.RTL_ = this.info_.RTL;
            a = a.getRenderer();
            this.constants_ = a.getConstants();
            this.highlightConstants_ = a.getHighlightConstants();
            this.highlightOffset_ = this.highlightConstants_.OFFSET;
            this.outsideCornerPaths_ = this.highlightConstants_.OUTSIDE_CORNER;
            this.insideCornerPaths_ = this.highlightConstants_.INSIDE_CORNER;
            this.puzzleTabPaths_ = this.highlightConstants_.PUZZLE_TAB;
            this.notchPaths_ = this.highlightConstants_.NOTCH;
            this.startPaths_ = this.highlightConstants_.START_HAT;
            this.jaggedTeethPaths_ = this.highlightConstants_.JAGGED_TEETH
        };
        Ub.prototype.getPath = function() {
            return this.steps_ + "\n" + this.inlineSteps_
        }
        ;
        Ub.prototype.drawTopCorner = function(a) {
            this.steps_ += (0,
            t.moveBy)(a.xPos, this.info_.startY);
            for (var b = 0, c; c = a.elements[b]; b++)
                p.isLeftSquareCorner(c) ? this.steps_ += this.highlightConstants_.START_POINT : p.isLeftRoundedCorner(c) ? this.steps_ += this.outsideCornerPaths_.topLeft(this.RTL_) : p.isPreviousConnection(c) ? this.steps_ += this.notchPaths_.pathLeft : p.isHat(c) ? this.steps_ += this.startPaths_.path(this.RTL_) : p.isSpacer(c) && 0 !== c.width && (this.steps_ += (0,
                t.lineOnAxis)("H", c.xPos + c.width - this.highlightOffset_));
            this.steps_ += (0,
            t.lineOnAxis)("H", a.xPos + a.width - this.highlightOffset_)
        }
        ;
        Ub.prototype.drawJaggedEdge_ = function(a) {
            this.info_.RTL && (this.steps_ += this.jaggedTeethPaths_.pathLeft + (0,
            t.lineOnAxis)("v", a.height - this.jaggedTeethPaths_.height - this.highlightOffset_))
        }
        ;
        Ub.prototype.drawValueInput = function(a) {
            var b = a.getLastInput();
            if (this.RTL_) {
                var c = a.height - b.connectionHeight;
                this.steps_ += (0,
                t.moveTo)(b.xPos + b.width - this.highlightOffset_, a.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_) + (0,
                t.lineOnAxis)("v", c)
            } else
                this.steps_ += (0,
                t.moveTo)(b.xPos + b.width, a.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_)
        }
        ;
        Ub.prototype.drawStatementInput = function(a) {
            var b = a.getLastInput();
            if (this.RTL_) {
                var c = a.height - 2 * this.insideCornerPaths_.height;
                this.steps_ += (0,
                t.moveTo)(b.xPos, a.yPos) + this.insideCornerPaths_.pathTop(this.RTL_) + (0,
                t.lineOnAxis)("v", c) + this.insideCornerPaths_.pathBottom(this.RTL_) + (0,
                t.lineTo)(a.width - b.xPos - this.insideCornerPaths_.width, 0)
            } else
                this.steps_ += (0,
                t.moveTo)(b.xPos, a.yPos + a.height) + this.insideCornerPaths_.pathBottom(this.RTL_) + (0,
                t.lineTo)(a.width - b.xPos - this.insideCornerPaths_.width, 0)
        }
        ;
        Ub.prototype.drawRightSideRow = function(a) {
            var b = a.xPos + a.width - this.highlightOffset_;
            a.followsStatement && (this.steps_ += (0,
            t.lineOnAxis)("H", b));
            this.RTL_ && (this.steps_ += (0,
            t.lineOnAxis)("H", b),
            a.height > this.highlightOffset_ && (this.steps_ += (0,
            t.lineOnAxis)("V", a.yPos + a.height - this.highlightOffset_)))
        }
        ;
        Ub.prototype.drawBottomRow = function(a) {
            if (this.RTL_)
                this.steps_ += (0,
                t.lineOnAxis)("V", a.baseline - this.highlightOffset_);
            else {
                var b = this.info_.bottomRow.elements[0];
                p.isLeftSquareCorner(b) ? this.steps_ += (0,
                t.moveTo)(a.xPos + this.highlightOffset_, a.baseline - this.highlightOffset_) : p.isLeftRoundedCorner(b) && (this.steps_ += (0,
                t.moveTo)(a.xPos, a.baseline),
                this.steps_ += this.outsideCornerPaths_.bottomLeft())
            }
        }
        ;
        Ub.prototype.drawLeft = function() {
            var a = this.info_.outputConnection;
            a && (a = a.connectionOffsetY + a.height,
            this.RTL_ ? this.steps_ += (0,
            t.moveTo)(this.info_.startX, a) : (this.steps_ += (0,
            t.moveTo)(this.info_.startX + this.highlightOffset_, this.info_.bottomRow.baseline - this.highlightOffset_),
            this.steps_ += (0,
            t.lineOnAxis)("V", a)),
            this.steps_ += this.puzzleTabPaths_.pathUp(this.RTL_));
            this.RTL_ || (a = this.info_.topRow,
            p.isLeftRoundedCorner(a.elements[0]) ? this.steps_ += (0,
            t.lineOnAxis)("V", this.outsideCornerPaths_.height) : this.steps_ += (0,
            t.lineOnAxis)("V", a.capline + this.highlightOffset_))
        }
        ;
        Ub.prototype.drawInlineInput = function(a) {
            var b = this.highlightOffset_
              , c = a.xPos + a.connectionWidth
              , d = a.centerline - a.height / 2
              , f = a.width - a.connectionWidth
              , g = d + b;
            this.RTL_ ? (d = a.connectionOffsetY - b,
            a = a.height - (a.connectionOffsetY + a.connectionHeight) + b,
            this.inlineSteps_ += (0,
            t.moveTo)(c - b, g) + (0,
            t.lineOnAxis)("v", d) + this.puzzleTabPaths_.pathDown(this.RTL_) + (0,
            t.lineOnAxis)("v", a) + (0,
            t.lineOnAxis)("h", f)) : this.inlineSteps_ += (0,
            t.moveTo)(a.xPos + a.width + b, g) + (0,
            t.lineOnAxis)("v", a.height) + (0,
            t.lineOnAxis)("h", -f) + (0,
            t.moveTo)(c, d + a.connectionOffsetY) + this.puzzleTabPaths_.pathDown(this.RTL_)
        }
        ;
        var Ka = {
            Drawer: function(a, b) {
                Ka.Drawer.superClass_.constructor.call(this, a, b);
                this.highlighter_ = new Ub(b)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Ka.Drawer, Ca);
        Ka.Drawer.prototype.draw = function() {
            this.hideHiddenIcons_();
            this.drawOutline_();
            this.drawInternals_();
            var a = this.block_.pathObject;
            a.setPath(this.outlinePath_ + "\n" + this.inlinePath_);
            a.setHighlightPath(this.highlighter_.getPath());
            this.info_.RTL && a.flipRTL();
            (0,
            Nb.isDebuggerEnabled)() && this.block_.renderingDebugger.drawDebug(this.block_, this.info_);
            this.recordSizeOnBlock_()
        }
        ;
        Ka.Drawer.prototype.drawTop_ = function() {
            this.highlighter_.drawTopCorner(this.info_.topRow);
            this.highlighter_.drawRightSideRow(this.info_.topRow);
            Ka.Drawer.superClass_.drawTop_.call(this)
        }
        ;
        Ka.Drawer.prototype.drawJaggedEdge_ = function(a) {
            this.highlighter_.drawJaggedEdge_(a);
            Ka.Drawer.superClass_.drawJaggedEdge_.call(this, a)
        }
        ;
        Ka.Drawer.prototype.drawValueInput_ = function(a) {
            this.highlighter_.drawValueInput(a);
            Ka.Drawer.superClass_.drawValueInput_.call(this, a)
        }
        ;
        Ka.Drawer.prototype.drawStatementInput_ = function(a) {
            this.highlighter_.drawStatementInput(a);
            Ka.Drawer.superClass_.drawStatementInput_.call(this, a)
        }
        ;
        Ka.Drawer.prototype.drawRightSideRow_ = function(a) {
            this.highlighter_.drawRightSideRow(a);
            this.outlinePath_ += (0,
            t.lineOnAxis)("H", a.xPos + a.width) + (0,
            t.lineOnAxis)("V", a.yPos + a.height)
        }
        ;
        Ka.Drawer.prototype.drawBottom_ = function() {
            this.highlighter_.drawBottomRow(this.info_.bottomRow);
            Ka.Drawer.superClass_.drawBottom_.call(this)
        }
        ;
        Ka.Drawer.prototype.drawLeft_ = function() {
            this.highlighter_.drawLeft();
            Ka.Drawer.superClass_.drawLeft_.call(this)
        }
        ;
        Ka.Drawer.prototype.drawInlineInput_ = function(a) {
            this.highlighter_.drawInlineInput(a);
            Ka.Drawer.superClass_.drawInlineInput_.call(this, a)
        }
        ;
        Ka.Drawer.prototype.positionInlineInputConnection_ = function(a) {
            var b = a.centerline - a.height / 2;
            if (a.connectionModel) {
                var c = a.xPos + a.connectionWidth + this.constants_.DARK_PATH_OFFSET;
                this.info_.RTL && (c *= -1);
                a.connectionModel.setOffsetInBlock(c, b + a.connectionOffsetY + this.constants_.DARK_PATH_OFFSET)
            }
        }
        ;
        Ka.Drawer.prototype.positionStatementInputConnection_ = function(a) {
            var b = a.getLastInput();
            if (b.connectionModel) {
                var c = a.xPos + a.statementEdge + b.notchOffset;
                c = this.info_.RTL ? -1 * c : c + this.constants_.DARK_PATH_OFFSET;
                b.connectionModel.setOffsetInBlock(c, a.yPos + this.constants_.DARK_PATH_OFFSET)
            }
        }
        ;
        Ka.Drawer.prototype.positionExternalValueConnection_ = function(a) {
            var b = a.getLastInput();
            if (b.connectionModel) {
                var c = a.xPos + a.width + this.constants_.DARK_PATH_OFFSET;
                this.info_.RTL && (c *= -1);
                b.connectionModel.setOffsetInBlock(c, a.yPos)
            }
        }
        ;
        Ka.Drawer.prototype.positionNextConnection_ = function() {
            var a = this.info_.bottomRow;
            if (a.connection) {
                var b = a.connection
                  , c = b.xPos;
                b.connectionModel.setOffsetInBlock((this.info_.RTL ? -c : c) + this.constants_.DARK_PATH_OFFSET / 2, a.baseline + this.constants_.DARK_PATH_OFFSET)
            }
        }
        ;
        var xc = function(a) {
            this.constantProvider = a;
            this.OFFSET = .5;
            this.START_POINT = (0,
            t.moveBy)(this.OFFSET, this.OFFSET)
        };
        xc.prototype.init = function() {
            this.INSIDE_CORNER = this.makeInsideCorner();
            this.OUTSIDE_CORNER = this.makeOutsideCorner();
            this.PUZZLE_TAB = this.makePuzzleTab();
            this.NOTCH = this.makeNotch();
            this.JAGGED_TEETH = this.makeJaggedTeeth();
            this.START_HAT = this.makeStartHat()
        }
        ;
        xc.prototype.makeInsideCorner = function() {
            var a = this.constantProvider.CORNER_RADIUS
              , b = this.OFFSET
              , c = (1 - Math.SQRT1_2) * (a + b) - b
              , d = (0,
            t.moveBy)(c, c) + (0,
            t.arc)("a", "0 0,0", a, (0,
            t.point)(-c - b, a - c))
              , f = (0,
            t.arc)("a", "0 0,0", a + b, (0,
            t.point)(a + b, a + b))
              , g = (0,
            t.moveBy)(c, -c) + (0,
            t.arc)("a", "0 0,0", a + b, (0,
            t.point)(a - c, c + b));
            return {
                width: a + b,
                height: a,
                pathTop: function(m) {
                    return m ? d : ""
                },
                pathBottom: function(m) {
                    return m ? f : g
                }
            }
        }
        ;
        xc.prototype.makeOutsideCorner = function() {
            var a = this.constantProvider.CORNER_RADIUS
              , b = this.OFFSET
              , c = (1 - Math.SQRT1_2) * (a - b) + b
              , d = (0,
            t.moveBy)(c, c) + (0,
            t.arc)("a", "0 0,1", a - b, (0,
            t.point)(a - c, -c + b))
              , f = (0,
            t.moveBy)(b, a) + (0,
            t.arc)("a", "0 0,1", a - b, (0,
            t.point)(a, -a + b))
              , g = -c
              , m = (0,
            t.moveBy)(c, g) + (0,
            t.arc)("a", "0 0,1", a - b, (0,
            t.point)(-c + b, -g - a));
            return {
                height: a,
                topLeft: function(r) {
                    return r ? d : f
                },
                bottomLeft: function() {
                    return m
                }
            }
        }
        ;
        xc.prototype.makePuzzleTab = function() {
            var a = this.constantProvider.TAB_WIDTH
              , b = this.constantProvider.TAB_HEIGHT
              , c = (0,
            t.moveBy)(-2, -b + 3.4) + (0,
            t.lineTo)(-.45 * a, -2.1)
              , d = (0,
            t.lineOnAxis)("v", 2.5) + (0,
            t.moveBy)(.97 * -a, 2.5) + (0,
            t.curve)("q", [(0,
            t.point)(.05 * -a, 10), (0,
            t.point)(.3 * a, 9.5)]) + (0,
            t.moveBy)(.67 * a, -1.9) + (0,
            t.lineOnAxis)("v", 2.5)
              , f = (0,
            t.lineOnAxis)("v", -1.5) + (0,
            t.moveBy)(-.92 * a, -.5) + (0,
            t.curve)("q", [(0,
            t.point)(-.19 * a, -5.5), (0,
            t.point)(0, -11)]) + (0,
            t.moveBy)(.92 * a, 1)
              , g = (0,
            t.moveBy)(-5, b - .7) + (0,
            t.lineTo)(.46 * a, -2.1);
            return {
                width: a,
                height: b,
                pathUp: function(m) {
                    return m ? c : f
                },
                pathDown: function(m) {
                    return m ? d : g
                }
            }
        }
        ;
        xc.prototype.makeNotch = function() {
            return {
                pathLeft: (0,
                t.lineOnAxis)("h", this.OFFSET) + this.constantProvider.NOTCH.pathLeft
            }
        }
        ;
        xc.prototype.makeJaggedTeeth = function() {
            return {
                pathLeft: (0,
                t.lineTo)(5.1, 2.6) + (0,
                t.moveBy)(-10.2, 6.8) + (0,
                t.lineTo)(5.1, 2.6),
                height: 12,
                width: 10.2
            }
        }
        ;
        xc.prototype.makeStartHat = function() {
            var a = this.constantProvider.START_HAT.height
              , b = (0,
            t.moveBy)(25, -8.7) + (0,
            t.curve)("c", [(0,
            t.point)(29.7, -6.2), (0,
            t.point)(57.2, -.5), (0,
            t.point)(75, 8.7)])
              , c = (0,
            t.curve)("c", [(0,
            t.point)(17.8, -9.2), (0,
            t.point)(45.3, -14.9), (0,
            t.point)(75, -8.7)]) + (0,
            t.moveTo)(100.5, a + .5);
            return {
                path: function(d) {
                    return d ? b : c
                }
            }
        }
        ;
        var Pd = {
            InlineInput: function(a, b) {
                Pd.InlineInput.superClass_.constructor.call(this, a, b);
                this.connectedBlock && (this.width += this.constants_.DARK_PATH_OFFSET,
                this.height += this.constants_.DARK_PATH_OFFSET)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Pd.InlineInput, jd.InlineInput);
        var fb = {
            RenderInfo: function(a, b) {
                fb.RenderInfo.superClass_.constructor.call(this, a, b)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(fb.RenderInfo, wa);
        fb.RenderInfo.prototype.getRenderer = function() {
            return this.renderer_
        }
        ;
        fb.RenderInfo.prototype.populateBottomRow_ = function() {
            fb.RenderInfo.superClass_.populateBottomRow_.call(this);
            this.block_.inputList.length && this.block_.inputList[this.block_.inputList.length - 1].type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT || (this.bottomRow.minHeight = this.constants_.MEDIUM_PADDING - this.constants_.DARK_PATH_OFFSET)
        }
        ;
        fb.RenderInfo.prototype.addInput_ = function(a, b) {
            this.isInline && a.type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE ? (b.elements.push(new Pd.InlineInput(this.constants_,a)),
            b.hasInlineInput = !0) : a.type === e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT ? (b.elements.push(new Od.StatementInput(this.constants_,a)),
            b.hasStatement = !0) : a.type === e.module$exports$Blockly$inputTypes.inputTypes.VALUE ? (b.elements.push(new id.ExternalValueInput(this.constants_,a)),
            b.hasExternalInput = !0) : a.type === e.module$exports$Blockly$inputTypes.inputTypes.DUMMY && (b.minHeight = Math.max(b.minHeight, this.constants_.DUMMY_INPUT_MIN_HEIGHT),
            b.hasDummyInput = !0);
            this.isInline || null !== b.align || (b.align = a.align)
        }
        ;
        fb.RenderInfo.prototype.addElemSpacing_ = function() {
            for (var a = !1, b = 0, c; c = this.rows[b]; b++)
                c.hasExternalInput && (a = !0);
            for (b = 0; c = this.rows[b]; b++) {
                var d = c.elements;
                c.elements = [];
                c.startsWithElemSpacer() && c.elements.push(new pb.InRowSpacer(this.constants_,this.getInRowSpacing_(null, d[0])));
                if (d.length) {
                    for (var f = 0; f < d.length - 1; f++) {
                        c.elements.push(d[f]);
                        var g = this.getInRowSpacing_(d[f], d[f + 1]);
                        c.elements.push(new pb.InRowSpacer(this.constants_,g))
                    }
                    c.elements.push(d[d.length - 1]);
                    c.endsWithElemSpacer() && (d = this.getInRowSpacing_(d[d.length - 1], null),
                    a && c.hasDummyInput && (d += this.constants_.TAB_WIDTH),
                    c.elements.push(new pb.InRowSpacer(this.constants_,d)))
                }
            }
        }
        ;
        fb.RenderInfo.prototype.getInRowSpacing_ = function(a, b) {
            if (!a)
                return b && p.isField(b) && b.isEditable ? this.constants_.MEDIUM_PADDING : b && p.isInlineInput(b) ? this.constants_.MEDIUM_LARGE_PADDING : b && p.isStatementInput(b) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.LARGE_PADDING;
            if (!p.isInput(a) && (!b || p.isStatementInput(b)))
                return p.isField(a) && a.isEditable ? this.constants_.MEDIUM_PADDING : p.isIcon(a) ? 2 * this.constants_.LARGE_PADDING + 1 : p.isHat(a) ? this.constants_.NO_PADDING : p.isPreviousOrNextConnection(a) ? this.constants_.LARGE_PADDING : p.isLeftRoundedCorner(a) ? this.constants_.MIN_BLOCK_WIDTH : p.isJaggedEdge(a) ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING;
            if (p.isInput(a) && !b) {
                if (p.isExternalInput(a))
                    return this.constants_.NO_PADDING;
                if (p.isInlineInput(a))
                    return this.constants_.LARGE_PADDING;
                if (p.isStatementInput(a))
                    return this.constants_.NO_PADDING
            }
            if (!p.isInput(a) && b && p.isInput(b)) {
                if (p.isField(a) && a.isEditable) {
                    if (p.isInlineInput(b) || p.isExternalInput(b))
                        return this.constants_.SMALL_PADDING
                } else {
                    if (p.isInlineInput(b) || p.isExternalInput(b))
                        return this.constants_.MEDIUM_LARGE_PADDING;
                    if (p.isStatementInput(b))
                        return this.constants_.LARGE_PADDING
                }
                return this.constants_.LARGE_PADDING - 1
            }
            if (p.isIcon(a) && b && !p.isInput(b))
                return this.constants_.LARGE_PADDING;
            if (p.isInlineInput(a) && b && p.isField(b))
                return b.isEditable ? this.constants_.MEDIUM_PADDING : this.constants_.LARGE_PADDING;
            if (p.isLeftSquareCorner(a) && b) {
                if (p.isHat(b))
                    return this.constants_.NO_PADDING;
                if (p.isPreviousConnection(b))
                    return b.notchOffset;
                if (p.isNextConnection(b))
                    return b.notchOffset + (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2
            }
            if (p.isLeftRoundedCorner(a) && b) {
                if (p.isPreviousConnection(b))
                    return b.notchOffset - this.constants_.CORNER_RADIUS;
                if (p.isNextConnection(b))
                    return b.notchOffset - this.constants_.CORNER_RADIUS + (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2
            }
            return p.isField(a) && b && p.isField(b) && a.isEditable === b.isEditable || b && p.isJaggedEdge(b) ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
        }
        ;
        fb.RenderInfo.prototype.getSpacerRowHeight_ = function(a, b) {
            return p.isTopRow(a) && p.isBottomRow(b) ? this.constants_.EMPTY_BLOCK_SPACER_HEIGHT : p.isTopRow(a) || p.isBottomRow(b) ? this.constants_.NO_PADDING : a.hasExternalInput && b.hasExternalInput ? this.constants_.LARGE_PADDING : !a.hasStatement && b.hasStatement ? this.constants_.BETWEEN_STATEMENT_PADDING_Y : a.hasStatement && b.hasStatement || !a.hasStatement && b.hasDummyInput || a.hasDummyInput ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
        }
        ;
        fb.RenderInfo.prototype.getElemCenterline_ = function(a, b) {
            if (p.isSpacer(b))
                return a.yPos + b.height / 2;
            if (p.isBottomRow(a))
                return a = a.yPos + a.height - a.descenderHeight,
                p.isNextConnection(b) ? a + b.height / 2 : a - b.height / 2;
            if (p.isTopRow(a))
                return p.isHat(b) ? a.capline - b.height / 2 : a.capline + b.height / 2;
            var c = a.yPos;
            p.isField(b) || p.isIcon(b) ? (c += b.height / 2,
            (a.hasInlineInput || a.hasStatement) && b.height + this.constants_.TALL_INPUT_FIELD_OFFSET_Y <= a.height && (c += this.constants_.TALL_INPUT_FIELD_OFFSET_Y)) : c = p.isInlineInput(b) ? c + b.height / 2 : c + a.height / 2;
            return c
        }
        ;
        fb.RenderInfo.prototype.alignRowElements_ = function() {
            if (this.isInline) {
                for (var a = 0, b = null, c = this.rows.length - 1, d; d = this.rows[c]; c--)
                    d.nextRightEdge = a,
                    p.isInputRow(d) && (d.hasStatement && this.alignStatementRow_(d),
                    b && b.hasStatement && d.width < b.width ? d.nextRightEdge = b.width : a = d.width,
                    b = d);
                for (a = c = 0; b = this.rows[a]; a++)
                    b.hasStatement ? c = this.getDesiredRowWidth_(b) : p.isSpacer(b) ? b.width = Math.max(c, b.nextRightEdge) : (c = Math.max(c, b.nextRightEdge) - b.width,
                    0 < c && this.addAlignmentPadding_(b, c),
                    c = b.width)
            } else
                fb.RenderInfo.superClass_.alignRowElements_.call(this)
        }
        ;
        fb.RenderInfo.prototype.getDesiredRowWidth_ = function(a) {
            return this.isInline && a.hasStatement ? this.statementEdge + this.constants_.MAX_BOTTOM_WIDTH + this.startX : fb.RenderInfo.superClass_.getDesiredRowWidth_.call(this, a)
        }
        ;
        fb.RenderInfo.prototype.finalize_ = function() {
            for (var a = 0, b = 0, c = 0, d; d = this.rows[c]; c++) {
                d.yPos = b;
                d.xPos = this.startX;
                b += d.height;
                a = Math.max(a, d.widthWithConnectedBlocks);
                var f = b - this.topRow.ascenderHeight;
                d === this.bottomRow && f < this.constants_.MIN_BLOCK_HEIGHT && (f = this.constants_.MIN_BLOCK_HEIGHT - f,
                this.bottomRow.height += f,
                b += f);
                this.recordElemPositions_(d)
            }
            this.outputConnection && this.block_.nextConnection && this.block_.nextConnection.isConnected() && (a = Math.max(a, this.block_.nextConnection.targetBlock().getHeightWidth().width - this.constants_.DARK_PATH_OFFSET));
            this.bottomRow.baseline = b - this.bottomRow.descenderHeight;
            this.widthWithChildren = a + this.startX + this.constants_.DARK_PATH_OFFSET;
            this.width += this.constants_.DARK_PATH_OFFSET;
            this.height = b + this.constants_.DARK_PATH_OFFSET;
            this.startY = this.topRow.capline
        }
        ;
        var xb = {
            Renderer: function(a) {
                xb.Renderer.superClass_.constructor.call(this, a);
                this.highlightConstants_ = null
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(xb.Renderer, Ra);
        xb.Renderer.prototype.init = function(a, b) {
            xb.Renderer.superClass_.init.call(this, a, b);
            this.highlightConstants_ = this.makeHighlightConstants_();
            this.highlightConstants_.init()
        }
        ;
        xb.Renderer.prototype.refreshDom = function(a, b) {
            xb.Renderer.superClass_.refreshDom.call(this, a, b);
            this.getHighlightConstants().init()
        }
        ;
        xb.Renderer.prototype.makeConstants_ = function() {
            return new Zc.ConstantProvider
        }
        ;
        xb.Renderer.prototype.makeRenderInfo_ = function(a) {
            return new fb.RenderInfo(this,a)
        }
        ;
        xb.Renderer.prototype.makeDrawer_ = function(a, b) {
            return new Ka.Drawer(a,b)
        }
        ;
        xb.Renderer.prototype.makePathObject = function(a, b) {
            return new Db(a,b,this.getConstants())
        }
        ;
        xb.Renderer.prototype.makeHighlightConstants_ = function() {
            return new xc(this.getConstants())
        }
        ;
        xb.Renderer.prototype.getHighlightConstants = function() {
            return this.highlightConstants_
        }
        ;
        (0,
        ma.register)("geras", xb.Renderer);
        var gc = {};
        gc.ConstantProvider = Zc.ConstantProvider;
        gc.Drawer = Ka.Drawer;
        gc.HighlightConstantProvider = xc;
        gc.Highlighter = Ub;
        gc.InlineInput = Pd.InlineInput;
        gc.PathObject = Db;
        gc.RenderInfo = fb.RenderInfo;
        gc.Renderer = xb.Renderer;
        gc.StatementInput = Od.StatementInput;
        var sf = new mb("zelos",{
            colour_blocks: {
                colourPrimary: "#CF63CF",
                colourSecondary: "#C94FC9",
                colourTertiary: "#BD42BD"
            },
            list_blocks: {
                colourPrimary: "#9966FF",
                colourSecondary: "#855CD6",
                colourTertiary: "#774DCB"
            },
            logic_blocks: {
                colourPrimary: "#4C97FF",
                colourSecondary: "#4280D7",
                colourTertiary: "#3373CC"
            },
            loop_blocks: {
                colourPrimary: "#0fBD8C",
                colourSecondary: "#0DA57A",
                colourTertiary: "#0B8E69"
            },
            math_blocks: {
                colourPrimary: "#59C059",
                colourSecondary: "#46B946",
                colourTertiary: "#389438"
            },
            procedure_blocks: {
                colourPrimary: "#FF6680",
                colourSecondary: "#FF4D6A",
                colourTertiary: "#FF3355"
            },
            text_blocks: {
                colourPrimary: "#FFBF00",
                colourSecondary: "#E6AC00",
                colourTertiary: "#CC9900"
            },
            variable_blocks: {
                colourPrimary: "#FF8C1A",
                colourSecondary: "#FF8000",
                colourTertiary: "#DB6E00"
            },
            variable_dynamic_blocks: {
                colourPrimary: "#FF8C1A",
                colourSecondary: "#FF8000",
                colourTertiary: "#DB6E00"
            },
            hat_blocks: {
                colourPrimary: "#4C97FF",
                colourSecondary: "#4280D7",
                colourTertiary: "#3373CC",
                hat: "cap"
            }
        },{
            colour_category: {
                colour: "#CF63CF"
            },
            list_category: {
                colour: "#9966FF"
            },
            logic_category: {
                colour: "#4C97FF"
            },
            loop_category: {
                colour: "#0fBD8C"
            },
            math_category: {
                colour: "#59C059"
            },
            procedure_category: {
                colour: "#FF6680"
            },
            text_category: {
                colour: "#FFBF00"
            },
            variable_category: {
                colour: "#FF8C1A"
            },
            variable_dynamic_category: {
                colour: "#FF8C1A"
            }
        });
        var fe = {};
        fe.Classic = ud;
        fe.Zelos = sf;
        var lb = {
            names: {
                ESCAPE: "escape",
                DELETE: "delete",
                COPY: "copy",
                CUT: "cut",
                PASTE: "paste",
                UNDO: "undo",
                REDO: "redo"
            },
            registerEscape: function() {
                var a = {
                    name: lb.names.ESCAPE,
                    preconditionFn: function(b) {
                        return !b.options.readOnly
                    },
                    callback: function(b) {
                        b.hideChaff();
                        return !0
                    }
                };
                R.ShortcutRegistry.registry.register(a);
                R.ShortcutRegistry.registry.addKeyMapping(M.ESC, a.name)
            },
            registerDelete: function() {
                var a = {
                    name: lb.names.DELETE,
                    preconditionFn: function(b) {
                        var c = (0,
                        e.module$exports$Blockly$common.getSelected)();
                        return !b.options.readOnly && c && c.isDeletable()
                    },
                    callback: function(b, c) {
                        c.preventDefault();
                        if (ba.inProgress())
                            return !1;
                        (0,
                        e.module$exports$Blockly$common.getSelected)().checkAndDelete();
                        return !0
                    }
                };
                R.ShortcutRegistry.registry.register(a);
                R.ShortcutRegistry.registry.addKeyMapping(M.DELETE, a.name);
                R.ShortcutRegistry.registry.addKeyMapping(M.BACKSPACE, a.name)
            },
            registerCopy: function() {
                var a = {
                    name: lb.names.COPY,
                    preconditionFn: function(c) {
                        var d = (0,
                        e.module$exports$Blockly$common.getSelected)();
                        return !c.options.readOnly && !ba.inProgress() && d && d.isDeletable() && d.isMovable()
                    },
                    callback: function(c, d) {
                        d.preventDefault();
                        c.hideChaff();
                        (0,
                        yb.copy)((0,
                        e.module$exports$Blockly$common.getSelected)());
                        return !0
                    }
                };
                R.ShortcutRegistry.registry.register(a);
                var b = R.ShortcutRegistry.registry.createSerializedKey(M.C, [M.CTRL]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.C, [M.ALT]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.C, [M.META]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name)
            },
            registerCut: function() {
                var a = {
                    name: lb.names.CUT,
                    preconditionFn: function(c) {
                        var d = (0,
                        e.module$exports$Blockly$common.getSelected)();
                        return !c.options.readOnly && !ba.inProgress() && d && d.isDeletable() && d.isMovable() && !d.workspace.isFlyout
                    },
                    callback: function() {
                        var c = (0,
                        e.module$exports$Blockly$common.getSelected)();
                        if (!c)
                            return !1;
                        (0,
                        yb.copy)(c);
                        c.checkAndDelete();
                        return !0
                    }
                };
                R.ShortcutRegistry.registry.register(a);
                var b = R.ShortcutRegistry.registry.createSerializedKey(M.X, [M.CTRL]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.X, [M.ALT]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.X, [M.META]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name)
            },
            registerPaste: function() {
                var a = {
                    name: lb.names.PASTE,
                    preconditionFn: function(c) {
                        return !c.options.readOnly && !ba.inProgress()
                    },
                    callback: function() {
                        return (0,
                        yb.paste)()
                    }
                };
                R.ShortcutRegistry.registry.register(a);
                var b = R.ShortcutRegistry.registry.createSerializedKey(M.V, [M.CTRL]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.V, [M.ALT]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.V, [M.META]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name)
            },
            registerUndo: function() {
                var a = {
                    name: lb.names.UNDO,
                    preconditionFn: function(c) {
                        return !c.options.readOnly && !ba.inProgress()
                    },
                    callback: function(c) {
                        c.hideChaff();
                        c.undo(!1);
                        return !0
                    }
                };
                R.ShortcutRegistry.registry.register(a);
                var b = R.ShortcutRegistry.registry.createSerializedKey(M.Z, [M.CTRL]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.Z, [M.ALT]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.Z, [M.META]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name)
            },
            registerRedo: function() {
                var a = {
                    name: lb.names.REDO,
                    preconditionFn: function(c) {
                        return !ba.inProgress() && !c.options.readOnly
                    },
                    callback: function(c) {
                        c.hideChaff();
                        c.undo(!0);
                        return !0
                    }
                };
                R.ShortcutRegistry.registry.register(a);
                var b = R.ShortcutRegistry.registry.createSerializedKey(M.Z, [M.SHIFT, M.CTRL]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.Z, [M.SHIFT, M.ALT]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.Z, [M.SHIFT, M.META]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name);
                b = R.ShortcutRegistry.registry.createSerializedKey(M.Y, [M.CTRL]);
                R.ShortcutRegistry.registry.addKeyMapping(b, a.name)
            },
            registerDefaultShortcuts: function() {
                (0,
                lb.registerEscape)();
                (0,
                lb.registerDelete)();
                (0,
                lb.registerCopy)();
                (0,
                lb.registerCut)();
                (0,
                lb.registerPaste)();
                (0,
                lb.registerUndo)();
                (0,
                lb.registerRedo)()
            }
        };
        (0,
        lb.registerDefaultShortcuts)();
        var $c = function(a) {
            this.isBlank = "undefined" === typeof a;
            this.workspaceId = a ? a.id : "";
            this.group = (0,
            k.getGroup)();
            this.recordUndo = !1
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)($c, Gb);
        $c.prototype.type = k.FINISHED_LOADING;
        $c.prototype.toJson = function() {
            var a = {
                type: this.type
            };
            this.group && (a.group = this.group);
            this.workspaceId && (a.workspaceId = this.workspaceId);
            return a
        }
        ;
        $c.prototype.fromJson = function(a) {
            this.isBlank = !1;
            this.workspaceId = a.workspaceId;
            this.group = a.group
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.FINISHED_LOADING, $c);
        var yc = {
            Ui: function(a, b, c, d) {
                yc.Ui.superClass_.constructor.call(this, a ? a.workspace.id : void 0);
                this.blockId = a ? a.id : null;
                this.element = "undefined" === typeof b ? "" : b;
                this.oldValue = "undefined" === typeof c ? "" : c;
                this.newValue = "undefined" === typeof d ? "" : d
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(yc.Ui, vb.UiBase);
        yc.Ui.prototype.type = k.UI;
        yc.Ui.prototype.toJson = function() {
            var a = yc.Ui.superClass_.toJson.call(this);
            a.element = this.element;
            void 0 !== this.newValue && (a.newValue = this.newValue);
            this.blockId && (a.blockId = this.blockId);
            return a
        }
        ;
        yc.Ui.prototype.fromJson = function(a) {
            yc.Ui.superClass_.fromJson.call(this, a);
            this.element = a.element;
            this.newValue = a.newValue;
            this.blockId = a.blockId
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.UI, yc.Ui);
        var zc = {
            BubbleOpen: function(a, b, c) {
                zc.BubbleOpen.superClass_.constructor.call(this, a ? a.workspace.id : void 0);
                this.blockId = a ? a.id : null;
                this.isOpen = b;
                this.bubbleType = c
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(zc.BubbleOpen, vb.UiBase);
        zc.BubbleOpen.prototype.type = k.BUBBLE_OPEN;
        zc.BubbleOpen.prototype.toJson = function() {
            var a = zc.BubbleOpen.superClass_.toJson.call(this);
            a.isOpen = this.isOpen;
            a.bubbleType = this.bubbleType;
            a.blockId = this.blockId;
            return a
        }
        ;
        zc.BubbleOpen.prototype.fromJson = function(a) {
            zc.BubbleOpen.superClass_.fromJson.call(this, a);
            this.isOpen = a.isOpen;
            this.bubbleType = a.bubbleType;
            this.blockId = a.blockId
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.BUBBLE_OPEN, zc.BubbleOpen);
        var Vb = {
            CommentChange: function(a, b, c) {
                Vb.CommentChange.superClass_.constructor.call(this, a);
                a && (this.oldContents_ = "undefined" === typeof b ? "" : b,
                this.newContents_ = "undefined" === typeof c ? "" : c)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Vb.CommentChange, Bb);
        Vb.CommentChange.prototype.type = k.COMMENT_CHANGE;
        Vb.CommentChange.prototype.toJson = function() {
            var a = Vb.CommentChange.superClass_.toJson.call(this);
            a.oldContents = this.oldContents_;
            a.newContents = this.newContents_;
            return a
        }
        ;
        Vb.CommentChange.prototype.fromJson = function(a) {
            Vb.CommentChange.superClass_.fromJson.call(this, a);
            this.oldContents_ = a.oldContents;
            this.newContents_ = a.newContents
        }
        ;
        Vb.CommentChange.prototype.isNull = function() {
            return this.oldContents_ === this.newContents_
        }
        ;
        Vb.CommentChange.prototype.run = function(a) {
            var b = this.getEventWorkspace_().getCommentById(this.commentId);
            b ? b.setContent(a ? this.newContents_ : this.oldContents_) : console.warn("Can't change non-existent comment: " + this.commentId)
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.COMMENT_CHANGE, Vb.CommentChange);
        var hc = {
            CommentCreate: function(a) {
                hc.CommentCreate.superClass_.constructor.call(this, a);
                a && (this.xml = a.toXmlWithXY())
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(hc.CommentCreate, Bb);
        hc.CommentCreate.prototype.type = k.COMMENT_CREATE;
        hc.CommentCreate.prototype.toJson = function() {
            var a = hc.CommentCreate.superClass_.toJson.call(this);
            a.xml = (0,
            e.module$exports$Blockly$Xml.domToText)(this.xml);
            return a
        }
        ;
        hc.CommentCreate.prototype.fromJson = function(a) {
            hc.CommentCreate.superClass_.fromJson.call(this, a);
            this.xml = (0,
            e.module$exports$Blockly$Xml.textToDom)(a.xml)
        }
        ;
        hc.CommentCreate.prototype.run = function(a) {
            Bb.CommentCreateDeleteHelper(this, a)
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.COMMENT_CREATE, hc.CommentCreate);
        var ic = {
            CommentDelete: function(a) {
                ic.CommentDelete.superClass_.constructor.call(this, a);
                a && (this.xml = a.toXmlWithXY())
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(ic.CommentDelete, Bb);
        ic.CommentDelete.prototype.type = k.COMMENT_DELETE;
        ic.CommentDelete.prototype.toJson = function() {
            return ic.CommentDelete.superClass_.toJson.call(this)
        }
        ;
        ic.CommentDelete.prototype.fromJson = function(a) {
            ic.CommentDelete.superClass_.fromJson.call(this, a)
        }
        ;
        ic.CommentDelete.prototype.run = function(a) {
            Bb.CommentCreateDeleteHelper(this, !a)
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.COMMENT_DELETE, ic.CommentDelete);
        var Ac = {
            TrashcanOpen: function(a, b) {
                Ac.TrashcanOpen.superClass_.constructor.call(this, b);
                this.isOpen = a
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Ac.TrashcanOpen, vb.UiBase);
        Ac.TrashcanOpen.prototype.type = k.TRASHCAN_OPEN;
        Ac.TrashcanOpen.prototype.toJson = function() {
            var a = Ac.TrashcanOpen.superClass_.toJson.call(this);
            a.isOpen = this.isOpen;
            return a
        }
        ;
        Ac.TrashcanOpen.prototype.fromJson = function(a) {
            Ac.TrashcanOpen.superClass_.fromJson.call(this, a);
            this.isOpen = a.isOpen
        }
        ;
        (0,
        w.register)(w.Type.EVENT, k.TRASHCAN_OPEN, Ac.TrashcanOpen);
        e.module$exports$Blockly$Events = {
            Abstract: Gb
        };
        e.module$exports$Blockly$Events.BubbleOpen = zc.BubbleOpen;
        e.module$exports$Blockly$Events.BlockBase = Mb.BlockBase;
        e.module$exports$Blockly$Events.BlockChange = gb.BlockChange;
        e.module$exports$Blockly$Events.BlockCreate = Xb.BlockCreate;
        e.module$exports$Blockly$Events.BlockDelete = ec.BlockDelete;
        e.module$exports$Blockly$Events.BlockDrag = nc.BlockDrag;
        e.module$exports$Blockly$Events.BlockMove = Ab.BlockMove;
        e.module$exports$Blockly$Events.Click = oc.Click;
        e.module$exports$Blockly$Events.CommentBase = Bb;
        e.module$exports$Blockly$Events.CommentChange = Vb.CommentChange;
        e.module$exports$Blockly$Events.CommentCreate = hc.CommentCreate;
        e.module$exports$Blockly$Events.CommentDelete = ic.CommentDelete;
        e.module$exports$Blockly$Events.CommentMove = Cb.CommentMove;
        e.module$exports$Blockly$Events.FinishedLoading = $c;
        e.module$exports$Blockly$Events.MarkerMove = pc.MarkerMove;
        e.module$exports$Blockly$Events.Selected = sc.Selected;
        e.module$exports$Blockly$Events.ThemeChange = uc.ThemeChange;
        e.module$exports$Blockly$Events.ToolboxItemSelect = wc.ToolboxItemSelect;
        e.module$exports$Blockly$Events.TrashcanOpen = Ac.TrashcanOpen;
        e.module$exports$Blockly$Events.Ui = yc.Ui;
        e.module$exports$Blockly$Events.UiBase = vb.UiBase;
        e.module$exports$Blockly$Events.VarBase = $b.VarBase;
        e.module$exports$Blockly$Events.VarCreate = ac.VarCreate;
        e.module$exports$Blockly$Events.VarDelete = bc.VarDelete;
        e.module$exports$Blockly$Events.VarRename = cc.VarRename;
        e.module$exports$Blockly$Events.ViewportChange = vc.ViewportChange;
        e.module$exports$Blockly$Events.BLOCK_CHANGE = k.CHANGE;
        e.module$exports$Blockly$Events.BLOCK_CREATE = k.CREATE;
        e.module$exports$Blockly$Events.BLOCK_DELETE = k.DELETE;
        e.module$exports$Blockly$Events.BLOCK_DRAG = k.BLOCK_DRAG;
        e.module$exports$Blockly$Events.BLOCK_MOVE = k.MOVE;
        e.module$exports$Blockly$Events.BUBBLE_OPEN = k.BUBBLE_OPEN;
        e.module$exports$Blockly$Events.BumpEvent = k.BumpEvent;
        e.module$exports$Blockly$Events.BUMP_EVENTS = k.BUMP_EVENTS;
        e.module$exports$Blockly$Events.CHANGE = k.CHANGE;
        e.module$exports$Blockly$Events.CLICK = k.CLICK;
        e.module$exports$Blockly$Events.COMMENT_CHANGE = k.COMMENT_CHANGE;
        e.module$exports$Blockly$Events.COMMENT_CREATE = k.COMMENT_CREATE;
        e.module$exports$Blockly$Events.COMMENT_DELETE = k.COMMENT_DELETE;
        e.module$exports$Blockly$Events.COMMENT_MOVE = k.COMMENT_MOVE;
        e.module$exports$Blockly$Events.CREATE = k.CREATE;
        e.module$exports$Blockly$Events.DELETE = k.DELETE;
        e.module$exports$Blockly$Events.FINISHED_LOADING = k.FINISHED_LOADING;
        e.module$exports$Blockly$Events.MARKER_MOVE = k.MARKER_MOVE;
        e.module$exports$Blockly$Events.MOVE = k.MOVE;
        e.module$exports$Blockly$Events.SELECTED = k.SELECTED;
        e.module$exports$Blockly$Events.THEME_CHANGE = k.THEME_CHANGE;
        e.module$exports$Blockly$Events.TOOLBOX_ITEM_SELECT = k.TOOLBOX_ITEM_SELECT;
        e.module$exports$Blockly$Events.TRASHCAN_OPEN = k.TRASHCAN_OPEN;
        e.module$exports$Blockly$Events.UI = k.UI;
        e.module$exports$Blockly$Events.VAR_CREATE = k.VAR_CREATE;
        e.module$exports$Blockly$Events.VAR_DELETE = k.VAR_DELETE;
        e.module$exports$Blockly$Events.VAR_RENAME = k.VAR_RENAME;
        e.module$exports$Blockly$Events.VIEWPORT_CHANGE = k.VIEWPORT_CHANGE;
        e.module$exports$Blockly$Events.clearPendingUndo = k.clearPendingUndo;
        e.module$exports$Blockly$Events.disable = k.disable;
        e.module$exports$Blockly$Events.enable = k.enable;
        e.module$exports$Blockly$Events.filter = k.filter;
        e.module$exports$Blockly$Events.fire = k.fire;
        e.module$exports$Blockly$Events.fromJson = k.fromJson;
        e.module$exports$Blockly$Events.getDescendantIds = k.getDescendantIds;
        e.module$exports$Blockly$Events.get = k.get;
        e.module$exports$Blockly$Events.getGroup = k.getGroup;
        e.module$exports$Blockly$Events.getRecordUndo = k.getRecordUndo;
        e.module$exports$Blockly$Events.isEnabled = k.isEnabled;
        e.module$exports$Blockly$Events.setGroup = k.setGroup;
        e.module$exports$Blockly$Events.setRecordUndo = k.setRecordUndo;
        e.module$exports$Blockly$Events.disableOrphans = k.disableOrphans;
        Object.defineProperties(e.module$exports$Blockly$Events, {
            recordUndo: {
                get: function() {
                    (0,
                    q.warn)("Blockly.Events.recordUndo", "September 2021", "September 2022", "Blockly.Events.getRecordUndo()");
                    return (0,
                    k.getRecordUndo)()
                },
                set: function(a) {
                    (0,
                    q.warn)("Blockly.Events.recordUndo", "September 2021", "September 2022", "Blockly.Events.setRecordUndo()");
                    (0,
                    k.setRecordUndo)(a)
                }
            }
        });
        var Aa = {
            registerUndo: function() {
                ia.ContextMenuRegistry.registry.register({
                    displayText: function() {
                        return e.module$exports$Blockly$Msg.Msg.UNDO
                    },
                    preconditionFn: function(a) {
                        return 0 < a.workspace.getUndoStack().length ? "enabled" : "disabled"
                    },
                    callback: function(a) {
                        a.workspace.undo(!1)
                    },
                    scopeType: ia.ContextMenuRegistry.ScopeType.WORKSPACE,
                    id: "undoWorkspace",
                    weight: 1
                })
            },
            registerRedo: function() {
                ia.ContextMenuRegistry.registry.register({
                    displayText: function() {
                        return e.module$exports$Blockly$Msg.Msg.REDO
                    },
                    preconditionFn: function(a) {
                        return 0 < a.workspace.getRedoStack().length ? "enabled" : "disabled"
                    },
                    callback: function(a) {
                        a.workspace.undo(!0)
                    },
                    scopeType: ia.ContextMenuRegistry.ScopeType.WORKSPACE,
                    id: "redoWorkspace",
                    weight: 2
                })
            },
            registerCleanup: function() {
                ia.ContextMenuRegistry.registry.register({
                    displayText: function() {
                        return e.module$exports$Blockly$Msg.Msg.CLEAN_UP
                    },
                    preconditionFn: function(a) {
                        return a.workspace.isMovable() ? 1 < a.workspace.getTopBlocks(!1).length ? "enabled" : "disabled" : "hidden"
                    },
                    callback: function(a) {
                        a.workspace.cleanUp()
                    },
                    scopeType: ia.ContextMenuRegistry.ScopeType.WORKSPACE,
                    id: "cleanWorkspace",
                    weight: 3
                })
            }
        }
          , Qe = function(a, b) {
            var c = 0
              , d = 0
              , f = function(r) {
                d--;
                r.setCollapsed(a);
                0 === d && (0,
                e.module$exports$Blockly$Events.setGroup)(!1)
            };
            (0,
            e.module$exports$Blockly$Events.setGroup)(!0);
            for (var g = 0; g < b.length; g++)
                for (var m = b[g]; m; )
                    d++,
                    setTimeout(f.bind(null, m), c),
                    m = m.getNextBlock(),
                    c += 10
        };
        Aa.registerCollapse = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function() {
                    return e.module$exports$Blockly$Msg.Msg.COLLAPSE_ALL
                },
                preconditionFn: function(a) {
                    if (a.workspace.options.collapse) {
                        a = a.workspace.getTopBlocks(!1);
                        for (var b = 0; b < a.length; b++)
                            for (var c = a[b]; c; ) {
                                if (!c.isCollapsed())
                                    return "enabled";
                                c = c.getNextBlock()
                            }
                        return "disabled"
                    }
                    return "hidden"
                },
                callback: function(a) {
                    Qe(!0, a.workspace.getTopBlocks(!0))
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.WORKSPACE,
                id: "collapseWorkspace",
                weight: 4
            })
        }
        ;
        Aa.registerExpand = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function() {
                    return e.module$exports$Blockly$Msg.Msg.EXPAND_ALL
                },
                preconditionFn: function(a) {
                    if (a.workspace.options.collapse) {
                        a = a.workspace.getTopBlocks(!1);
                        for (var b = 0; b < a.length; b++)
                            for (var c = a[b]; c; ) {
                                if (c.isCollapsed())
                                    return "enabled";
                                c = c.getNextBlock()
                            }
                        return "disabled"
                    }
                    return "hidden"
                },
                callback: function(a) {
                    Qe(!1, a.workspace.getTopBlocks(!0))
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.WORKSPACE,
                id: "expandWorkspace",
                weight: 5
            })
        }
        ;
        var Re = function(a, b) {
            if (a.isDeletable())
                Array.prototype.push.apply(b, a.getDescendants(!1));
            else {
                a = a.getChildren(!1);
                for (var c = 0; c < a.length; c++)
                    Re(a[c], b)
            }
        }
          , ge = function(a) {
            var b = [];
            a = a.getTopBlocks(!0);
            for (var c = 0; c < a.length; c++)
                Re(a[c], b);
            return b
        }
          , Qd = function(a, b) {
            (0,
            k.setGroup)(b);
            var c = a.shift();
            c && (c.workspace ? (c.dispose(!1, !0),
            setTimeout(Qd, 10, a, b)) : Qd(a, b));
            (0,
            k.setGroup)(!1)
        };
        Aa.registerDeleteAll = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function(a) {
                    if (a.workspace)
                        return a = ge(a.workspace).length,
                        1 === a ? e.module$exports$Blockly$Msg.Msg.DELETE_BLOCK : e.module$exports$Blockly$Msg.Msg.DELETE_X_BLOCKS.replace("%1", String(a))
                },
                preconditionFn: function(a) {
                    if (a.workspace)
                        return 0 < ge(a.workspace).length ? "enabled" : "disabled"
                },
                callback: function(a) {
                    if (a.workspace) {
                        a.workspace.cancelCurrentGesture();
                        var b = ge(a.workspace)
                          , c = (0,
                        bb.genUid)();
                        2 > b.length ? Qd(b, c) : (0,
                        Ua.confirm)(e.module$exports$Blockly$Msg.Msg.DELETE_ALL_BLOCKS.replace("%1", String(b.length)), function(d) {
                            d && Qd(b, c)
                        })
                    }
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.WORKSPACE,
                id: "workspaceDelete",
                weight: 6
            })
        }
        ;
        Aa.registerDuplicate = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function() {
                    return e.module$exports$Blockly$Msg.Msg.DUPLICATE_BLOCK
                },
                preconditionFn: function(a) {
                    a = a.block;
                    return !a.isInFlyout && a.isDeletable() && a.isMovable() ? a.isDuplicatable() ? "enabled" : "disabled" : "hidden"
                },
                callback: function(a) {
                    a.block && (0,
                    yb.duplicate)(a.block)
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.BLOCK,
                id: "blockDuplicate",
                weight: 1
            })
        }
        ;
        Aa.registerComment = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function(a) {
                    return a.block.getCommentIcon() ? e.module$exports$Blockly$Msg.Msg.REMOVE_COMMENT : e.module$exports$Blockly$Msg.Msg.ADD_COMMENT
                },
                preconditionFn: function(a) {
                    a = a.block;
                    return V.IE || a.isInFlyout || !a.workspace.options.comments || a.isCollapsed() || !a.isEditable() ? "hidden" : "enabled"
                },
                callback: function(a) {
                    a = a.block;
                    a.getCommentIcon() ? a.setCommentText(null) : a.setCommentText("")
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.BLOCK,
                id: "blockComment",
                weight: 2
            })
        }
        ;
        Aa.registerInline = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function(a) {
                    return a.block.getInputsInline() ? e.module$exports$Blockly$Msg.Msg.EXTERNAL_INPUTS : e.module$exports$Blockly$Msg.Msg.INLINE_INPUTS
                },
                preconditionFn: function(a) {
                    a = a.block;
                    if (!a.isInFlyout && a.isMovable() && !a.isCollapsed())
                        for (var b = 1; b < a.inputList.length; b++)
                            if (a.inputList[b - 1].type !== e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT && a.inputList[b].type !== e.module$exports$Blockly$inputTypes.inputTypes.STATEMENT)
                                return "enabled";
                    return "hidden"
                },
                callback: function(a) {
                    a.block.setInputsInline(!a.block.getInputsInline())
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.BLOCK,
                id: "blockInline",
                weight: 3
            })
        }
        ;
        Aa.registerCollapseExpandBlock = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function(a) {
                    return a.block.isCollapsed() ? e.module$exports$Blockly$Msg.Msg.EXPAND_BLOCK : e.module$exports$Blockly$Msg.Msg.COLLAPSE_BLOCK
                },
                preconditionFn: function(a) {
                    a = a.block;
                    return !a.isInFlyout && a.isMovable() && a.workspace.options.collapse ? "enabled" : "hidden"
                },
                callback: function(a) {
                    a.block.setCollapsed(!a.block.isCollapsed())
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.BLOCK,
                id: "blockCollapseExpand",
                weight: 4
            })
        }
        ;
        Aa.registerDisable = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function(a) {
                    return a.block.isEnabled() ? e.module$exports$Blockly$Msg.Msg.DISABLE_BLOCK : e.module$exports$Blockly$Msg.Msg.ENABLE_BLOCK
                },
                preconditionFn: function(a) {
                    a = a.block;
                    return !a.isInFlyout && a.workspace.options.disable && a.isEditable() ? a.getInheritedDisabled() ? "disabled" : "enabled" : "hidden"
                },
                callback: function(a) {
                    a = a.block;
                    var b = (0,
                    k.getGroup)();
                    b || (0,
                    k.setGroup)(!0);
                    a.setEnabled(!a.isEnabled());
                    b || (0,
                    k.setGroup)(!1)
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.BLOCK,
                id: "blockDisable",
                weight: 5
            })
        }
        ;
        Aa.registerDelete = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function(a) {
                    var b = a.block;
                    a = b.getDescendants(!1).length;
                    (b = b.getNextBlock()) && (a -= b.getDescendants(!1).length);
                    return 1 === a ? e.module$exports$Blockly$Msg.Msg.DELETE_BLOCK : e.module$exports$Blockly$Msg.Msg.DELETE_X_BLOCKS.replace("%1", String(a))
                },
                preconditionFn: function(a) {
                    return !a.block.isInFlyout && a.block.isDeletable() ? "enabled" : "hidden"
                },
                callback: function(a) {
                    a.block && a.block.checkAndDelete()
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.BLOCK,
                id: "blockDelete",
                weight: 6
            })
        }
        ;
        Aa.registerHelp = function() {
            ia.ContextMenuRegistry.registry.register({
                displayText: function() {
                    return e.module$exports$Blockly$Msg.Msg.HELP
                },
                preconditionFn: function(a) {
                    a = a.block;
                    return ("function" === typeof a.helpUrl ? a.helpUrl() : a.helpUrl) ? "enabled" : "hidden"
                },
                callback: function(a) {
                    a.block.showHelp()
                },
                scopeType: ia.ContextMenuRegistry.ScopeType.BLOCK,
                id: "blockHelp",
                weight: 7
            })
        }
        ;
        Aa.registerDefaultOptions = function() {
            (0,
            Aa.registerUndo)();
            (0,
            Aa.registerRedo)();
            (0,
            Aa.registerCleanup)();
            (0,
            Aa.registerCollapse)();
            (0,
            Aa.registerExpand)();
            (0,
            Aa.registerDeleteAll)();
            (0,
            Aa.registerDuplicate)();
            (0,
            Aa.registerComment)();
            (0,
            Aa.registerInline)();
            (0,
            Aa.registerCollapseExpandBlock)();
            (0,
            Aa.registerDisable)();
            (0,
            Aa.registerDelete)();
            (0,
            Aa.registerHelp)()
        }
        ;
        (0,
        Aa.registerDefaultOptions)();
        var La = function(a) {
            this.block_ = a;
            this.iconGroup_ = null
        };
        La.prototype.collapseHidden = !0;
        La.prototype.SIZE = 17;
        La.prototype.bubble_ = null;
        La.prototype.iconXY_ = null;
        La.prototype.createIcon = function() {
            this.iconGroup_ || (this.iconGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyIconGroup"
            }, null),
            this.block_.isInFlyout && (0,
            n.addClass)(this.iconGroup_, "blocklyIconGroupReadonly"),
            this.drawIcon_(this.iconGroup_),
            this.block_.getSvgRoot().appendChild(this.iconGroup_),
            (0,
            y.conditionalBind)(this.iconGroup_, "mouseup", this, this.iconClick_),
            this.updateEditable())
        }
        ;
        La.prototype.dispose = function() {
            (0,
            n.removeNode)(this.iconGroup_);
            this.iconGroup_ = null;
            this.setVisible(!1);
            this.block_ = null
        }
        ;
        La.prototype.updateEditable = function() {}
        ;
        La.prototype.isVisible = function() {
            return !!this.bubble_
        }
        ;
        La.prototype.iconClick_ = function(a) {
            this.block_.workspace.isDragging() || this.block_.isInFlyout || (0,
            y.isRightButton)(a) || this.setVisible(!this.isVisible())
        }
        ;
        La.prototype.applyColour = function() {
            this.isVisible() && this.bubble_.setColour(this.block_.style.colourPrimary)
        }
        ;
        La.prototype.setIconLocation = function(a) {
            this.iconXY_ = a;
            this.isVisible() && this.bubble_.setAnchorLocation(a)
        }
        ;
        La.prototype.computeIconLocation = function() {
            var a = this.block_.getRelativeToSurfaceXY()
              , b = (0,
            ja.getRelativeXY)(this.iconGroup_);
            a = new J(a.x + b.x + this.SIZE / 2,a.y + b.y + this.SIZE / 2);
            J.equals(this.getIconLocation(), a) || this.setIconLocation(a)
        }
        ;
        La.prototype.getIconLocation = function() {
            return this.iconXY_
        }
        ;
        La.prototype.getCorrectedSize = function() {
            return new Pa(La.prototype.SIZE,La.prototype.SIZE - 2)
        }
        ;
        var Hb = {
            Warning: function(a) {
                Hb.Warning.superClass_.constructor.call(this, a);
                this.createIcon();
                this.text_ = Object.create(null)
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Hb.Warning, La);
        Hb.Warning.prototype.collapseHidden = !1;
        Hb.Warning.prototype.drawIcon_ = function(a) {
            (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyIconShape",
                d: "M2,15Q-1,15 0.5,12L6.5,1.7Q8,-1 9.5,1.7L15.5,12Q17,15 14,15z"
            }, a);
            (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyIconSymbol",
                d: "m7,4.8v3.16l0.27,2.27h1.46l0.27,-2.27v-3.16z"
            }, a);
            (0,
            n.createSvgElement)(u.RECT, {
                "class": "blocklyIconSymbol",
                x: "7",
                y: "11",
                height: "2",
                width: "2"
            }, a)
        }
        ;
        Hb.Warning.prototype.setVisible = function(a) {
            a !== this.isVisible() && ((0,
            k.fire)(new ((0,
            k.get)(k.BUBBLE_OPEN))(this.block_,a,"warning")),
            a ? this.createBubble_() : this.disposeBubble_())
        }
        ;
        Hb.Warning.prototype.createBubble_ = function() {
            this.paragraphElement_ = H.Bubble.textToDom(this.getText());
            this.bubble_ = H.Bubble.createNonEditableBubble(this.paragraphElement_, this.block_, this.iconXY_);
            this.applyColour()
        }
        ;
        Hb.Warning.prototype.disposeBubble_ = function() {
            this.bubble_.dispose();
            this.paragraphElement_ = this.bubble_ = null
        }
        ;
        Hb.Warning.prototype.setText = function(a, b) {
            this.text_[b] !== a && (a ? this.text_[b] = a : delete this.text_[b],
            this.isVisible() && (this.setVisible(!1),
            this.setVisible(!0)))
        }
        ;
        Hb.Warning.prototype.getText = function() {
            var a = [], b;
            for (b in this.text_)
                a.push(this.text_[b]);
            return a.join("\n")
        }
        ;
        Hb.Warning.prototype.dispose = function() {
            this.block_.warning = null;
            La.prototype.dispose.call(this)
        }
        ;
        var Qa = {
            Comment: function(a) {
                Qa.Comment.superClass_.constructor.call(this, a);
                this.model_ = a.commentModel;
                this.model_.text = this.model_.text || "";
                this.cachedText_ = "";
                this.onInputWrapper_ = this.onChangeWrapper_ = this.onWheelWrapper_ = this.onMouseUpWrapper_ = null;
                this.createIcon()
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(Qa.Comment, La);
        Qa.Comment.prototype.drawIcon_ = function(a) {
            (0,
            n.createSvgElement)(u.CIRCLE, {
                "class": "blocklyIconShape",
                r: "8",
                cx: "8",
                cy: "8"
            }, a);
            (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyIconSymbol",
                d: "m6.8,10h2c0.003,-0.617 0.271,-0.962 0.633,-1.266 2.875,-2.4050.607,-5.534 -3.765,-3.874v1.7c3.12,-1.657 3.698,0.118 2.336,1.25-1.201,0.998 -1.201,1.528 -1.204,2.19z"
            }, a);
            (0,
            n.createSvgElement)(u.RECT, {
                "class": "blocklyIconSymbol",
                x: "6.8",
                y: "10.78",
                height: "2",
                width: "2"
            }, a)
        }
        ;
        Qa.Comment.prototype.createEditor_ = function() {
            this.foreignObject_ = (0,
            n.createSvgElement)(u.FOREIGNOBJECT, {
                x: H.Bubble.BORDER_WIDTH,
                y: H.Bubble.BORDER_WIDTH
            }, null);
            var a = document.createElementNS(n.HTML_NS, "body");
            a.setAttribute("xmlns", n.HTML_NS);
            a.className = "blocklyMinimalBody";
            var b = this.textarea_ = document.createElementNS(n.HTML_NS, "textarea");
            b.className = "blocklyCommentTextarea";
            b.setAttribute("dir", this.block_.RTL ? "RTL" : "LTR");
            b.value = this.model_.text;
            this.resizeTextarea_();
            a.appendChild(b);
            this.foreignObject_.appendChild(a);
            this.onMouseUpWrapper_ = (0,
            y.conditionalBind)(b, "mouseup", this, this.startEdit_, !0, !0);
            this.onWheelWrapper_ = (0,
            y.conditionalBind)(b, "wheel", this, function(c) {
                c.stopPropagation()
            });
            this.onChangeWrapper_ = (0,
            y.conditionalBind)(b, "change", this, function(c) {
                this.cachedText_ !== this.model_.text && (0,
                k.fire)(new ((0,
                k.get)(k.CHANGE))(this.block_,"comment",null,this.cachedText_,this.model_.text))
            });
            this.onInputWrapper_ = (0,
            y.conditionalBind)(b, "input", this, function(c) {
                this.model_.text = b.value
            });
            setTimeout(b.focus.bind(b), 0);
            return this.foreignObject_
        }
        ;
        Qa.Comment.prototype.updateEditable = function() {
            Qa.Comment.superClass_.updateEditable.call(this);
            this.isVisible() && (this.disposeBubble_(),
            this.createBubble_())
        }
        ;
        Qa.Comment.prototype.onBubbleResize_ = function() {
            this.isVisible() && (this.model_.size = this.bubble_.getBubbleSize(),
            this.resizeTextarea_())
        }
        ;
        Qa.Comment.prototype.resizeTextarea_ = function() {
            var a = this.model_.size
              , b = 2 * H.Bubble.BORDER_WIDTH
              , c = a.width - b;
            a = a.height - b;
            this.foreignObject_.setAttribute("width", c);
            this.foreignObject_.setAttribute("height", a);
            this.textarea_.style.width = c - 4 + "px";
            this.textarea_.style.height = a - 4 + "px"
        }
        ;
        Qa.Comment.prototype.setVisible = function(a) {
            a !== this.isVisible() && ((0,
            k.fire)(new ((0,
            k.get)(k.BUBBLE_OPEN))(this.block_,a,"comment")),
            (this.model_.pinned = a) ? this.createBubble_() : this.disposeBubble_())
        }
        ;
        Qa.Comment.prototype.createBubble_ = function() {
            !this.block_.isEditable() || V.IE ? this.createNonEditableBubble_() : this.createEditableBubble_()
        }
        ;
        Qa.Comment.prototype.createEditableBubble_ = function() {
            this.bubble_ = new H.Bubble(this.block_.workspace,this.createEditor_(),this.block_.pathObject.svgPath,this.iconXY_,this.model_.size.width,this.model_.size.height);
            this.bubble_.setSvgId(this.block_.id);
            this.bubble_.registerResizeEvent(this.onBubbleResize_.bind(this));
            this.applyColour()
        }
        ;
        Qa.Comment.prototype.createNonEditableBubble_ = function() {
            this.paragraphElement_ = H.Bubble.textToDom(this.block_.getCommentText());
            this.bubble_ = H.Bubble.createNonEditableBubble(this.paragraphElement_, this.block_, this.iconXY_);
            this.applyColour()
        }
        ;
        Qa.Comment.prototype.disposeBubble_ = function() {
            this.onMouseUpWrapper_ && ((0,
            y.unbind)(this.onMouseUpWrapper_),
            this.onMouseUpWrapper_ = null);
            this.onWheelWrapper_ && ((0,
            y.unbind)(this.onWheelWrapper_),
            this.onWheelWrapper_ = null);
            this.onChangeWrapper_ && ((0,
            y.unbind)(this.onChangeWrapper_),
            this.onChangeWrapper_ = null);
            this.onInputWrapper_ && ((0,
            y.unbind)(this.onInputWrapper_),
            this.onInputWrapper_ = null);
            this.bubble_.dispose();
            this.paragraphElement_ = this.foreignObject_ = this.textarea_ = this.bubble_ = null
        }
        ;
        Qa.Comment.prototype.startEdit_ = function(a) {
            this.bubble_.promote() && this.textarea_.focus();
            this.cachedText_ = this.model_.text
        }
        ;
        Qa.Comment.prototype.getBubbleSize = function() {
            return this.model_.size
        }
        ;
        Qa.Comment.prototype.setBubbleSize = function(a, b) {
            this.bubble_ ? this.bubble_.setBubbleSize(a, b) : (this.model_.size.width = a,
            this.model_.size.height = b)
        }
        ;
        Qa.Comment.prototype.updateText = function() {
            this.textarea_ ? this.textarea_.value = this.model_.text : this.paragraphElement_ && (this.paragraphElement_.firstChild.textContent = this.model_.text)
        }
        ;
        Qa.Comment.prototype.dispose = function() {
            this.block_.comment = null;
            La.prototype.dispose.call(this)
        }
        ;
        (0,
        v.register)("\n  .blocklyCommentTextarea {\n    background-color: #fef49c;\n    border: 0;\n    display: block;\n    margin: 0;\n    outline: 0;\n    padding: 3px;\n    resize: none;\n    text-overflow: hidden;\n  }\n");
        var Sa = {
            verticalPosition: {
                TOP: 0,
                BOTTOM: 1
            },
            horizontalPosition: {
                LEFT: 0,
                RIGHT: 1
            },
            bumpDirection: {
                UP: 0,
                DOWN: 1
            },
            getStartPositionRect: function(a, b, c, d, f, g) {
                var m = g.scrollbar && g.scrollbar.canScrollVertically();
                a.horizontal === Sa.horizontalPosition.LEFT ? (c = f.absoluteMetrics.left + c,
                m && g.RTL && (c += L.Scrollbar.scrollbarThickness)) : (c = f.absoluteMetrics.left + f.viewMetrics.width - b.width - c,
                m && !g.RTL && (c -= L.Scrollbar.scrollbarThickness));
                a.vertical === Sa.verticalPosition.TOP ? a = f.absoluteMetrics.top + d : (a = f.absoluteMetrics.top + f.viewMetrics.height - b.height - d,
                g.scrollbar && g.scrollbar.canScrollHorizontally() && (a -= L.Scrollbar.scrollbarThickness));
                return new Ha(a,a + b.height,c,c + b.width)
            },
            getCornerOppositeToolbox: function(a, b) {
                return {
                    horizontal: b.toolboxMetrics.position === X.Position.LEFT || a.horizontalLayout && !a.RTL ? Sa.horizontalPosition.RIGHT : Sa.horizontalPosition.LEFT,
                    vertical: b.toolboxMetrics.position === X.Position.BOTTOM ? Sa.verticalPosition.TOP : Sa.verticalPosition.BOTTOM
                }
            },
            bumpPositionRect: function(a, b, c, d) {
                for (var f = a.left, g = a.right - a.left, m = a.bottom - a.top, r = 0; r < d.length; r++) {
                    var B = d[r];
                    a.intersects(B) && (a = c === Sa.bumpDirection.UP ? B.top - m - b : B.bottom + b,
                    a = new Ha(a,a + m,f,f + g),
                    r = -1)
                }
                return a
            }
        }
          , Na = {
            ZoomControls: function(a) {
                this.workspace_ = a;
                this.id = "zoomControls";
                this.zoomResetGroup_ = this.zoomOutGroup_ = this.zoomInGroup_ = this.onZoomOutWrapper_ = this.onZoomInWrapper_ = this.onZoomResetWrapper_ = null
            }
        };
        Na.ZoomControls.prototype.WIDTH_ = 32;
        Na.ZoomControls.prototype.HEIGHT_ = 32;
        Na.ZoomControls.prototype.SMALL_SPACING_ = 2;
        Na.ZoomControls.prototype.LARGE_SPACING_ = 11;
        Na.ZoomControls.prototype.MARGIN_VERTICAL_ = 20;
        Na.ZoomControls.prototype.MARGIN_HORIZONTAL_ = 20;
        Na.ZoomControls.prototype.svgGroup_ = null;
        Na.ZoomControls.prototype.left_ = 0;
        Na.ZoomControls.prototype.top_ = 0;
        Na.ZoomControls.prototype.initialized_ = !1;
        Na.ZoomControls.prototype.createDom = function() {
            this.svgGroup_ = (0,
            n.createSvgElement)(u.G, {}, null);
            var a = String(Math.random()).substring(2);
            this.createZoomOutSvg_(a);
            this.createZoomInSvg_(a);
            this.workspace_.isMovable() && this.createZoomResetSvg_(a);
            return this.svgGroup_
        }
        ;
        Na.ZoomControls.prototype.init = function() {
            this.workspace_.getComponentManager().addComponent({
                component: this,
                weight: 2,
                capabilities: [oa.Capability.POSITIONABLE]
            });
            this.initialized_ = !0
        }
        ;
        Na.ZoomControls.prototype.dispose = function() {
            this.workspace_.getComponentManager().removeComponent("zoomControls");
            this.svgGroup_ && (0,
            n.removeNode)(this.svgGroup_);
            this.onZoomResetWrapper_ && (0,
            y.unbind)(this.onZoomResetWrapper_);
            this.onZoomInWrapper_ && (0,
            y.unbind)(this.onZoomInWrapper_);
            this.onZoomOutWrapper_ && (0,
            y.unbind)(this.onZoomOutWrapper_)
        }
        ;
        Na.ZoomControls.prototype.getBoundingRectangle = function() {
            var a = this.SMALL_SPACING_ + 2 * this.HEIGHT_;
            this.zoomResetGroup_ && (a += this.LARGE_SPACING_ + this.HEIGHT_);
            return new Ha(this.top_,this.top_ + a,this.left_,this.left_ + this.WIDTH_)
        }
        ;
        Na.ZoomControls.prototype.position = function(a, b) {
            if (this.initialized_) {
                var c = (0,
                Sa.getCornerOppositeToolbox)(this.workspace_, a)
                  , d = this.SMALL_SPACING_ + 2 * this.HEIGHT_;
                this.zoomResetGroup_ && (d += this.LARGE_SPACING_ + this.HEIGHT_);
                a = (0,
                Sa.getStartPositionRect)(c, new Pa(this.WIDTH_,d), this.MARGIN_HORIZONTAL_, this.MARGIN_VERTICAL_, a, this.workspace_);
                c = c.vertical;
                b = (0,
                Sa.bumpPositionRect)(a, this.MARGIN_VERTICAL_, c === Sa.verticalPosition.TOP ? Sa.bumpDirection.DOWN : Sa.bumpDirection.UP, b);
                c === Sa.verticalPosition.TOP ? (c = this.SMALL_SPACING_ + this.HEIGHT_,
                this.zoomInGroup_.setAttribute("transform", "translate(0, " + c + ")"),
                this.zoomResetGroup_ && this.zoomResetGroup_.setAttribute("transform", "translate(0, " + (c + this.LARGE_SPACING_ + this.HEIGHT_) + ")")) : (c = this.zoomResetGroup_ ? this.LARGE_SPACING_ + this.HEIGHT_ : 0,
                this.zoomInGroup_.setAttribute("transform", "translate(0, " + c + ")"),
                this.zoomOutGroup_.setAttribute("transform", "translate(0, " + (c + this.SMALL_SPACING_ + this.HEIGHT_) + ")"));
                this.top_ = b.top;
                this.left_ = b.left;
                this.svgGroup_.setAttribute("transform", "translate(" + this.left_ + "," + this.top_ + ")")
            }
        }
        ;
        Na.ZoomControls.prototype.createZoomOutSvg_ = function(a) {
            this.zoomOutGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyZoom"
            }, this.svgGroup_);
            var b = (0,
            n.createSvgElement)(u.CLIPPATH, {
                id: "blocklyZoomoutClipPath" + a
            }, this.zoomOutGroup_);
            (0,
            n.createSvgElement)(u.RECT, {
                width: 32,
                height: 32
            }, b);
            (0,
            n.createSvgElement)(u.IMAGE, {
                width: e.module$exports$Blockly$internalConstants.SPRITE.width,
                height: e.module$exports$Blockly$internalConstants.SPRITE.height,
                x: -64,
                y: -92,
                "clip-path": "url(#blocklyZoomoutClipPath" + a + ")"
            }, this.zoomOutGroup_).setAttributeNS(n.XLINK_NS, "xlink:href", this.workspace_.options.pathToMedia + e.module$exports$Blockly$internalConstants.SPRITE.url);
            this.onZoomOutWrapper_ = (0,
            y.conditionalBind)(this.zoomOutGroup_, "mousedown", null, this.zoom_.bind(this, -1))
        }
        ;
        Na.ZoomControls.prototype.createZoomInSvg_ = function(a) {
            this.zoomInGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyZoom"
            }, this.svgGroup_);
            var b = (0,
            n.createSvgElement)(u.CLIPPATH, {
                id: "blocklyZoominClipPath" + a
            }, this.zoomInGroup_);
            (0,
            n.createSvgElement)(u.RECT, {
                width: 32,
                height: 32
            }, b);
            (0,
            n.createSvgElement)(u.IMAGE, {
                width: e.module$exports$Blockly$internalConstants.SPRITE.width,
                height: e.module$exports$Blockly$internalConstants.SPRITE.height,
                x: -32,
                y: -92,
                "clip-path": "url(#blocklyZoominClipPath" + a + ")"
            }, this.zoomInGroup_).setAttributeNS(n.XLINK_NS, "xlink:href", this.workspace_.options.pathToMedia + e.module$exports$Blockly$internalConstants.SPRITE.url);
            this.onZoomInWrapper_ = (0,
            y.conditionalBind)(this.zoomInGroup_, "mousedown", null, this.zoom_.bind(this, 1))
        }
        ;
        Na.ZoomControls.prototype.zoom_ = function(a, b) {
            this.workspace_.markFocused();
            this.workspace_.zoomCenter(a);
            this.fireZoomEvent_();
            (0,
            O.clearTouchIdentifier)();
            b.stopPropagation();
            b.preventDefault()
        }
        ;
        Na.ZoomControls.prototype.createZoomResetSvg_ = function(a) {
            this.zoomResetGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyZoom"
            }, this.svgGroup_);
            var b = (0,
            n.createSvgElement)(u.CLIPPATH, {
                id: "blocklyZoomresetClipPath" + a
            }, this.zoomResetGroup_);
            (0,
            n.createSvgElement)(u.RECT, {
                width: 32,
                height: 32
            }, b);
            (0,
            n.createSvgElement)(u.IMAGE, {
                width: e.module$exports$Blockly$internalConstants.SPRITE.width,
                height: e.module$exports$Blockly$internalConstants.SPRITE.height,
                y: -92,
                "clip-path": "url(#blocklyZoomresetClipPath" + a + ")"
            }, this.zoomResetGroup_).setAttributeNS(n.XLINK_NS, "xlink:href", this.workspace_.options.pathToMedia + e.module$exports$Blockly$internalConstants.SPRITE.url);
            this.onZoomResetWrapper_ = (0,
            y.conditionalBind)(this.zoomResetGroup_, "mousedown", null, this.resetZoom_.bind(this))
        }
        ;
        Na.ZoomControls.prototype.resetZoom_ = function(a) {
            this.workspace_.markFocused();
            var b = Math.log(this.workspace_.options.zoomOptions.startScale / this.workspace_.scale) / Math.log(this.workspace_.options.zoomOptions.scaleSpeed);
            this.workspace_.beginCanvasTransition();
            this.workspace_.zoomCenter(b);
            this.workspace_.scrollCenter();
            setTimeout(this.workspace_.endCanvasTransition.bind(this.workspace_), 500);
            this.fireZoomEvent_();
            (0,
            O.clearTouchIdentifier)();
            a.stopPropagation();
            a.preventDefault()
        }
        ;
        Na.ZoomControls.prototype.fireZoomEvent_ = function() {
            var a = new ((0,
            k.get)(k.CLICK))(null,this.workspace_.id,"zoom_controls");
            (0,
            k.fire)(a)
        }
        ;
        (0,
        v.register)("\n  .blocklyZoom>image, .blocklyZoom>svg>image {\n    opacity: .4;\n  }\n\n  .blocklyZoom>image:hover, .blocklyZoom>svg>image:hover {\n    opacity: .6;\n  }\n\n  .blocklyZoom>image:active, .blocklyZoom>svg>image:active {\n    opacity: .8;\n  }\n");
        var ua = {
            WorkspaceComment: function(a, b, c, d, f) {
                this.id = f && !a.getCommentById(f) ? f : (0,
                bb.genUid)();
                a.addTopComment(this);
                this.xy_ = new J(0,0);
                this.height_ = c;
                this.width_ = d;
                this.workspace = a;
                this.RTL = a.RTL;
                this.editable_ = this.movable_ = this.deletable_ = !0;
                this.content_ = b;
                this.disposed_ = !1;
                this.isComment = !0;
                ua.WorkspaceComment.fireCreateEvent(this)
            }
        };
        ua.WorkspaceComment.prototype.dispose = function() {
            this.disposed_ || ((0,
            k.isEnabled)() && (0,
            k.fire)(new ((0,
            k.get)(k.COMMENT_DELETE))(this)),
            this.workspace.removeTopComment(this),
            this.disposed_ = !0)
        }
        ;
        ua.WorkspaceComment.prototype.getHeight = function() {
            return this.height_
        }
        ;
        ua.WorkspaceComment.prototype.setHeight = function(a) {
            this.height_ = a
        }
        ;
        ua.WorkspaceComment.prototype.getWidth = function() {
            return this.width_
        }
        ;
        ua.WorkspaceComment.prototype.setWidth = function(a) {
            this.width_ = a
        }
        ;
        ua.WorkspaceComment.prototype.getXY = function() {
            return new J(this.xy_.x,this.xy_.y)
        }
        ;
        ua.WorkspaceComment.prototype.moveBy = function(a, b) {
            var c = new ((0,
            k.get)(k.COMMENT_MOVE))(this);
            this.xy_.translate(a, b);
            c.recordNew();
            (0,
            k.fire)(c)
        }
        ;
        ua.WorkspaceComment.prototype.isDeletable = function() {
            return this.deletable_ && !(this.workspace && this.workspace.options.readOnly)
        }
        ;
        ua.WorkspaceComment.prototype.setDeletable = function(a) {
            this.deletable_ = a
        }
        ;
        ua.WorkspaceComment.prototype.isMovable = function() {
            return this.movable_ && !(this.workspace && this.workspace.options.readOnly)
        }
        ;
        ua.WorkspaceComment.prototype.setMovable = function(a) {
            this.movable_ = a
        }
        ;
        ua.WorkspaceComment.prototype.isEditable = function() {
            return this.editable_ && !(this.workspace && this.workspace.options.readOnly)
        }
        ;
        ua.WorkspaceComment.prototype.setEditable = function(a) {
            this.editable_ = a
        }
        ;
        ua.WorkspaceComment.prototype.getContent = function() {
            return this.content_
        }
        ;
        ua.WorkspaceComment.prototype.setContent = function(a) {
            this.content_ !== a && ((0,
            k.fire)(new ((0,
            k.get)(k.COMMENT_CHANGE))(this,this.content_,a)),
            this.content_ = a)
        }
        ;
        ua.WorkspaceComment.prototype.toXmlWithXY = function(a) {
            a = this.toXml(a);
            a.setAttribute("x", Math.round(this.xy_.x));
            a.setAttribute("y", Math.round(this.xy_.y));
            a.setAttribute("h", this.height_);
            a.setAttribute("w", this.width_);
            return a
        }
        ;
        ua.WorkspaceComment.prototype.toXml = function(a) {
            var b = (0,
            e.module$exports$Blockly$utils$xml.createElement)("comment");
            a || (b.id = this.id);
            b.textContent = this.getContent();
            return b
        }
        ;
        ua.WorkspaceComment.fireCreateEvent = function(a) {
            if ((0,
            k.isEnabled)()) {
                var b = (0,
                k.getGroup)();
                b || (0,
                k.setGroup)(!0);
                try {
                    (0,
                    k.fire)(new ((0,
                    k.get)(k.COMMENT_CREATE))(a))
                } finally {
                    b || (0,
                    k.setGroup)(!1)
                }
            }
        }
        ;
        ua.WorkspaceComment.fromXml = function(a, b) {
            var c = ua.WorkspaceComment.parseAttributes(a);
            b = new ua.WorkspaceComment(b,c.content,c.h,c.w,c.id);
            c = parseInt(a.getAttribute("x"), 10);
            a = parseInt(a.getAttribute("y"), 10);
            isNaN(c) || isNaN(a) || b.moveBy(c, a);
            ua.WorkspaceComment.fireCreateEvent(b);
            return b
        }
        ;
        ua.WorkspaceComment.parseAttributes = function(a) {
            var b = a.getAttribute("h")
              , c = a.getAttribute("w");
            return {
                id: a.getAttribute("id"),
                h: b ? parseInt(b, 10) : 100,
                w: c ? parseInt(c, 10) : 100,
                x: parseInt(a.getAttribute("x"), 10),
                y: parseInt(a.getAttribute("y"), 10),
                content: a.textContent
            }
        }
        ;
        var S = {
            WorkspaceCommentSvg: function(a, b, c, d, f) {
                this.onMouseMoveWrapper_ = this.onMouseUpWrapper_ = null;
                this.svgGroup_ = (0,
                n.createSvgElement)(u.G, {
                    "class": "blocklyComment"
                }, null);
                this.svgGroup_.translate_ = "";
                this.svgRect_ = (0,
                n.createSvgElement)(u.RECT, {
                    "class": "blocklyCommentRect",
                    x: 0,
                    y: 0,
                    rx: 3,
                    ry: 3
                });
                this.svgGroup_.appendChild(this.svgRect_);
                this.rendered_ = !1;
                this.useDragSurface_ = (0,
                ja.is3dSupported)() && !!a.getBlockDragSurface();
                S.WorkspaceCommentSvg.superClass_.constructor.call(this, a, b, c, d, f);
                this.render()
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(S.WorkspaceCommentSvg, ua.WorkspaceComment);
        S.WorkspaceCommentSvg.DEFAULT_SIZE = 100;
        S.WorkspaceCommentSvg.TOP_OFFSET = 10;
        S.WorkspaceCommentSvg.prototype.dispose = function() {
            this.disposed_ || ((0,
            e.module$exports$Blockly$common.getSelected)() === this && (this.unselect(),
            this.workspace.cancelCurrentGesture()),
            (0,
            k.isEnabled)() && (0,
            k.fire)(new ((0,
            k.get)(k.COMMENT_DELETE))(this)),
            (0,
            n.removeNode)(this.svgGroup_),
            this.disposeInternal_(),
            (0,
            k.disable)(),
            S.WorkspaceCommentSvg.superClass_.dispose.call(this),
            (0,
            k.enable)())
        }
        ;
        S.WorkspaceCommentSvg.prototype.initSvg = function(a) {
            if (!this.workspace.rendered)
                throw TypeError("Workspace is headless.");
            this.workspace.options.readOnly || this.eventsInit_ || ((0,
            y.conditionalBind)(this.svgRectTarget_, "mousedown", this, this.pathMouseDown_),
            (0,
            y.conditionalBind)(this.svgHandleTarget_, "mousedown", this, this.pathMouseDown_));
            this.eventsInit_ = !0;
            this.updateMovable();
            this.getSvgRoot().parentNode || this.workspace.getBubbleCanvas().appendChild(this.getSvgRoot());
            !a && this.textarea_ && this.textarea_.select()
        }
        ;
        S.WorkspaceCommentSvg.prototype.pathMouseDown_ = function(a) {
            var b = this.workspace.getGesture(a);
            b && b.handleBubbleStart(a, this)
        }
        ;
        S.WorkspaceCommentSvg.prototype.showContextMenu = function(a) {
            if (!this.workspace.options.readOnly) {
                var b = [];
                this.isDeletable() && this.isMovable() && (b.push((0,
                e.module$exports$Blockly$ContextMenu.commentDuplicateOption)(this)),
                b.push((0,
                e.module$exports$Blockly$ContextMenu.commentDeleteOption)(this)));
                (0,
                e.module$exports$Blockly$ContextMenu.show)(a, b, this.RTL)
            }
        }
        ;
        S.WorkspaceCommentSvg.prototype.select = function() {
            if ((0,
            e.module$exports$Blockly$common.getSelected)() !== this) {
                var a = null;
                if ((0,
                e.module$exports$Blockly$common.getSelected)()) {
                    a = (0,
                    e.module$exports$Blockly$common.getSelected)().id;
                    (0,
                    k.disable)();
                    try {
                        (0,
                        e.module$exports$Blockly$common.getSelected)().unselect()
                    } finally {
                        (0,
                        k.enable)()
                    }
                }
                a = new ((0,
                k.get)(k.SELECTED))(a,this.id,this.workspace.id);
                (0,
                k.fire)(a);
                (0,
                e.module$exports$Blockly$common.setSelected)(this);
                this.addSelect()
            }
        }
        ;
        S.WorkspaceCommentSvg.prototype.unselect = function() {
            if ((0,
            e.module$exports$Blockly$common.getSelected)() === this) {
                var a = new ((0,
                k.get)(k.SELECTED))(this.id,null,this.workspace.id);
                (0,
                k.fire)(a);
                (0,
                e.module$exports$Blockly$common.setSelected)(null);
                this.removeSelect();
                this.blurFocus()
            }
        }
        ;
        S.WorkspaceCommentSvg.prototype.addSelect = function() {
            (0,
            n.addClass)(this.svgGroup_, "blocklySelected");
            this.setFocus()
        }
        ;
        S.WorkspaceCommentSvg.prototype.removeSelect = function() {
            (0,
            n.removeClass)(this.svgGroup_, "blocklySelected");
            this.blurFocus()
        }
        ;
        S.WorkspaceCommentSvg.prototype.addFocus = function() {
            (0,
            n.addClass)(this.svgGroup_, "blocklyFocused")
        }
        ;
        S.WorkspaceCommentSvg.prototype.removeFocus = function() {
            (0,
            n.removeClass)(this.svgGroup_, "blocklyFocused")
        }
        ;
        S.WorkspaceCommentSvg.prototype.getRelativeToSurfaceXY = function() {
            var a = 0
              , b = 0
              , c = this.useDragSurface_ ? this.workspace.getBlockDragSurface().getGroup() : null
              , d = this.getSvgRoot();
            if (d) {
                do {
                    var f = (0,
                    ja.getRelativeXY)(d);
                    a += f.x;
                    b += f.y;
                    this.useDragSurface_ && this.workspace.getBlockDragSurface().getCurrentBlock() === d && (f = this.workspace.getBlockDragSurface().getSurfaceTranslation(),
                    a += f.x,
                    b += f.y);
                    d = d.parentNode
                } while (d && d !== this.workspace.getBubbleCanvas() && d !== c)
            }
            return this.xy_ = new J(a,b)
        }
        ;
        S.WorkspaceCommentSvg.prototype.moveBy = function(a, b) {
            var c = new ((0,
            k.get)(k.COMMENT_MOVE))(this)
              , d = this.getRelativeToSurfaceXY();
            this.translate(d.x + a, d.y + b);
            this.xy_ = new J(d.x + a,d.y + b);
            c.recordNew();
            (0,
            k.fire)(c);
            this.workspace.resizeContents()
        }
        ;
        S.WorkspaceCommentSvg.prototype.translate = function(a, b) {
            this.xy_ = new J(a,b);
            this.getSvgRoot().setAttribute("transform", "translate(" + a + "," + b + ")")
        }
        ;
        S.WorkspaceCommentSvg.prototype.moveToDragSurface = function() {
            if (this.useDragSurface_) {
                var a = this.getRelativeToSurfaceXY();
                this.clearTransformAttributes_();
                this.workspace.getBlockDragSurface().translateSurface(a.x, a.y);
                this.workspace.getBlockDragSurface().setBlocksAndShow(this.getSvgRoot())
            }
        }
        ;
        S.WorkspaceCommentSvg.prototype.moveDuringDrag = function(a, b) {
            a ? a.translateSurface(b.x, b.y) : (this.svgGroup_.translate_ = "translate(" + b.x + "," + b.y + ")",
            this.svgGroup_.setAttribute("transform", this.svgGroup_.translate_ + this.svgGroup_.skew_))
        }
        ;
        S.WorkspaceCommentSvg.prototype.moveTo = function(a, b) {
            this.translate(a, b)
        }
        ;
        S.WorkspaceCommentSvg.prototype.clearTransformAttributes_ = function() {
            this.getSvgRoot().removeAttribute("transform")
        }
        ;
        S.WorkspaceCommentSvg.prototype.getBoundingRectangle = function() {
            var a = this.getRelativeToSurfaceXY()
              , b = this.getHeightWidth()
              , c = a.y
              , d = a.y + b.height;
            if (this.RTL) {
                var f = a.x - b.width;
                a = a.x
            } else
                f = a.x,
                a = a.x + b.width;
            return new Ha(c,d,f,a)
        }
        ;
        S.WorkspaceCommentSvg.prototype.updateMovable = function() {
            this.isMovable() ? (0,
            n.addClass)(this.svgGroup_, "blocklyDraggable") : (0,
            n.removeClass)(this.svgGroup_, "blocklyDraggable")
        }
        ;
        S.WorkspaceCommentSvg.prototype.setMovable = function(a) {
            S.WorkspaceCommentSvg.superClass_.setMovable.call(this, a);
            this.updateMovable()
        }
        ;
        S.WorkspaceCommentSvg.prototype.setEditable = function(a) {
            S.WorkspaceCommentSvg.superClass_.setEditable.call(this, a);
            this.textarea_ && (this.textarea_.readOnly = !a)
        }
        ;
        S.WorkspaceCommentSvg.prototype.setDragging = function(a) {
            a ? (a = this.getSvgRoot(),
            a.translate_ = "",
            a.skew_ = "",
            (0,
            n.addClass)(this.svgGroup_, "blocklyDragging")) : (0,
            n.removeClass)(this.svgGroup_, "blocklyDragging")
        }
        ;
        S.WorkspaceCommentSvg.prototype.getSvgRoot = function() {
            return this.svgGroup_
        }
        ;
        S.WorkspaceCommentSvg.prototype.getContent = function() {
            return this.textarea_ ? this.textarea_.value : this.content_
        }
        ;
        S.WorkspaceCommentSvg.prototype.setContent = function(a) {
            S.WorkspaceCommentSvg.superClass_.setContent.call(this, a);
            this.textarea_ && (this.textarea_.value = a)
        }
        ;
        S.WorkspaceCommentSvg.prototype.setDeleteStyle = function(a) {
            a ? (0,
            n.addClass)(this.svgGroup_, "blocklyDraggingDelete") : (0,
            n.removeClass)(this.svgGroup_, "blocklyDraggingDelete")
        }
        ;
        S.WorkspaceCommentSvg.prototype.setAutoLayout = function(a) {}
        ;
        S.WorkspaceCommentSvg.fromXml = function(a, b, c) {
            (0,
            k.disable)();
            try {
                var d = ua.WorkspaceComment.parseAttributes(a)
                  , f = new S.WorkspaceCommentSvg(b,d.content,d.h,d.w,d.id);
                b.rendered && (f.initSvg(!0),
                f.render());
                if (!isNaN(d.x) && !isNaN(d.y))
                    if (b.RTL) {
                        var g = c || b.getWidth();
                        f.moveBy(g - d.x, d.y)
                    } else
                        f.moveBy(d.x, d.y)
            } finally {
                (0,
                k.enable)()
            }
            ua.WorkspaceComment.fireCreateEvent(f);
            return f
        }
        ;
        S.WorkspaceCommentSvg.prototype.toXmlWithXY = function(a) {
            var b;
            this.workspace.RTL && (b = this.workspace.getWidth());
            a = this.toXml(a);
            var c = this.getRelativeToSurfaceXY();
            a.setAttribute("x", Math.round(this.workspace.RTL ? b - c.x : c.x));
            a.setAttribute("y", Math.round(c.y));
            a.setAttribute("h", this.getHeight());
            a.setAttribute("w", this.getWidth());
            return a
        }
        ;
        S.WorkspaceCommentSvg.prototype.toCopyData = function() {
            return {
                saveInfo: this.toXmlWithXY(),
                source: this.workspace,
                typeCounts: null
            }
        }
        ;
        S.WorkspaceCommentSvg.prototype.getHeightWidth = function() {
            return {
                width: this.getWidth(),
                height: this.getHeight()
            }
        }
        ;
        S.WorkspaceCommentSvg.prototype.render = function() {
            if (!this.rendered_) {
                var a = this.getHeightWidth();
                this.createEditor_();
                this.svgGroup_.appendChild(this.foreignObject_);
                this.svgHandleTarget_ = (0,
                n.createSvgElement)(u.RECT, {
                    "class": "blocklyCommentHandleTarget",
                    x: 0,
                    y: 0
                });
                this.svgGroup_.appendChild(this.svgHandleTarget_);
                this.svgRectTarget_ = (0,
                n.createSvgElement)(u.RECT, {
                    "class": "blocklyCommentTarget",
                    x: 0,
                    y: 0,
                    rx: 3,
                    ry: 3
                });
                this.svgGroup_.appendChild(this.svgRectTarget_);
                this.addResizeDom_();
                this.isDeletable() && this.addDeleteDom_();
                this.setSize_(a.width, a.height);
                this.textarea_.value = this.content_;
                this.rendered_ = !0;
                this.resizeGroup_ && (0,
                y.conditionalBind)(this.resizeGroup_, "mousedown", this, this.resizeMouseDown_);
                this.isDeletable() && ((0,
                y.conditionalBind)(this.deleteGroup_, "mousedown", this, this.deleteMouseDown_),
                (0,
                y.conditionalBind)(this.deleteGroup_, "mouseout", this, this.deleteMouseOut_),
                (0,
                y.conditionalBind)(this.deleteGroup_, "mouseup", this, this.deleteMouseUp_))
            }
        }
        ;
        S.WorkspaceCommentSvg.prototype.createEditor_ = function() {
            this.foreignObject_ = (0,
            n.createSvgElement)(u.FOREIGNOBJECT, {
                x: 0,
                y: S.WorkspaceCommentSvg.TOP_OFFSET,
                "class": "blocklyCommentForeignObject"
            }, null);
            var a = document.createElementNS(n.HTML_NS, "body");
            a.setAttribute("xmlns", n.HTML_NS);
            a.className = "blocklyMinimalBody";
            var b = document.createElementNS(n.HTML_NS, "textarea");
            b.className = "blocklyCommentTextarea";
            b.setAttribute("dir", this.RTL ? "RTL" : "LTR");
            b.readOnly = !this.isEditable();
            a.appendChild(b);
            this.textarea_ = b;
            this.foreignObject_.appendChild(a);
            (0,
            y.conditionalBind)(b, "wheel", this, function(c) {
                c.stopPropagation()
            });
            (0,
            y.conditionalBind)(b, "change", this, function(c) {
                this.setContent(b.value)
            });
            return this.foreignObject_
        }
        ;
        S.WorkspaceCommentSvg.prototype.addResizeDom_ = function() {
            this.resizeGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": this.RTL ? "blocklyResizeSW" : "blocklyResizeSE"
            }, this.svgGroup_);
            (0,
            n.createSvgElement)(u.POLYGON, {
                points: "0,x x,x x,0".replace(/x/g, (8).toString())
            }, this.resizeGroup_);
            (0,
            n.createSvgElement)(u.LINE, {
                "class": "blocklyResizeLine",
                x1: 8 / 3,
                y1: 7,
                x2: 7,
                y2: 8 / 3
            }, this.resizeGroup_);
            (0,
            n.createSvgElement)(u.LINE, {
                "class": "blocklyResizeLine",
                x1: 16 / 3,
                y1: 7,
                x2: 7,
                y2: 16 / 3
            }, this.resizeGroup_)
        }
        ;
        S.WorkspaceCommentSvg.prototype.addDeleteDom_ = function() {
            this.deleteGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyCommentDeleteIcon"
            }, this.svgGroup_);
            this.deleteIconBorder_ = (0,
            n.createSvgElement)(u.CIRCLE, {
                "class": "blocklyDeleteIconShape",
                r: "7",
                cx: "7.5",
                cy: "7.5"
            }, this.deleteGroup_);
            (0,
            n.createSvgElement)(u.LINE, {
                x1: "5",
                y1: "10",
                x2: "10",
                y2: "5",
                stroke: "#fff",
                "stroke-width": "2"
            }, this.deleteGroup_);
            (0,
            n.createSvgElement)(u.LINE, {
                x1: "5",
                y1: "5",
                x2: "10",
                y2: "10",
                stroke: "#fff",
                "stroke-width": "2"
            }, this.deleteGroup_)
        }
        ;
        S.WorkspaceCommentSvg.prototype.resizeMouseDown_ = function(a) {
            this.unbindDragEvents_();
            (0,
            y.isRightButton)(a) || (this.workspace.startDrag(a, new J(this.workspace.RTL ? -this.width_ : this.width_,this.height_)),
            this.onMouseUpWrapper_ = (0,
            y.conditionalBind)(document, "mouseup", this, this.resizeMouseUp_),
            this.onMouseMoveWrapper_ = (0,
            y.conditionalBind)(document, "mousemove", this, this.resizeMouseMove_),
            this.workspace.hideChaff());
            a.stopPropagation()
        }
        ;
        S.WorkspaceCommentSvg.prototype.deleteMouseDown_ = function(a) {
            (0,
            n.addClass)(this.deleteIconBorder_, "blocklyDeleteIconHighlighted");
            a.stopPropagation()
        }
        ;
        S.WorkspaceCommentSvg.prototype.deleteMouseOut_ = function(a) {
            (0,
            n.removeClass)(this.deleteIconBorder_, "blocklyDeleteIconHighlighted")
        }
        ;
        S.WorkspaceCommentSvg.prototype.deleteMouseUp_ = function(a) {
            this.dispose();
            a.stopPropagation()
        }
        ;
        S.WorkspaceCommentSvg.prototype.unbindDragEvents_ = function() {
            this.onMouseUpWrapper_ && ((0,
            y.unbind)(this.onMouseUpWrapper_),
            this.onMouseUpWrapper_ = null);
            this.onMouseMoveWrapper_ && ((0,
            y.unbind)(this.onMouseMoveWrapper_),
            this.onMouseMoveWrapper_ = null)
        }
        ;
        S.WorkspaceCommentSvg.prototype.resizeMouseUp_ = function(a) {
            (0,
            O.clearTouchIdentifier)();
            this.unbindDragEvents_()
        }
        ;
        S.WorkspaceCommentSvg.prototype.resizeMouseMove_ = function(a) {
            this.autoLayout_ = !1;
            a = this.workspace.moveDrag(a);
            this.setSize_(this.RTL ? -a.x : a.x, a.y)
        }
        ;
        S.WorkspaceCommentSvg.prototype.resizeComment_ = function() {
            var a = this.getHeightWidth()
              , b = S.WorkspaceCommentSvg.TOP_OFFSET;
            this.foreignObject_.setAttribute("width", a.width);
            this.foreignObject_.setAttribute("height", a.height - b);
            this.RTL && this.foreignObject_.setAttribute("x", -a.width);
            this.textarea_.style.width = a.width - 4 + "px";
            this.textarea_.style.height = a.height - 4 - b + "px"
        }
        ;
        S.WorkspaceCommentSvg.prototype.setSize_ = function(a, b) {
            a = Math.max(a, 45);
            b = Math.max(b, 20 + S.WorkspaceCommentSvg.TOP_OFFSET);
            this.width_ = a;
            this.height_ = b;
            this.svgRect_.setAttribute("width", a);
            this.svgRect_.setAttribute("height", b);
            this.svgRectTarget_.setAttribute("width", a);
            this.svgRectTarget_.setAttribute("height", b);
            this.svgHandleTarget_.setAttribute("width", a);
            this.svgHandleTarget_.setAttribute("height", S.WorkspaceCommentSvg.TOP_OFFSET);
            this.RTL && (this.svgRect_.setAttribute("transform", "scale(-1 1)"),
            this.svgRectTarget_.setAttribute("transform", "scale(-1 1)"));
            this.resizeGroup_ && (this.RTL ? (this.resizeGroup_.setAttribute("transform", "translate(" + (-a + 8) + "," + (b - 8) + ") scale(-1 1)"),
            this.deleteGroup_.setAttribute("transform", "translate(" + (-a + 8) + ",-8) scale(-1 1)")) : (this.resizeGroup_.setAttribute("transform", "translate(" + (a - 8) + "," + (b - 8) + ")"),
            this.deleteGroup_.setAttribute("transform", "translate(" + (a - 8) + ",-8)")));
            this.resizeComment_()
        }
        ;
        S.WorkspaceCommentSvg.prototype.disposeInternal_ = function() {
            this.svgHandleTarget_ = this.svgRectTarget_ = this.foreignObject_ = this.textarea_ = null;
            this.disposed_ = !0
        }
        ;
        S.WorkspaceCommentSvg.prototype.setFocus = function() {
            var a = this;
            this.focused_ = !0;
            setTimeout(function() {
                a.disposed_ || (a.textarea_.focus(),
                a.addFocus(),
                (0,
                n.addClass)(a.svgRectTarget_, "blocklyCommentTargetFocused"),
                (0,
                n.addClass)(a.svgHandleTarget_, "blocklyCommentHandleTargetFocused"))
            }, 0)
        }
        ;
        S.WorkspaceCommentSvg.prototype.blurFocus = function() {
            var a = this;
            this.focused_ = !1;
            setTimeout(function() {
                a.disposed_ || (a.textarea_.blur(),
                a.removeFocus(),
                (0,
                n.removeClass)(a.svgRectTarget_, "blocklyCommentTargetFocused"),
                (0,
                n.removeClass)(a.svgHandleTarget_, "blocklyCommentHandleTargetFocused"))
            }, 0)
        }
        ;
        (0,
        v.register)("\n  .blocklyCommentForeignObject {\n    position: relative;\n    z-index: 0;\n  }\n\n  .blocklyCommentRect {\n    fill: #E7DE8E;\n    stroke: #bcA903;\n    stroke-width: 1px;\n  }\n\n  .blocklyCommentTarget {\n    fill: transparent;\n    stroke: #bcA903;\n  }\n\n  .blocklyCommentTargetFocused {\n    fill: none;\n  }\n\n  .blocklyCommentHandleTarget {\n    fill: none;\n  }\n\n  .blocklyCommentHandleTargetFocused {\n    fill: transparent;\n  }\n\n  .blocklyFocused>.blocklyCommentRect {\n    fill: #B9B272;\n    stroke: #B9B272;\n  }\n\n  .blocklySelected>.blocklyCommentTarget {\n    stroke: #fc3;\n    stroke-width: 3px;\n  }\n\n  .blocklyCommentDeleteIcon {\n    cursor: pointer;\n    fill: #000;\n    display: none;\n  }\n\n  .blocklySelected > .blocklyCommentDeleteIcon {\n    display: block;\n  }\n\n  .blocklyDeleteIconShape {\n    fill: #000;\n    stroke: #000;\n    stroke-width: 1px;\n  }\n\n  .blocklyDeleteIconShape.blocklyDeleteIconHighlighted {\n    stroke: #fc3;\n  }\n");
        var ha = {
            Trashcan: function(a) {
                ha.Trashcan.superClass_.constructor.call(this);
                this.workspace_ = a;
                this.id = "trashcan";
                this.contents_ = [];
                this.flyout = null;
                0 >= this.workspace_.options.maxTrashcanContents || (a = new nb.Options({
                    scrollbars: !0,
                    parentWorkspace: this.workspace_,
                    rtl: this.workspace_.RTL,
                    oneBasedIndex: this.workspace_.options.oneBasedIndex,
                    renderer: this.workspace_.options.renderer,
                    rendererOverrides: this.workspace_.options.rendererOverrides,
                    move: {
                        scrollbars: !0
                    }
                }),
                this.workspace_.horizontalLayout ? (a.toolboxPosition = this.workspace_.toolboxPosition === X.Position.TOP ? X.Position.BOTTOM : X.Position.TOP,
                this.flyout = new ((0,
                w.getClassFromOptions)(w.Type.FLYOUTS_HORIZONTAL_TOOLBOX, this.workspace_.options, !0))(a)) : (a.toolboxPosition = this.workspace_.toolboxPosition === X.Position.RIGHT ? X.Position.LEFT : X.Position.RIGHT,
                this.flyout = new ((0,
                w.getClassFromOptions)(w.Type.FLYOUTS_VERTICAL_TOOLBOX, this.workspace_.options, !0))(a)),
                this.workspace_.addChangeListener(this.onDelete_.bind(this)))
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(ha.Trashcan, Ec.DeleteArea);
        ha.Trashcan.prototype.isLidOpen = !1;
        ha.Trashcan.prototype.minOpenness_ = 0;
        ha.Trashcan.prototype.svgGroup_ = null;
        ha.Trashcan.prototype.svgLid_ = null;
        ha.Trashcan.prototype.lidTask_ = 0;
        ha.Trashcan.prototype.lidOpen_ = 0;
        ha.Trashcan.prototype.left_ = 0;
        ha.Trashcan.prototype.top_ = 0;
        ha.Trashcan.prototype.initialized_ = !1;
        ha.Trashcan.prototype.createDom = function() {
            this.svgGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": "blocklyTrash"
            }, null);
            var a = String(Math.random()).substring(2)
              , b = (0,
            n.createSvgElement)(u.CLIPPATH, {
                id: "blocklyTrashBodyClipPath" + a
            }, this.svgGroup_);
            (0,
            n.createSvgElement)(u.RECT, {
                width: 47,
                height: 44,
                y: 16
            }, b);
            var c = (0,
            n.createSvgElement)(u.IMAGE, {
                width: e.module$exports$Blockly$internalConstants.SPRITE.width,
                x: -0,
                height: e.module$exports$Blockly$internalConstants.SPRITE.height,
                y: -32,
                "clip-path": "url(#blocklyTrashBodyClipPath" + a + ")"
            }, this.svgGroup_);
            c.setAttributeNS(n.XLINK_NS, "xlink:href", this.workspace_.options.pathToMedia + e.module$exports$Blockly$internalConstants.SPRITE.url);
            b = (0,
            n.createSvgElement)(u.CLIPPATH, {
                id: "blocklyTrashLidClipPath" + a
            }, this.svgGroup_);
            (0,
            n.createSvgElement)(u.RECT, {
                width: 47,
                height: 16
            }, b);
            this.svgLid_ = (0,
            n.createSvgElement)(u.IMAGE, {
                width: e.module$exports$Blockly$internalConstants.SPRITE.width,
                x: -0,
                height: e.module$exports$Blockly$internalConstants.SPRITE.height,
                y: -32,
                "clip-path": "url(#blocklyTrashLidClipPath" + a + ")"
            }, this.svgGroup_);
            this.svgLid_.setAttributeNS(n.XLINK_NS, "xlink:href", this.workspace_.options.pathToMedia + e.module$exports$Blockly$internalConstants.SPRITE.url);
            (0,
            y.bind)(this.svgGroup_, "mousedown", this, this.blockMouseDownWhenOpenable_);
            (0,
            y.bind)(this.svgGroup_, "mouseup", this, this.click);
            (0,
            y.bind)(c, "mouseover", this, this.mouseOver_);
            (0,
            y.bind)(c, "mouseout", this, this.mouseOut_);
            this.animateLid_();
            return this.svgGroup_
        }
        ;
        ha.Trashcan.prototype.init = function() {
            0 < this.workspace_.options.maxTrashcanContents && ((0,
            n.insertAfter)(this.flyout.createDom(u.SVG), this.workspace_.getParentSvg()),
            this.flyout.init(this.workspace_));
            this.workspace_.getComponentManager().addComponent({
                component: this,
                weight: 1,
                capabilities: [oa.Capability.AUTOHIDEABLE, oa.Capability.DELETE_AREA, oa.Capability.DRAG_TARGET, oa.Capability.POSITIONABLE]
            });
            this.initialized_ = !0;
            this.setLidOpen(!1)
        }
        ;
        ha.Trashcan.prototype.dispose = function() {
            this.workspace_.getComponentManager().removeComponent("trashcan");
            this.svgGroup_ && ((0,
            n.removeNode)(this.svgGroup_),
            this.svgGroup_ = null);
            this.workspace_ = this.svgLid_ = null;
            clearTimeout(this.lidTask_)
        }
        ;
        ha.Trashcan.prototype.hasContents_ = function() {
            return !!this.contents_.length
        }
        ;
        ha.Trashcan.prototype.contentsIsOpen = function() {
            return !!this.flyout && this.flyout.isVisible()
        }
        ;
        ha.Trashcan.prototype.openFlyout = function() {
            if (!this.contentsIsOpen()) {
                var a = this.contents_.map(function(b) {
                    return JSON.parse(b)
                });
                this.flyout.show(a);
                this.fireUiEvent_(!0)
            }
        }
        ;
        ha.Trashcan.prototype.closeFlyout = function() {
            this.contentsIsOpen() && (this.flyout.hide(),
            this.fireUiEvent_(!1),
            this.workspace_.recordDragTargets())
        }
        ;
        ha.Trashcan.prototype.autoHide = function(a) {
            !a && this.flyout && this.closeFlyout()
        }
        ;
        ha.Trashcan.prototype.emptyContents = function() {
            this.hasContents_() && (this.contents_.length = 0,
            this.setMinOpenness_(0),
            this.closeFlyout())
        }
        ;
        ha.Trashcan.prototype.position = function(a, b) {
            if (this.initialized_) {
                var c = (0,
                Sa.getCornerOppositeToolbox)(this.workspace_, a);
                a = (0,
                Sa.getStartPositionRect)(c, new Pa(47,60), 20, 20, a, this.workspace_);
                b = (0,
                Sa.bumpPositionRect)(a, 20, c.vertical === Sa.verticalPosition.TOP ? Sa.bumpDirection.DOWN : Sa.bumpDirection.UP, b);
                this.top_ = b.top;
                this.left_ = b.left;
                this.svgGroup_.setAttribute("transform", "translate(" + this.left_ + "," + this.top_ + ")")
            }
        }
        ;
        ha.Trashcan.prototype.getBoundingRectangle = function() {
            return new Ha(this.top_,this.top_ + 44 + 16,this.left_,this.left_ + 47)
        }
        ;
        ha.Trashcan.prototype.getClientRect = function() {
            if (!this.svgGroup_)
                return null;
            var a = this.svgGroup_.getBoundingClientRect()
              , b = a.top + 32 - 10;
            a = a.left + 0 - 10;
            return new Ha(b,b + 16 + 44 + 20,a,a + 47 + 20)
        }
        ;
        ha.Trashcan.prototype.onDragOver = function(a) {
            this.setLidOpen(this.wouldDelete_)
        }
        ;
        ha.Trashcan.prototype.onDragExit = function(a) {
            this.setLidOpen(!1)
        }
        ;
        ha.Trashcan.prototype.onDrop = function(a) {
            setTimeout(this.setLidOpen.bind(this, !1), 100)
        }
        ;
        ha.Trashcan.prototype.setLidOpen = function(a) {
            this.isLidOpen !== a && (clearTimeout(this.lidTask_),
            this.isLidOpen = a,
            this.animateLid_())
        }
        ;
        ha.Trashcan.prototype.animateLid_ = function() {
            this.lidOpen_ += this.isLidOpen ? .2 : -.2;
            this.lidOpen_ = Math.min(Math.max(this.lidOpen_, this.minOpenness_), 1);
            this.setLidAngle_(45 * this.lidOpen_);
            this.svgGroup_.style.opacity = .4 + .4 * this.lidOpen_;
            this.lidOpen_ > this.minOpenness_ && 1 > this.lidOpen_ && (this.lidTask_ = setTimeout(this.animateLid_.bind(this), 20))
        }
        ;
        ha.Trashcan.prototype.setLidAngle_ = function(a) {
            var b = this.workspace_.toolboxPosition === X.Position.RIGHT || this.workspace_.horizontalLayout && this.workspace_.RTL;
            this.svgLid_.setAttribute("transform", "rotate(" + (b ? -a : a) + "," + (b ? 4 : 43) + ",14)")
        }
        ;
        ha.Trashcan.prototype.setMinOpenness_ = function(a) {
            this.minOpenness_ = a;
            this.isLidOpen || this.setLidAngle_(45 * a)
        }
        ;
        ha.Trashcan.prototype.closeLid = function() {
            this.setLidOpen(!1)
        }
        ;
        ha.Trashcan.prototype.click = function() {
            this.hasContents_() && this.openFlyout()
        }
        ;
        ha.Trashcan.prototype.fireUiEvent_ = function(a) {
            a = new ((0,
            k.get)(k.TRASHCAN_OPEN))(a,this.workspace_.id);
            (0,
            k.fire)(a)
        }
        ;
        ha.Trashcan.prototype.blockMouseDownWhenOpenable_ = function(a) {
            !this.contentsIsOpen() && this.hasContents_() && a.stopPropagation()
        }
        ;
        ha.Trashcan.prototype.mouseOver_ = function() {
            this.hasContents_() && this.setLidOpen(!0)
        }
        ;
        ha.Trashcan.prototype.mouseOut_ = function() {
            this.setLidOpen(!1)
        }
        ;
        ha.Trashcan.prototype.onDelete_ = function(a) {
            if (!(0 >= this.workspace_.options.maxTrashcanContents || a.type !== k.DELETE || a.wasShadow) && (a = this.cleanBlockJson_(a.oldJson),
            -1 === this.contents_.indexOf(a))) {
                for (this.contents_.unshift(a); this.contents_.length > this.workspace_.options.maxTrashcanContents; )
                    this.contents_.pop();
                this.setMinOpenness_(.1)
            }
        }
        ;
        ha.Trashcan.prototype.cleanBlockJson_ = function(a) {
            function b(c) {
                if (c) {
                    delete c.id;
                    delete c.x;
                    delete c.y;
                    delete c.enabled;
                    if (c.icons && c.icons.comment) {
                        var d = c.icons.comment;
                        delete d.height;
                        delete d.width;
                        delete d.pinned
                    }
                    d = c.inputs;
                    for (var f in d) {
                        var g = d[f];
                        b(g.block);
                        b(g.shadow)
                    }
                    c.next && (c = c.next,
                    b(c.block),
                    b(c.shadow))
                }
            }
            a = JSON.parse(JSON.stringify(a));
            b(a);
            a.kind = "BLOCK";
            return JSON.stringify(a)
        }
        ;
        var cb = {
            FlyoutButton: function(a, b, c, d) {
                this.workspace_ = a;
                this.targetWorkspace_ = b;
                this.text_ = c.text;
                this.position_ = new J(0,0);
                this.isLabel_ = d;
                this.callbackKey_ = c.callbackKey || c.callbackkey;
                this.cssClass_ = c["web-class"] || null;
                this.onMouseUpWrapper_ = null;
                this.info = c
            }
        };
        cb.FlyoutButton.MARGIN_X = 5;
        cb.FlyoutButton.MARGIN_Y = 2;
        cb.FlyoutButton.prototype.width = 0;
        cb.FlyoutButton.prototype.height = 0;
        cb.FlyoutButton.prototype.createDom = function() {
            var a = this.isLabel_ ? "blocklyFlyoutLabel" : "blocklyFlyoutButton";
            this.cssClass_ && (a += " " + this.cssClass_);
            this.svgGroup_ = (0,
            n.createSvgElement)(u.G, {
                "class": a
            }, this.workspace_.getCanvas());
            var b;
            this.isLabel_ || (b = (0,
            n.createSvgElement)(u.RECT, {
                "class": "blocklyFlyoutButtonShadow",
                rx: 4,
                ry: 4,
                x: 1,
                y: 1
            }, this.svgGroup_));
            a = (0,
            n.createSvgElement)(u.RECT, {
                "class": this.isLabel_ ? "blocklyFlyoutLabelBackground" : "blocklyFlyoutButtonBackground",
                rx: 4,
                ry: 4
            }, this.svgGroup_);
            var c = (0,
            n.createSvgElement)(u.TEXT, {
                "class": this.isLabel_ ? "blocklyFlyoutLabelText" : "blocklyText",
                x: 0,
                y: 0,
                "text-anchor": "middle"
            }, this.svgGroup_)
              , d = (0,
            ka.replaceMessageReferences)(this.text_);
            this.workspace_.RTL && (d += "\u200f");
            c.textContent = d;
            this.isLabel_ && (this.svgText_ = c,
            this.workspace_.getThemeManager().subscribe(this.svgText_, "flyoutForegroundColour", "fill"));
            var f = (0,
            ta.getComputedStyle)(c, "fontSize")
              , g = (0,
            ta.getComputedStyle)(c, "fontWeight")
              , m = (0,
            ta.getComputedStyle)(c, "fontFamily");
            this.width = (0,
            n.getFastTextWidthWithSizeString)(c, f, g, m);
            d = (0,
            n.measureFontMetrics)(d, f, g, m);
            this.height = d.height;
            this.isLabel_ || (this.width += 2 * cb.FlyoutButton.MARGIN_X,
            this.height += 2 * cb.FlyoutButton.MARGIN_Y,
            b.setAttribute("width", this.width),
            b.setAttribute("height", this.height));
            a.setAttribute("width", this.width);
            a.setAttribute("height", this.height);
            c.setAttribute("x", this.width / 2);
            c.setAttribute("y", this.height / 2 - d.height / 2 + d.baseline);
            this.updateTransform_();
            this.onMouseUpWrapper_ = (0,
            y.conditionalBind)(this.svgGroup_, "mouseup", this, this.onMouseUp_);
            return this.svgGroup_
        }
        ;
        cb.FlyoutButton.prototype.show = function() {
            this.updateTransform_();
            this.svgGroup_.setAttribute("display", "block")
        }
        ;
        cb.FlyoutButton.prototype.updateTransform_ = function() {
            this.svgGroup_.setAttribute("transform", "translate(" + this.position_.x + "," + this.position_.y + ")")
        }
        ;
        cb.FlyoutButton.prototype.moveTo = function(a, b) {
            this.position_.x = a;
            this.position_.y = b;
            this.updateTransform_()
        }
        ;
        cb.FlyoutButton.prototype.isLabel = function() {
            return this.isLabel_
        }
        ;
        cb.FlyoutButton.prototype.getPosition = function() {
            return this.position_
        }
        ;
        cb.FlyoutButton.prototype.getButtonText = function() {
            return this.text_
        }
        ;
        cb.FlyoutButton.prototype.getTargetWorkspace = function() {
            return this.targetWorkspace_
        }
        ;
        cb.FlyoutButton.prototype.dispose = function() {
            this.onMouseUpWrapper_ && (0,
            y.unbind)(this.onMouseUpWrapper_);
            this.svgGroup_ && (0,
            n.removeNode)(this.svgGroup_);
            this.svgText_ && this.workspace_.getThemeManager().unsubscribe(this.svgText_)
        }
        ;
        cb.FlyoutButton.prototype.onMouseUp_ = function(a) {
            (a = this.targetWorkspace_.getGesture(a)) && a.cancel();
            this.isLabel_ && this.callbackKey_ ? console.warn("Labels should not have callbacks. Label text: " + this.text_) : this.isLabel_ || this.callbackKey_ && this.targetWorkspace_.getButtonCallback(this.callbackKey_) ? this.isLabel_ || this.targetWorkspace_.getButtonCallback(this.callbackKey_)(this) : console.warn("Buttons should have callbacks. Button text: " + this.text_)
        }
        ;
        (0,
        v.register)("\n  .blocklyFlyoutButton {\n    fill: #888;\n    cursor: default;\n  }\n\n  .blocklyFlyoutButtonShadow {\n    fill: #666;\n  }\n\n  .blocklyFlyoutButton:hover {\n    fill: #aaa;\n  }\n\n  .blocklyFlyoutLabel {\n    cursor: default;\n  }\n\n  .blocklyFlyoutLabelBackground {\n    opacity: 0;\n  }\n");
        var Mc = {
            CATEGORY_NAME: "VARIABLE_DYNAMIC",
            onCreateVariableButtonClick_String: function(a) {
                (0,
                e.module$exports$Blockly$Variables.createVariableButtonHandler)(a.getTargetWorkspace(), void 0, "String")
            },
            onCreateVariableButtonClick_Number: function(a) {
                (0,
                e.module$exports$Blockly$Variables.createVariableButtonHandler)(a.getTargetWorkspace(), void 0, "Number")
            },
            onCreateVariableButtonClick_Colour: function(a) {
                (0,
                e.module$exports$Blockly$Variables.createVariableButtonHandler)(a.getTargetWorkspace(), void 0, "Colour")
            },
            flyoutCategory: function(a) {
                var b = []
                  , c = document.createElement("button");
                c.setAttribute("text", e.module$exports$Blockly$Msg.Msg.NEW_STRING_VARIABLE);
                c.setAttribute("callbackKey", "CREATE_VARIABLE_STRING");
                b.push(c);
                c = document.createElement("button");
                c.setAttribute("text", e.module$exports$Blockly$Msg.Msg.NEW_NUMBER_VARIABLE);
                c.setAttribute("callbackKey", "CREATE_VARIABLE_NUMBER");
                b.push(c);
                c = document.createElement("button");
                c.setAttribute("text", e.module$exports$Blockly$Msg.Msg.NEW_COLOUR_VARIABLE);
                c.setAttribute("callbackKey", "CREATE_VARIABLE_COLOUR");
                b.push(c);
                a.registerButtonCallback("CREATE_VARIABLE_STRING", Mc.onCreateVariableButtonClick_String);
                a.registerButtonCallback("CREATE_VARIABLE_NUMBER", Mc.onCreateVariableButtonClick_Number);
                a.registerButtonCallback("CREATE_VARIABLE_COLOUR", Mc.onCreateVariableButtonClick_Colour);
                a = (0,
                Mc.flyoutCategoryBlocks)(a);
                return b.concat(a)
            },
            flyoutCategoryBlocks: function(a) {
                a = a.getAllVariables();
                var b = [];
                if (0 < a.length) {
                    if (e.module$exports$Blockly$blocks.Blocks.variables_set_dynamic) {
                        var c = a[a.length - 1]
                          , d = (0,
                        e.module$exports$Blockly$utils$xml.createElement)("block");
                        d.setAttribute("type", "variables_set_dynamic");
                        d.setAttribute("gap", 24);
                        d.appendChild((0,
                        e.module$exports$Blockly$Variables.generateVariableFieldDom)(c));
                        b.push(d)
                    }
                    if (e.module$exports$Blockly$blocks.Blocks.variables_get_dynamic)
                        for (a.sort(Hc.compareByName),
                        c = 0; d = a[c]; c++) {
                            var f = (0,
                            e.module$exports$Blockly$utils$xml.createElement)("block");
                            f.setAttribute("type", "variables_get_dynamic");
                            f.setAttribute("gap", 8);
                            f.appendChild((0,
                            e.module$exports$Blockly$Variables.generateVariableFieldDom)(d));
                            b.push(f)
                        }
                }
                return b
            }
        };
        e.module$exports$Blockly$Procedures = {
            CATEGORY_NAME: "PROCEDURE",
            DEFAULT_ARG: "x",
            allProcedures: function(a) {
                var b = a.getBlocksByType("procedures_defnoreturn", !1).map(function(c) {
                    return c.getProcedureDef()
                });
                a = a.getBlocksByType("procedures_defreturn", !1).map(function(c) {
                    return c.getProcedureDef()
                });
                b.sort(Se);
                a.sort(Se);
                return [b, a]
            }
        };
        var Se = function(a, b) {
            return a[0].localeCompare(b[0], void 0, {
                sensitivity: "base"
            })
        };
        e.module$exports$Blockly$Procedures.findLegalName = function(a, b) {
            if (b.isInFlyout)
                return a;
            for (a = a || e.module$exports$Blockly$Msg.Msg.UNNAMED_KEY || "unnamed"; !tf(a, b.workspace, b); ) {
                var c = a.match(/^(.*?)(\d+)$/);
                a = c ? c[1] + (parseInt(c[2], 10) + 1) : a + "2"
            }
            return a
        }
        ;
        var tf = function(a, b, c) {
            return !(0,
            e.module$exports$Blockly$Procedures.isNameUsed)(a, b, c)
        };
        e.module$exports$Blockly$Procedures.isNameUsed = function(a, b, c) {
            b = b.getAllBlocks(!1);
            for (var d = 0; d < b.length; d++)
                if (b[d] !== c && b[d].getProcedureDef) {
                    var f = b[d].getProcedureDef();
                    if (e.module$exports$Blockly$Names.Names.equals(f[0], a))
                        return !0
                }
            return !1
        }
        ;
        e.module$exports$Blockly$Procedures.rename = function(a) {
            a = a.trim();
            var b = (0,
            e.module$exports$Blockly$Procedures.findLegalName)(a, this.getSourceBlock())
              , c = this.getValue();
            if (c !== a && c !== b) {
                a = this.getSourceBlock().workspace.getAllBlocks(!1);
                for (var d = 0; d < a.length; d++)
                    a[d].renameProcedure && a[d].renameProcedure(c, b)
            }
            return b
        }
        ;
        e.module$exports$Blockly$Procedures.flyoutCategory = function(a) {
            function b(g, m) {
                for (var r = 0; r < g.length; r++) {
                    var B = g[r][0]
                      , G = g[r][1]
                      , W = (0,
                    e.module$exports$Blockly$utils$xml.createElement)("block");
                    W.setAttribute("type", m);
                    W.setAttribute("gap", 16);
                    var ra = (0,
                    e.module$exports$Blockly$utils$xml.createElement)("mutation");
                    ra.setAttribute("name", B);
                    W.appendChild(ra);
                    for (B = 0; B < G.length; B++) {
                        var Fa = (0,
                        e.module$exports$Blockly$utils$xml.createElement)("arg");
                        Fa.setAttribute("name", G[B]);
                        ra.appendChild(Fa)
                    }
                    c.push(W)
                }
            }
            var c = [];
            if (e.module$exports$Blockly$blocks.Blocks.procedures_defnoreturn) {
                var d = (0,
                e.module$exports$Blockly$utils$xml.createElement)("block");
                d.setAttribute("type", "procedures_defnoreturn");
                d.setAttribute("gap", 16);
                var f = (0,
                e.module$exports$Blockly$utils$xml.createElement)("field");
                f.setAttribute("name", "NAME");
                f.appendChild((0,
                e.module$exports$Blockly$utils$xml.createTextNode)(e.module$exports$Blockly$Msg.Msg.PROCEDURES_DEFNORETURN_PROCEDURE));
                d.appendChild(f);
                c.push(d)
            }
            e.module$exports$Blockly$blocks.Blocks.procedures_defreturn && (d = (0,
            e.module$exports$Blockly$utils$xml.createElement)("block"),
            d.setAttribute("type", "procedures_defreturn"),
            d.setAttribute("gap", 16),
            f = (0,
            e.module$exports$Blockly$utils$xml.createElement)("field"),
            f.setAttribute("name", "NAME"),
            f.appendChild((0,
            e.module$exports$Blockly$utils$xml.createTextNode)(e.module$exports$Blockly$Msg.Msg.PROCEDURES_DEFRETURN_PROCEDURE)),
            d.appendChild(f),
            c.push(d));
            e.module$exports$Blockly$blocks.Blocks.procedures_ifreturn && (d = (0,
            e.module$exports$Blockly$utils$xml.createElement)("block"),
            d.setAttribute("type", "procedures_ifreturn"),
            d.setAttribute("gap", 16),
            c.push(d));
            c.length && c[c.length - 1].setAttribute("gap", 24);
            a = (0,
            e.module$exports$Blockly$Procedures.allProcedures)(a);
            b(a[0], "procedures_callnoreturn");
            b(a[1], "procedures_callreturn");
            return c
        }
        ;
        var Te = function(a) {
            for (var b = [], c = a.getBlocksByType("procedures_mutatorarg", !1), d = 0, f; f = c[d]; d++)
                b.push(f.getFieldValue("NAME"));
            c = (0,
            e.module$exports$Blockly$utils$xml.createElement)("xml");
            d = (0,
            e.module$exports$Blockly$utils$xml.createElement)("block");
            d.setAttribute("type", "procedures_mutatorarg");
            f = (0,
            e.module$exports$Blockly$utils$xml.createElement)("field");
            f.setAttribute("name", "NAME");
            b = (0,
            e.module$exports$Blockly$Variables.generateUniqueNameFromOptions)(e.module$exports$Blockly$Procedures.DEFAULT_ARG, b);
            b = (0,
            e.module$exports$Blockly$utils$xml.createTextNode)(b);
            f.appendChild(b);
            d.appendChild(f);
            c.appendChild(d);
            a.updateToolbox(c)
        };
        e.module$exports$Blockly$Procedures.mutatorOpenListener = function(a) {
            if (a.type === k.BUBBLE_OPEN && "mutator" === a.bubbleType && a.isOpen) {
                a = N.Workspace.getById(a.workspaceId).getBlockById(a.blockId);
                var b = a.type;
                if ("procedures_defnoreturn" === b || "procedures_defreturn" === b)
                    a = a.mutator.getWorkspace(),
                    Te(a),
                    a.addChangeListener(uf)
            }
        }
        ;
        var uf = function(a) {
            if (a.type === k.CREATE || a.type === k.DELETE || a.type === k.CHANGE)
                a = N.Workspace.getById(a.workspaceId),
                Te(a)
        };
        e.module$exports$Blockly$Procedures.getCallers = function(a, b) {
            var c = [];
            b = b.getAllBlocks(!1);
            for (var d = 0; d < b.length; d++)
                if (b[d].getProcedureCall) {
                    var f = b[d].getProcedureCall();
                    f && e.module$exports$Blockly$Names.Names.equals(f, a) && c.push(b[d])
                }
            return c
        }
        ;
        e.module$exports$Blockly$Procedures.mutateCallers = function(a) {
            var b = (0,
            k.getRecordUndo)()
              , c = a.getProcedureDef()[0]
              , d = a.mutationToDom(!0);
            a = (0,
            e.module$exports$Blockly$Procedures.getCallers)(c, a.workspace);
            c = 0;
            for (var f; f = a[c]; c++) {
                var g = f.mutationToDom();
                g = g && (0,
                e.module$exports$Blockly$Xml.domToText)(g);
                f.domToMutation(d);
                var m = f.mutationToDom();
                m = m && (0,
                e.module$exports$Blockly$Xml.domToText)(m);
                g !== m && ((0,
                k.setRecordUndo)(!1),
                (0,
                k.fire)(new ((0,
                k.get)(k.CHANGE))(f,"mutation",null,g,m)),
                (0,
                k.setRecordUndo)(b))
            }
        }
        ;
        e.module$exports$Blockly$Procedures.getDefinition = function(a, b) {
            b = b.getAllBlocks(!1);
            for (var c = 0; c < b.length; c++)
                if (b[c].getProcedureDef) {
                    var d = b[c].getProcedureDef();
                    if (d && e.module$exports$Blockly$Names.Names.equals(d[0], a))
                        return b[c]
                }
            return null
        }
        ;
        e.module$exports$Blockly$Mutator = {
            Mutator: function(a) {
                e.module$exports$Blockly$Mutator.Mutator.superClass_.constructor.call(this, null);
                this.quarkNames_ = a
            }
        };
        (0,
        e.module$exports$Blockly$utils$object.inherits)(e.module$exports$Blockly$Mutator.Mutator, La);
        e.module$exports$Blockly$Mutator.Mutator.prototype.workspace_ = null;
        e.module$exports$Blockly$Mutator.Mutator.prototype.workspaceWidth_ = 0;
        e.module$exports$Blockly$Mutator.Mutator.prototype.workspaceHeight_ = 0;
        e.module$exports$Blockly$Mutator.Mutator.prototype.setBlock = function(a) {
            this.block_ = a
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.getWorkspace = function() {
            return this.workspace_
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.drawIcon_ = function(a) {
            (0,
            n.createSvgElement)(u.RECT, {
                "class": "blocklyIconShape",
                rx: "4",
                ry: "4",
                height: "16",
                width: "16"
            }, a);
            (0,
            n.createSvgElement)(u.PATH, {
                "class": "blocklyIconSymbol",
                d: "m4.203,7.296 0,1.368 -0.92,0.677 -0.11,0.41 0.9,1.559 0.41,0.11 1.043,-0.457 1.187,0.683 0.127,1.134 0.3,0.3 1.8,0 0.3,-0.299 0.127,-1.138 1.185,-0.682 1.046,0.458 0.409,-0.11 0.9,-1.559 -0.11,-0.41 -0.92,-0.677 0,-1.366 0.92,-0.677 0.11,-0.41 -0.9,-1.559 -0.409,-0.109 -1.046,0.458 -1.185,-0.682 -0.127,-1.138 -0.3,-0.299 -1.8,0 -0.3,0.3 -0.126,1.135 -1.187,0.682 -1.043,-0.457 -0.41,0.11 -0.899,1.559 0.108,0.409z"
            }, a);
            (0,
            n.createSvgElement)(u.CIRCLE, {
                "class": "blocklyIconShape",
                r: "2.7",
                cx: "8",
                cy: "8"
            }, a)
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.iconClick_ = function(a) {
            this.block_.isEditable() && La.prototype.iconClick_.call(this, a)
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.createEditor_ = function() {
            this.svgDialog_ = (0,
            n.createSvgElement)(u.SVG, {
                x: H.Bubble.BORDER_WIDTH,
                y: H.Bubble.BORDER_WIDTH
            }, null);
            if (this.quarkNames_.length)
                for (var a = (0,
                e.module$exports$Blockly$utils$xml.createElement)("xml"), b = 0, c; c = this.quarkNames_[b]; b++) {
                    var d = (0,
                    e.module$exports$Blockly$utils$xml.createElement)("block");
                    d.setAttribute("type", c);
                    a.appendChild(d)
                }
            else
                a = null;
            b = new nb.Options({
                disable: !1,
                parentWorkspace: this.block_.workspace,
                media: this.block_.workspace.options.pathToMedia,
                rtl: this.block_.RTL,
                horizontalLayout: !1,
                renderer: this.block_.workspace.options.renderer,
                rendererOverrides: this.block_.workspace.options.rendererOverrides
            });
            b.toolboxPosition = this.block_.RTL ? X.Position.RIGHT : X.Position.LEFT;
            if (c = !!a)
                b.languageTree = (0,
                X.convertToolboxDefToJson)(a);
            this.workspace_ = new x.WorkspaceSvg(b);
            this.workspace_.isMutator = !0;
            this.workspace_.addChangeListener(k.disableOrphans);
            a = c ? this.workspace_.addFlyout(u.G) : null;
            b = this.workspace_.createDom("blocklyMutatorBackground");
            a && b.insertBefore(a, this.workspace_.svgBlockCanvas_);
            this.svgDialog_.appendChild(b);
            return this.svgDialog_
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.updateEditable = function() {
            e.module$exports$Blockly$Mutator.Mutator.superClass_.updateEditable.call(this);
            this.block_.isInFlyout || (this.block_.isEditable() ? this.iconGroup_ && (0,
            n.removeClass)(this.iconGroup_, "blocklyIconGroupReadonly") : (this.setVisible(!1),
            this.iconGroup_ && (0,
            n.addClass)(this.iconGroup_, "blocklyIconGroupReadonly")))
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.resizeBubble_ = function() {
            var a = 2 * H.Bubble.BORDER_WIDTH
              , b = this.workspace_.getCanvas().getBBox()
              , c = b.width + b.x
              , d = b.height + 3 * a
              , f = this.workspace_.getFlyout();
            if (f) {
                var g = f.getWorkspace().getMetricsManager().getScrollMetrics();
                d = Math.max(d, g.height + 20);
                c += f.getWidth()
            }
            this.block_.RTL && (c = -b.x);
            c += 3 * a;
            if (Math.abs(this.workspaceWidth_ - c) > a || Math.abs(this.workspaceHeight_ - d) > a)
                this.workspaceWidth_ = c,
                this.workspaceHeight_ = d,
                this.bubble_.setBubbleSize(c + a, d + a),
                this.svgDialog_.setAttribute("width", this.workspaceWidth_),
                this.svgDialog_.setAttribute("height", this.workspaceHeight_),
                this.workspace_.setCachedParentSvgSize(this.workspaceWidth_, this.workspaceHeight_);
            this.block_.RTL && (a = "translate(" + this.workspaceWidth_ + ",0)",
            this.workspace_.getCanvas().setAttribute("transform", a));
            this.workspace_.resize()
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.onBubbleMove_ = function() {
            this.workspace_ && this.workspace_.recordDragTargets()
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.setVisible = function(a) {
            if (a !== this.isVisible())
                if ((0,
                k.fire)(new ((0,
                k.get)(k.BUBBLE_OPEN))(this.block_,a,"mutator")),
                a) {
                    this.bubble_ = new H.Bubble(this.block_.workspace,this.createEditor_(),this.block_.pathObject.svgPath,this.iconXY_,null,null);
                    this.bubble_.setSvgId(this.block_.id);
                    this.bubble_.registerMoveEvent(this.onBubbleMove_.bind(this));
                    var b = this.workspace_.options.languageTree;
                    a = this.workspace_.getFlyout();
                    b && (a.init(this.workspace_),
                    a.show(b));
                    this.rootBlock_ = this.block_.decompose(this.workspace_);
                    b = this.rootBlock_.getDescendants(!1);
                    for (var c = 0, d = void 0; d = b[c]; c++)
                        d.render();
                    this.rootBlock_.setMovable(!1);
                    this.rootBlock_.setDeletable(!1);
                    a ? (b = 2 * a.CORNER_RADIUS,
                    a = this.rootBlock_.RTL ? a.getWidth() + b : b) : a = b = 16;
                    this.block_.RTL && (a = -a);
                    this.rootBlock_.moveBy(a, b);
                    if (this.block_.saveConnections) {
                        var f = this
                          , g = this.block_;
                        g.saveConnections(this.rootBlock_);
                        this.sourceListener_ = function() {
                            g.saveConnections(f.rootBlock_)
                        }
                        ;
                        this.block_.workspace.addChangeListener(this.sourceListener_)
                    }
                    this.resizeBubble_();
                    this.workspace_.addChangeListener(this.workspaceChanged_.bind(this));
                    this.updateWorkspace_();
                    this.applyColour()
                } else
                    this.svgDialog_ = null,
                    this.workspace_.dispose(),
                    this.rootBlock_ = this.workspace_ = null,
                    this.bubble_.dispose(),
                    this.bubble_ = null,
                    this.workspaceHeight_ = this.workspaceWidth_ = 0,
                    this.sourceListener_ && (this.block_.workspace.removeChangeListener(this.sourceListener_),
                    this.sourceListener_ = null)
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.workspaceChanged_ = function(a) {
            a.isUiEvent || a.type === k.CHANGE && "disabled" === a.element || a.type === k.CREATE || this.updateWorkspace_()
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.updateWorkspace_ = function() {
            if (!this.workspace_.isDragging())
                for (var a = this.workspace_.getTopBlocks(!1), b = 0, c = void 0; c = a[b]; b++) {
                    var d = c.getRelativeToSurfaceXY();
                    20 > d.y && c.moveBy(0, 20 - d.y);
                    if (c.RTL) {
                        var f = -20
                          , g = this.workspace_.getFlyout();
                        g && (f -= g.getWidth());
                        d.x > f && c.moveBy(f - d.x, 0)
                    } else
                        20 > d.x && c.moveBy(20 - d.x, 0)
                }
            if (this.rootBlock_.workspace === this.workspace_) {
                (0,
                k.setGroup)(!0);
                var m = this.block_;
                a = gb.BlockChange.getExtraBlockState_(m);
                b = m.rendered;
                m.rendered = !1;
                m.compose(this.rootBlock_);
                m.rendered = b;
                m.initSvg();
                m.rendered && m.render();
                b = gb.BlockChange.getExtraBlockState_(m);
                if (a !== b) {
                    (0,
                    k.fire)(new ((0,
                    k.get)(k.CHANGE))(m,"mutation",null,a,b));
                    var r = (0,
                    k.getGroup)();
                    setTimeout(function() {
                        (0,
                        k.setGroup)(r);
                        m.bumpNeighbours();
                        (0,
                        k.setGroup)(!1)
                    }, e.module$exports$Blockly$internalConstants.BUMP_DELAY)
                }
                this.workspace_.isDragging() || this.resizeBubble_();
                (0,
                k.setGroup)(!1)
            }
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.dispose = function() {
            this.block_.mutator = null;
            La.prototype.dispose.call(this)
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.prototype.updateBlockStyle = function() {
            var a = this.workspace_;
            if (a && a.getAllBlocks(!1)) {
                for (var b = a.getAllBlocks(!1), c = 0, d; d = b[c]; c++)
                    d.setStyle(d.getStyleName());
                if (a = a.getFlyout())
                    for (a = a.workspace_.getAllBlocks(!1),
                    b = 0; c = a[b]; b++)
                        c.setStyle(c.getStyleName())
            }
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.reconnect = function(a, b, c) {
            if (!a || !a.getSourceBlock().workspace)
                return !1;
            c = b.getInput(c).connection;
            var d = a.targetBlock();
            return d && d !== b || c.targetConnection === a ? !1 : (c.isConnected() && c.disconnect(),
            c.connect(a),
            !0)
        }
        ;
        e.module$exports$Blockly$Mutator.Mutator.findParentWs = function(a) {
            var b = null;
            if (a && a.options) {
                var c = a.options.parentWorkspace;
                a.isFlyout ? c && c.options && (b = c.options.parentWorkspace) : c && (b = c)
            }
            return b
        }
        ;
        e.Blockly = {
            VERSION: "7.20211209.4"
        };
        e.Blockly.ALIGN_LEFT = e.module$exports$Blockly$Input.Align.LEFT;
        e.Blockly.ALIGN_CENTRE = e.module$exports$Blockly$Input.Align.CENTRE;
        e.Blockly.ALIGN_RIGHT = e.module$exports$Blockly$Input.Align.RIGHT;
        e.Blockly.INPUT_VALUE = e.module$exports$Blockly$ConnectionType.ConnectionType.INPUT_VALUE;
        e.Blockly.OUTPUT_VALUE = e.module$exports$Blockly$ConnectionType.ConnectionType.OUTPUT_VALUE;
        e.Blockly.NEXT_STATEMENT = e.module$exports$Blockly$ConnectionType.ConnectionType.NEXT_STATEMENT;
        e.Blockly.PREVIOUS_STATEMENT = e.module$exports$Blockly$ConnectionType.ConnectionType.PREVIOUS_STATEMENT;
        e.Blockly.DUMMY_INPUT = e.module$exports$Blockly$inputTypes.inputTypes.DUMMY;
        e.Blockly.TOOLBOX_AT_TOP = X.Position.TOP;
        e.Blockly.TOOLBOX_AT_BOTTOM = X.Position.BOTTOM;
        e.Blockly.TOOLBOX_AT_LEFT = X.Position.LEFT;
        e.Blockly.TOOLBOX_AT_RIGHT = X.Position.RIGHT;
        e.Blockly.svgResize = e.module$exports$Blockly$common.svgResize;
        e.Blockly.hideChaff = function(a) {
            (0,
            e.module$exports$Blockly$common.getMainWorkspace)().hideChaff(a)
        }
        ;
        e.Blockly.getMainWorkspace = e.module$exports$Blockly$common.getMainWorkspace;
        e.Blockly.defineBlocksWithJsonArray = e.module$exports$Blockly$common.defineBlocksWithJsonArray;
        e.Blockly.setParentContainer = e.module$exports$Blockly$common.setParentContainer;
        Object.defineProperties(e.Blockly, {
            alert: {
                set: function(a) {
                    (0,
                    q.warn)("Blockly.alert", "December 2021", "December 2022");
                    (0,
                    Ua.setAlert)(a)
                },
                get: function() {
                    (0,
                    q.warn)("Blockly.alert", "December 2021", "December 2022", "Blockly.dialog.alert()");
                    return Ua.alert
                }
            },
            confirm: {
                set: function(a) {
                    (0,
                    q.warn)("Blockly.confirm", "December 2021", "December 2022");
                    (0,
                    Ua.setConfirm)(a)
                },
                get: function() {
                    (0,
                    q.warn)("Blockly.confirm", "December 2021", "December 2022", "Blockly.dialog.confirm()");
                    return Ua.confirm
                }
            },
            mainWorkspace: {
                set: function(a) {
                    (0,
                    e.module$exports$Blockly$common.setMainWorkspace)(a)
                },
                get: function() {
                    return (0,
                    e.module$exports$Blockly$common.getMainWorkspace)()
                }
            },
            prompt: {
                set: function(a) {
                    (0,
                    q.warn)("Blockly.prompt", "December 2021", "December 2022");
                    (0,
                    Ua.setPrompt)(a)
                },
                get: function() {
                    (0,
                    q.warn)("Blockly.prompt", "December 2021", "December 2022", "Blockly.dialog.prompt()");
                    return Ua.prompt
                }
            },
            selected: {
                get: function() {
                    return (0,
                    e.module$exports$Blockly$common.getSelected)()
                },
                set: function(a) {
                    (0,
                    e.module$exports$Blockly$common.setSelected)(a)
                }
            },
            HSV_SATURATION: {
                get: function() {
                    return ca.colour.getHsvSaturation()
                },
                set: function(a) {
                    ca.colour.setHsvSaturation(a)
                }
            },
            HSV_VALUE: {
                get: function() {
                    return ca.colour.getHsvValue()
                },
                set: function(a) {
                    ca.colour.setHsvValue(a)
                }
            }
        });
        e.Blockly.svgSize = ja.svgSize;
        e.Blockly.resizeSvgContents = function(a) {
            (0,
            q.warn)("Blockly.resizeSvgContents", "December 2021", "December 2022", "Blockly.WorkspaceSvg.resizeSvgContents");
            (0,
            x.resizeSvgContents)(a)
        }
        ;
        e.Blockly.copy = function(a) {
            (0,
            q.warn)("Blockly.copy", "December 2021", "December 2022", "Blockly.clipboard.copy");
            (0,
            yb.copy)(a)
        }
        ;
        e.Blockly.paste = function() {
            (0,
            q.warn)("Blockly.paste", "December 2021", "December 2022", "Blockly.clipboard.paste");
            return (0,
            yb.paste)()
        }
        ;
        e.Blockly.duplicate = function(a) {
            (0,
            q.warn)("Blockly.duplicate", "December 2021", "December 2022", "Blockly.clipboard.duplicate");
            (0,
            yb.duplicate)(a)
        }
        ;
        e.Blockly.isNumber = function(a) {
            (0,
            q.warn)("Blockly.isNumber", "December 2021", "December 2022", "Blockly.utils.string.isNumber");
            return ca.string.isNumber(a)
        }
        ;
        e.Blockly.hueToHex = function(a) {
            (0,
            q.warn)("Blockly.hueToHex", "December 2021", "December 2022", "Blockly.utils.colour.hueToHex");
            return (0,
            na.hueToHex)(a)
        }
        ;
        e.Blockly.bindEvent_ = function(a, b, c, d) {
            (0,
            q.warn)("Blockly.bindEvent_", "December 2021", "December 2022", "Blockly.browserEvents.bind");
            return (0,
            y.bind)(a, b, c, d)
        }
        ;
        e.Blockly.unbindEvent_ = function(a) {
            (0,
            q.warn)("Blockly.unbindEvent_", "December 2021", "December 2022", "Blockly.browserEvents.unbind");
            return (0,
            y.unbind)(a)
        }
        ;
        e.Blockly.bindEventWithChecks_ = function(a, b, c, d, f, g) {
            (0,
            q.warn)("Blockly.bindEventWithChecks_", "December 2021", "December 2022", "Blockly.browserEvents.conditionalBind");
            return (0,
            y.conditionalBind)(a, b, c, d, f, g)
        }
        ;
        e.Blockly.LINE_MODE_MULTIPLIER = e.module$exports$Blockly$internalConstants.LINE_MODE_MULTIPLIER;
        e.Blockly.PAGE_MODE_MULTIPLIER = e.module$exports$Blockly$internalConstants.PAGE_MODE_MULTIPLIER;
        e.Blockly.DRAG_RADIUS = e.module$exports$Blockly$internalConstants.DRAG_RADIUS;
        e.Blockly.FLYOUT_DRAG_RADIUS = e.module$exports$Blockly$internalConstants.FLYOUT_DRAG_RADIUS;
        e.Blockly.SNAP_RADIUS = e.module$exports$Blockly$internalConstants.SNAP_RADIUS;
        e.Blockly.CONNECTING_SNAP_RADIUS = e.module$exports$Blockly$internalConstants.SNAP_RADIUS;
        e.Blockly.CURRENT_CONNECTION_PREFERENCE = e.module$exports$Blockly$internalConstants.CURRENT_CONNECTION_PREFERENCE;
        e.Blockly.BUMP_DELAY = e.module$exports$Blockly$internalConstants.BUMP_DELAY;
        e.Blockly.BUMP_RANDOMNESS = e.module$exports$Blockly$internalConstants.BUMP_RANDOMNESS;
        e.Blockly.COLLAPSE_CHARS = e.module$exports$Blockly$internalConstants.COLLAPSE_CHARS;
        e.Blockly.LONGPRESS = e.module$exports$Blockly$internalConstants.LONGPRESS;
        e.Blockly.SOUND_LIMIT = e.module$exports$Blockly$internalConstants.SOUND_LIMIT;
        e.Blockly.DRAG_STACK = e.module$exports$Blockly$internalConstants.DRAG_STACK;
        e.Blockly.SPRITE = e.module$exports$Blockly$internalConstants.SPRITE;
        e.Blockly.DRAG_NONE = e.module$exports$Blockly$internalConstants.DRAG_NONE;
        e.Blockly.DRAG_STICKY = e.module$exports$Blockly$internalConstants.DRAG_STICKY;
        e.Blockly.DRAG_BEGIN = e.module$exports$Blockly$internalConstants.DRAG_BEGIN;
        e.Blockly.DRAG_FREE = e.module$exports$Blockly$internalConstants.DRAG_FREE;
        e.Blockly.OPPOSITE_TYPE = e.module$exports$Blockly$internalConstants.OPPOSITE_TYPE;
        e.Blockly.RENAME_VARIABLE_ID = e.module$exports$Blockly$internalConstants.RENAME_VARIABLE_ID;
        e.Blockly.DELETE_VARIABLE_ID = e.module$exports$Blockly$internalConstants.DELETE_VARIABLE_ID;
        e.Blockly.COLLAPSED_INPUT_NAME = lc.COLLAPSED_INPUT_NAME;
        e.Blockly.COLLAPSED_FIELD_NAME = lc.COLLAPSED_FIELD_NAME;
        e.Blockly.VARIABLE_CATEGORY_NAME = e.module$exports$Blockly$Variables.CATEGORY_NAME;
        e.Blockly.VARIABLE_DYNAMIC_CATEGORY_NAME = Mc.CATEGORY_NAME;
        e.Blockly.PROCEDURE_CATEGORY_NAME = e.module$exports$Blockly$Procedures.CATEGORY_NAME;
        e.Blockly.ASTNode = A.ASTNode;
        e.Blockly.BasicCursor = hb.BasicCursor;
        e.Blockly.Block = F.Block;
        e.Blockly.BlocklyOptions = function() {}
        ;
        e.Blockly.BlockDragger = $a;
        e.Blockly.BlockDragSurfaceSvg = Ta;
        e.Blockly.BlockSvg = E.BlockSvg;
        e.Blockly.Blocks = e.module$exports$Blockly$blocks.Blocks;
        e.Blockly.Bubble = H.Bubble;
        e.Blockly.BubbleDragger = Qb;
        e.Blockly.CollapsibleToolboxCategory = za.CollapsibleToolboxCategory;
        e.Blockly.Comment = Qa.Comment;
        e.Blockly.ComponentManager = oa;
        e.Blockly.Connection = K;
        e.Blockly.ConnectionType = e.module$exports$Blockly$ConnectionType.ConnectionType;
        e.Blockly.ConnectionChecker = mc;
        e.Blockly.ConnectionDB = wb;
        e.Blockly.ContextMenu = e.module$exports$Blockly$ContextMenu;
        e.Blockly.ContextMenuItems = Aa;
        e.Blockly.ContextMenuRegistry = ia.ContextMenuRegistry;
        e.Blockly.Css = v;
        e.Blockly.Cursor = rc.Cursor;
        e.Blockly.DeleteArea = Ec.DeleteArea;
        e.Blockly.DragTarget = Nc;
        e.Blockly.DropDownDiv = C;
        e.Blockly.Events = e.module$exports$Blockly$Events;
        e.Blockly.Extensions = e.module$exports$Blockly$Extensions;
        e.Blockly.Field = I;
        e.Blockly.FieldAngle = T.FieldAngle;
        e.Blockly.FieldCheckbox = e.module$exports$Blockly$FieldCheckbox.FieldCheckbox;
        e.Blockly.FieldColour = fa.FieldColour;
        e.Blockly.FieldDropdown = e.module$exports$Blockly$FieldDropdown.FieldDropdown;
        e.Blockly.FieldImage = e.module$exports$Blockly$FieldImage.FieldImage;
        e.Blockly.FieldLabel = e.module$exports$Blockly$FieldLabel.FieldLabel;
        e.Blockly.FieldLabelSerializable = Pc.FieldLabelSerializable;
        e.Blockly.FieldMultilineInput = Da.FieldMultilineInput;
        e.Blockly.FieldNumber = Oa.FieldNumber;
        e.Blockly.FieldTextInput = e.module$exports$Blockly$FieldTextInput.FieldTextInput;
        e.Blockly.FieldVariable = qa.FieldVariable;
        e.Blockly.Flyout = Y.Flyout;
        e.Blockly.FlyoutButton = cb.FlyoutButton;
        e.Blockly.FlyoutMetricsManager = Oc.FlyoutMetricsManager;
        e.Blockly.Generator = e.module$exports$Blockly$Generator.Generator;
        e.Blockly.Gesture = ba;
        e.Blockly.Grid = Fb;
        e.Blockly.HorizontalFlyout = qb.HorizontalFlyout;
        e.Blockly.IASTNodeLocation = function() {}
        ;
        e.Blockly.IASTNodeLocationSvg = function() {}
        ;
        e.Blockly.IASTNodeLocationWithBlock = function() {}
        ;
        e.Blockly.IAutoHideable = function() {}
        ;
        e.Blockly.IBlockDragger = function() {}
        ;
        e.Blockly.IBoundedElement = function() {}
        ;
        e.Blockly.IBubble = function() {}
        ;
        e.Blockly.ICollapsibleToolboxItem = function() {}
        ;
        e.Blockly.IComponent = function() {}
        ;
        e.Blockly.IConnectionChecker = function() {}
        ;
        e.Blockly.IContextMenu = function() {}
        ;
        e.Blockly.Icon = La;
        e.Blockly.ICopyable = function() {}
        ;
        e.Blockly.IDeletable = function() {}
        ;
        e.Blockly.IDeleteArea = function() {}
        ;
        e.Blockly.IDragTarget = function() {}
        ;
        e.Blockly.IDraggable = function() {}
        ;
        e.Blockly.IFlyout = function() {}
        ;
        e.Blockly.IKeyboardAccessible = function() {}
        ;
        e.Blockly.IMetricsManager = function() {}
        ;
        e.Blockly.IMovable = function() {}
        ;
        e.Blockly.Input = e.module$exports$Blockly$Input.Input;
        e.Blockly.InsertionMarkerManager = la;
        e.Blockly.IPositionable = function() {}
        ;
        e.Blockly.IRegistrable = function() {}
        ;
        e.Blockly.IRegistrableField = {};
        e.Blockly.ISelectable = function() {}
        ;
        e.Blockly.ISelectableToolboxItem = function() {}
        ;
        e.Blockly.IStyleable = function() {}
        ;
        e.Blockly.IToolbox = function() {}
        ;
        e.Blockly.IToolboxItem = function() {}
        ;
        e.Blockly.Marker = qc;
        e.Blockly.MarkerManager = ub;
        e.Blockly.Menu = Ma;
        e.Blockly.MenuItem = eb;
        e.Blockly.MetricsManager = ib;
        e.Blockly.Mutator = e.module$exports$Blockly$Mutator.Mutator;
        e.Blockly.Msg = e.module$exports$Blockly$Msg.Msg;
        e.Blockly.Names = e.module$exports$Blockly$Names.Names;
        e.Blockly.Options = nb.Options;
        e.Blockly.Procedures = e.module$exports$Blockly$Procedures;
        e.Blockly.RenderedConnection = ea.RenderedConnection;
        e.Blockly.Scrollbar = L.Scrollbar;
        e.Blockly.ScrollbarPair = ob;
        e.Blockly.ShortcutItems = lb;
        e.Blockly.ShortcutRegistry = R.ShortcutRegistry;
        e.Blockly.TabNavigateCursor = ld.TabNavigateCursor;
        e.Blockly.Theme = mb;
        e.Blockly.Themes = fe;
        e.Blockly.ThemeManager = tc;
        e.Blockly.Toolbox = Z.Toolbox;
        e.Blockly.ToolboxCategory = da.ToolboxCategory;
        e.Blockly.ToolboxItem = Rb;
        e.Blockly.ToolboxSeparator = Sb.ToolboxSeparator;
        e.Blockly.Tooltip = aa;
        e.Blockly.Touch = O;
        e.Blockly.TouchGesture = ya.TouchGesture;
        e.Blockly.Trashcan = ha.Trashcan;
        e.Blockly.VariableMap = Za;
        e.Blockly.VariableModel = Hc;
        e.Blockly.Variables = e.module$exports$Blockly$Variables;
        e.Blockly.VariablesDynamic = Mc;
        e.Blockly.VerticalFlyout = jb.VerticalFlyout;
        e.Blockly.Warning = Hb.Warning;
        e.Blockly.WidgetDiv = sa;
        e.Blockly.Workspace = N.Workspace;
        e.Blockly.WorkspaceAudio = Lc;
        e.Blockly.WorkspaceComment = ua.WorkspaceComment;
        e.Blockly.WorkspaceCommentSvg = S.WorkspaceCommentSvg;
        e.Blockly.WorkspaceDragSurfaceSvg = jc;
        e.Blockly.WorkspaceDragger = Vc;
        e.Blockly.WorkspaceSvg = x.WorkspaceSvg;
        e.Blockly.Xml = e.module$exports$Blockly$Xml;
        e.Blockly.ZoomControls = Na.ZoomControls;
        e.Blockly.blockAnimations = Pb;
        e.Blockly.blockRendering = ma;
        e.Blockly.browserEvents = y;
        e.Blockly.bumpObjects = Fc;
        e.Blockly.clipboard = yb;
        e.Blockly.common = e.module$exports$Blockly$common;
        e.Blockly.connectionTypes = e.module$exports$Blockly$ConnectionType.ConnectionType;
        e.Blockly.constants = lc;
        e.Blockly.dialog = Ua;
        e.Blockly.fieldRegistry = tb;
        e.Blockly.geras = gc;
        e.Blockly.inject = function(a, b) {
            "string" === typeof a && (a = document.getElementById(a) || document.querySelector(a));
            if (!a || !(0,
            n.containsNode)(document, a))
                throw Error("Error: container is not in current document.");
            b = new nb.Options(b || {});
            var c = document.createElement("div");
            c.className = "injectionDiv";
            c.tabIndex = 0;
            (0,
            Q.setState)(c, Q.State.LABEL, e.module$exports$Blockly$Msg.Msg.WORKSPACE_ARIA_LABEL);
            a.appendChild(c);
            a = mf(c, b);
            var d = new Ta(c)
              , f = new jc(c)
              , g = nf(a, b, d, f);
            qf(g);
            (0,
            e.module$exports$Blockly$common.setMainWorkspace)(g);
            (0,
            e.module$exports$Blockly$common.svgResize)(g);
            c.addEventListener("focusin", function() {
                (0,
                e.module$exports$Blockly$common.setMainWorkspace)(g)
            });
            return g
        }
        ;
        e.Blockly.inputTypes = e.module$exports$Blockly$inputTypes.inputTypes;
        e.Blockly.minimalist = od;
        e.Blockly.registry = w;
        e.Blockly.serialization = {
            blocks: Ya,
            exceptions: Ba,
            priorities: Xd,
            registry: Yd,
            variables: {},
            workspaces: {
                save: function(a) {
                    var b = Object.create(null), c = (0,
                    w.getAllItems)(w.Type.SERIALIZER, !0), d;
                    for (d in c) {
                        var f = c[d].save(a);
                        f && (b[d] = f)
                    }
                    return b
                },
                load: function(a, b, c) {
                    c = void 0 === c ? {} : c;
                    var d = void 0 === c.recordUndo ? !1 : c.recordUndo;
                    if (c = (0,
                    w.getAllItems)(w.Type.SERIALIZER, !0)) {
                        var f = Object.entries(c).sort(function(r, B) {
                            return B[1].priority - r[1].priority
                        });
                        c = (0,
                        k.getRecordUndo)();
                        (0,
                        k.setRecordUndo)(d);
                        (d = (0,
                        k.getGroup)()) || (0,
                        k.setGroup)(!0);
                        (0,
                        n.startTextWidthCache)();
                        b.setResizesEnabled && b.setResizesEnabled(!1);
                        for (var g = z.makeIterator(f.reverse()), m = g.next(); !m.done; m = g.next())
                            m = z.makeIterator(m.value),
                            m.next(),
                            m.next().value.clear(b);
                        f = z.makeIterator(f.reverse());
                        for (g = f.next(); !g.done; g = f.next())
                            m = z.makeIterator(g.value),
                            g = m.next().value,
                            m = m.next().value,
                            a[g] && m.load(a[g], b);
                        b.setResizesEnabled && b.setResizesEnabled(!0);
                        (0,
                        n.stopTextWidthCache)();
                        (0,
                        k.fire)(new ((0,
                        k.get)(k.FINISHED_LOADING))(b));
                        (0,
                        k.setGroup)(d);
                        (0,
                        k.setRecordUndo)(c)
                    }
                }
            },
            ISerializer: vd
        };
        e.Blockly.thrasos = ee;
        e.Blockly.uiPosition = Sa;
        e.Blockly.utils = ca;
        e.Blockly.zelos = Tb;
        "Blockly"in e.module$exports$Blockly$utils$global.globalThis || (e.module$exports$Blockly$utils$global.globalThis.Blockly = {
            Msg: e.module$exports$Blockly$Msg.Msg
        });
        e.Blockly.internal_ = e;
        return e.Blockly
    });
    return U
}
;
var process = process || {
    env: {
        NODE_ENV: "development"
    }
};
(function(U, h) {
    "function" === typeof define && define.amd ? define(["./blockly_compressed.js"], h) : "object" === typeof exports ? module.exports = h(_asset_pipeline_require("comm_vendor/blockly/blockly_compressed.js")) : U.Blockly.Python = h(U.Blockly)
}
)(this, function(U) {
    const h = U.internal_;
    U = new h.module$exports$Blockly$Generator.Generator("Python");
    U.addReservedWords("False,None,True,and,as,assert,break,class,continue,def,del,elif,else,except,exec,finally,for,from,global,if,import,in,is,lambda,nonlocal,not,or,pass,print,raise,return,try,while,with,yield,NotImplemented,Ellipsis,__debug__,quit,exit,copyright,license,credits,ArithmeticError,AssertionError,AttributeError,BaseException,BlockingIOError,BrokenPipeError,BufferError,BytesWarning,ChildProcessError,ConnectionAbortedError,ConnectionError,ConnectionRefusedError,ConnectionResetError,DeprecationWarning,EOFError,Ellipsis,EnvironmentError,Exception,FileExistsError,FileNotFoundError,FloatingPointError,FutureWarning,GeneratorExit,IOError,ImportError,ImportWarning,IndentationError,IndexError,InterruptedError,IsADirectoryError,KeyError,KeyboardInterrupt,LookupError,MemoryError,ModuleNotFoundError,NameError,NotADirectoryError,NotImplemented,NotImplementedError,OSError,OverflowError,PendingDeprecationWarning,PermissionError,ProcessLookupError,RecursionError,ReferenceError,ResourceWarning,RuntimeError,RuntimeWarning,StandardError,StopAsyncIteration,StopIteration,SyntaxError,SyntaxWarning,SystemError,SystemExit,TabError,TimeoutError,TypeError,UnboundLocalError,UnicodeDecodeError,UnicodeEncodeError,UnicodeError,UnicodeTranslateError,UnicodeWarning,UserWarning,ValueError,Warning,ZeroDivisionError,_,__build_class__,__debug__,__doc__,__import__,__loader__,__name__,__package__,__spec__,abs,all,any,apply,ascii,basestring,bin,bool,buffer,bytearray,bytes,callable,chr,classmethod,cmp,coerce,compile,complex,copyright,credits,delattr,dict,dir,divmod,enumerate,eval,exec,execfile,exit,file,filter,float,format,frozenset,getattr,globals,hasattr,hash,help,hex,id,input,int,intern,isinstance,issubclass,iter,len,license,list,locals,long,map,max,memoryview,min,next,object,oct,open,ord,pow,print,property,quit,range,raw_input,reduce,reload,repr,reversed,round,set,setattr,slice,sorted,staticmethod,str,sum,super,tuple,type,unichr,unicode,vars,xrange,zip");
    U.ORDER_ATOMIC = 0;
    U.ORDER_COLLECTION = 1;
    U.ORDER_STRING_CONVERSION = 1;
    U.ORDER_MEMBER = 2.1;
    U.ORDER_FUNCTION_CALL = 2.2;
    U.ORDER_EXPONENTIATION = 3;
    U.ORDER_UNARY_SIGN = 4;
    U.ORDER_BITWISE_NOT = 4;
    U.ORDER_MULTIPLICATIVE = 5;
    U.ORDER_ADDITIVE = 6;
    U.ORDER_BITWISE_SHIFT = 7;
    U.ORDER_BITWISE_AND = 8;
    U.ORDER_BITWISE_XOR = 9;
    U.ORDER_BITWISE_OR = 10;
    U.ORDER_RELATIONAL = 11;
    U.ORDER_LOGICAL_NOT = 12;
    U.ORDER_LOGICAL_AND = 13;
    U.ORDER_LOGICAL_OR = 14;
    U.ORDER_CONDITIONAL = 15;
    U.ORDER_LAMBDA = 16;
    U.ORDER_NONE = 99;
    U.ORDER_OVERRIDES = [[U.ORDER_FUNCTION_CALL, U.ORDER_MEMBER], [U.ORDER_FUNCTION_CALL, U.ORDER_FUNCTION_CALL], [U.ORDER_MEMBER, U.ORDER_MEMBER], [U.ORDER_MEMBER, U.ORDER_FUNCTION_CALL], [U.ORDER_LOGICAL_NOT, U.ORDER_LOGICAL_NOT], [U.ORDER_LOGICAL_AND, U.ORDER_LOGICAL_AND], [U.ORDER_LOGICAL_OR, U.ORDER_LOGICAL_OR]];
    U.isInitialized = !1;
    U.init = function(l) {
        Object.getPrototypeOf(this).init.call(this);
        this.PASS = this.INDENT + "pass\n";
        this.nameDB_ ? this.nameDB_.reset() : this.nameDB_ = new h.module$exports$Blockly$Names.Names(this.RESERVED_WORDS_);
        this.nameDB_.setVariableMap(l.getVariableMap());
        this.nameDB_.populateVariables(l);
        this.nameDB_.populateProcedures(l);
        for (var q = [], v = (0,
        h.module$exports$Blockly$Variables.allDeveloperVariables)(l), D = 0; D < v.length; D++)
            q.push(this.nameDB_.getName(v[D], h.module$exports$Blockly$Names.Names.DEVELOPER_VARIABLE_TYPE) + " = None");
        l = (0,
        h.module$exports$Blockly$Variables.allUsedVarModels)(l);
        for (v = 0; v < l.length; v++)
            q.push(this.nameDB_.getName(l[v].getId(), h.module$exports$Blockly$Names.NameType.VARIABLE) + " = None");
        this.definitions_.variables = q.join("\n");
        this.isInitialized = !0
    }
    ;
    U.finish = function(l) {
        var q = [], v = [], D;
        for (D in this.definitions_) {
            var P = this.definitions_[D];
            P.match(/^(from\s+\S+\s+)?import\s+\S+/) ? q.push(P) : v.push(P)
        }
        l = Object.getPrototypeOf(this).finish.call(this, l);
        this.isInitialized = !1;
        this.nameDB_.reset();
        return (q.join("\n") + "\n\n" + v.join("\n\n")).replace(/\n\n+/g, "\n\n").replace(/\n*$/, "\n\n\n") + l
    }
    ;
    U.scrubNakedValue = function(l) {
        return l + "\n"
    }
    ;
    U.quote_ = function(l) {
        l = l.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n");
        var q = "'";
        -1 !== l.indexOf("'") && (-1 === l.indexOf('"') ? q = '"' : l = l.replace(/'/g, "\\'"));
        return q + l + q
    }
    ;
    U.multiline_quote_ = function(l) {
        return l.split(/\n/g).map(this.quote_).join(" + '\\n' + \n")
    }
    ;
    U.scrub_ = function(l, q, v) {
        var D = "";
        if (!l.outputConnection || !l.outputConnection.targetConnection) {
            var P = l.getCommentText();
            P && (P = (0,
            h.module$exports$Blockly$utils$string.wrap)(P, this.COMMENT_WRAP - 3),
            D += this.prefixLines(P + "\n", "# "));
            for (var xa = 0; xa < l.inputList.length; xa++)
                l.inputList[xa].type === h.module$exports$Blockly$inputTypes.inputTypes.VALUE && (P = l.inputList[xa].connection.targetBlock()) && (P = this.allNestedComments(P)) && (D += this.prefixLines(P, "# "))
        }
        l = l.nextConnection && l.nextConnection.targetBlock();
        v = v ? "" : this.blockToCode(l);
        return D + q + v
    }
    ;
    U.getAdjustedInt = function(l, q, v, D) {
        v = v || 0;
        l.workspace.options.oneBasedIndex && v--;
        var P = l.workspace.options.oneBasedIndex ? "1" : "0";
        l = this.valueToCode(l, q, v ? this.ORDER_ADDITIVE : this.ORDER_NONE) || P;
        (0,
        h.module$exports$Blockly$utils$string.isNumber)(l) ? (l = parseInt(l, 10) + v,
        D && (l = -l)) : (l = 0 < v ? "int(" + l + " + " + v + ")" : 0 > v ? "int(" + l + " - " + -v + ")" : "int(" + l + ")",
        D && (l = "-" + l));
        return l
    }
    ;
    h.Blockly.Python = U;
    h.Blockly.Python.variables_get = function(l) {
        return [h.Blockly.Python.nameDB_.getName(l.getFieldValue("VAR"), h.module$exports$Blockly$Names.NameType.VARIABLE), h.Blockly.Python.ORDER_ATOMIC]
    }
    ;
    h.Blockly.Python.variables_set = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "VALUE", h.Blockly.Python.ORDER_NONE) || "0";
        return h.Blockly.Python.nameDB_.getName(l.getFieldValue("VAR"), h.module$exports$Blockly$Names.NameType.VARIABLE) + " = " + q + "\n"
    }
    ;
    h.Blockly.Python.variables_get_dynamic = h.Blockly.Python.variables_get;
    h.Blockly.Python.variables_set_dynamic = h.Blockly.Python.variables_set;
    h.Blockly.Python.text = function(l) {
        return [h.Blockly.Python.quote_(l.getFieldValue("TEXT")), h.Blockly.Python.ORDER_ATOMIC]
    }
    ;
    h.Blockly.Python.text_multiline = function(l) {
        l = h.Blockly.Python.multiline_quote_(l.getFieldValue("TEXT"));
        var q = -1 !== l.indexOf("+") ? h.Blockly.Python.ORDER_ADDITIVE : h.Blockly.Python.ORDER_ATOMIC;
        return [l, q]
    }
    ;
    var e = /^\s*'([^']|\\')*'\s*$/
      , z = function(l) {
        return e.test(l) ? [l, h.Blockly.Python.ORDER_ATOMIC] : ["str(" + l + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    };
    h.Blockly.Python.text_join = function(l) {
        switch (l.itemCount_) {
        case 0:
            return ["''", h.Blockly.Python.ORDER_ATOMIC];
        case 1:
            return l = h.Blockly.Python.valueToCode(l, "ADD0", h.Blockly.Python.ORDER_NONE) || "''",
            z(l);
        case 2:
            var q = h.Blockly.Python.valueToCode(l, "ADD0", h.Blockly.Python.ORDER_NONE) || "''";
            l = h.Blockly.Python.valueToCode(l, "ADD1", h.Blockly.Python.ORDER_NONE) || "''";
            return [z(q)[0] + " + " + z(l)[0], h.Blockly.Python.ORDER_ADDITIVE];
        default:
            q = [];
            for (var v = 0; v < l.itemCount_; v++)
                q[v] = h.Blockly.Python.valueToCode(l, "ADD" + v, h.Blockly.Python.ORDER_NONE) || "''";
            l = h.Blockly.Python.nameDB_.getDistinctName("x", h.module$exports$Blockly$Names.NameType.VARIABLE);
            return ["''.join([str(" + l + ") for " + l + " in [" + q.join(", ") + "]])", h.Blockly.Python.ORDER_FUNCTION_CALL]
        }
    }
    ;
    h.Blockly.Python.text_append = function(l) {
        var q = h.Blockly.Python.nameDB_.getName(l.getFieldValue("VAR"), h.module$exports$Blockly$Names.NameType.VARIABLE);
        l = h.Blockly.Python.valueToCode(l, "TEXT", h.Blockly.Python.ORDER_NONE) || "''";
        return q + " = str(" + q + ") + " + z(l)[0] + "\n"
    }
    ;
    h.Blockly.Python.text_length = function(l) {
        return ["len(" + (h.Blockly.Python.valueToCode(l, "VALUE", h.Blockly.Python.ORDER_NONE) || "''") + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.text_isEmpty = function(l) {
        return ["not len(" + (h.Blockly.Python.valueToCode(l, "VALUE", h.Blockly.Python.ORDER_NONE) || "''") + ")", h.Blockly.Python.ORDER_LOGICAL_NOT]
    }
    ;
    h.Blockly.Python.text_indexOf = function(l) {
        var q = "FIRST" === l.getFieldValue("END") ? "find" : "rfind"
          , v = h.Blockly.Python.valueToCode(l, "FIND", h.Blockly.Python.ORDER_NONE) || "''";
        q = (h.Blockly.Python.valueToCode(l, "VALUE", h.Blockly.Python.ORDER_MEMBER) || "''") + "." + q + "(" + v + ")";
        return l.workspace.options.oneBasedIndex ? [q + " + 1", h.Blockly.Python.ORDER_ADDITIVE] : [q, h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.text_charAt = function(l) {
        var q = l.getFieldValue("WHERE") || "FROM_START"
          , v = h.Blockly.Python.valueToCode(l, "VALUE", "RANDOM" === q ? h.Blockly.Python.ORDER_NONE : h.Blockly.Python.ORDER_MEMBER) || "''";
        switch (q) {
        case "FIRST":
            return [v + "[0]", h.Blockly.Python.ORDER_MEMBER];
        case "LAST":
            return [v + "[-1]", h.Blockly.Python.ORDER_MEMBER];
        case "FROM_START":
            return l = h.Blockly.Python.getAdjustedInt(l, "AT"),
            [v + "[" + l + "]", h.Blockly.Python.ORDER_MEMBER];
        case "FROM_END":
            return l = h.Blockly.Python.getAdjustedInt(l, "AT", 1, !0),
            [v + "[" + l + "]", h.Blockly.Python.ORDER_MEMBER];
        case "RANDOM":
            return h.Blockly.Python.definitions_.import_random = "import random",
            [h.Blockly.Python.provideFunction_("text_random_letter", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(text):", "  x = int(random.random() * len(text))", "  return text[x];"]) + "(" + v + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
        }
        throw Error("Unhandled option (text_charAt).");
    }
    ;
    h.Blockly.Python.text_getSubstring = function(l) {
        var q = l.getFieldValue("WHERE1")
          , v = l.getFieldValue("WHERE2")
          , D = h.Blockly.Python.valueToCode(l, "STRING", h.Blockly.Python.ORDER_MEMBER) || "''";
        switch (q) {
        case "FROM_START":
            q = h.Blockly.Python.getAdjustedInt(l, "AT1");
            0 === q && (q = "");
            break;
        case "FROM_END":
            q = h.Blockly.Python.getAdjustedInt(l, "AT1", 1, !0);
            break;
        case "FIRST":
            q = "";
            break;
        default:
            throw Error("Unhandled option (text_getSubstring)");
        }
        switch (v) {
        case "FROM_START":
            l = h.Blockly.Python.getAdjustedInt(l, "AT2", 1);
            break;
        case "FROM_END":
            l = h.Blockly.Python.getAdjustedInt(l, "AT2", 0, !0);
            (0,
            h.module$exports$Blockly$utils$string.isNumber)(String(l)) ? 0 === l && (l = "") : (h.Blockly.Python.definitions_.import_sys = "import sys",
            l += " or sys.maxsize");
            break;
        case "LAST":
            l = "";
            break;
        default:
            throw Error("Unhandled option (text_getSubstring)");
        }
        return [D + "[" + q + " : " + l + "]", h.Blockly.Python.ORDER_MEMBER]
    }
    ;
    h.Blockly.Python.text_changeCase = function(l) {
        var q = {
            UPPERCASE: ".upper()",
            LOWERCASE: ".lower()",
            TITLECASE: ".title()"
        }[l.getFieldValue("CASE")];
        return [(h.Blockly.Python.valueToCode(l, "TEXT", h.Blockly.Python.ORDER_MEMBER) || "''") + q, h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.text_trim = function(l) {
        var q = {
            LEFT: ".lstrip()",
            RIGHT: ".rstrip()",
            BOTH: ".strip()"
        }[l.getFieldValue("MODE")];
        return [(h.Blockly.Python.valueToCode(l, "TEXT", h.Blockly.Python.ORDER_MEMBER) || "''") + q, h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.text_print = function(l) {
        return "print(" + (h.Blockly.Python.valueToCode(l, "TEXT", h.Blockly.Python.ORDER_NONE) || "''") + ")\n"
    }
    ;
    h.Blockly.Python.text_prompt_ext = function(l) {
        var q = h.Blockly.Python.provideFunction_("text_prompt", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(msg):", "  try:", "    return raw_input(msg)", "  except NameError:", "    return input(msg)"])
          , v = l.getField("TEXT") ? h.Blockly.Python.quote_(l.getFieldValue("TEXT")) : h.Blockly.Python.valueToCode(l, "TEXT", h.Blockly.Python.ORDER_NONE) || "''";
        q = q + "(" + v + ")";
        "NUMBER" === l.getFieldValue("TYPE") && (q = "float(" + q + ")");
        return [q, h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.text_prompt = h.Blockly.Python.text_prompt_ext;
    h.Blockly.Python.text_count = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "TEXT", h.Blockly.Python.ORDER_MEMBER) || "''";
        l = h.Blockly.Python.valueToCode(l, "SUB", h.Blockly.Python.ORDER_NONE) || "''";
        return [q + ".count(" + l + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.text_replace = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "TEXT", h.Blockly.Python.ORDER_MEMBER) || "''"
          , v = h.Blockly.Python.valueToCode(l, "FROM", h.Blockly.Python.ORDER_NONE) || "''";
        l = h.Blockly.Python.valueToCode(l, "TO", h.Blockly.Python.ORDER_NONE) || "''";
        return [q + ".replace(" + v + ", " + l + ")", h.Blockly.Python.ORDER_MEMBER]
    }
    ;
    h.Blockly.Python.text_reverse = function(l) {
        return [(h.Blockly.Python.valueToCode(l, "TEXT", h.Blockly.Python.ORDER_MEMBER) || "''") + "[::-1]", h.Blockly.Python.ORDER_MEMBER]
    }
    ;
    h.Blockly.Python.procedures_defreturn = function(l) {
        for (var q = [], v = l.workspace, D = (0,
        h.module$exports$Blockly$Variables.allUsedVarModels)(v) || [], P = 0, xa; xa = D[P]; P++)
            xa = xa.name,
            -1 === l.getVars().indexOf(xa) && q.push(h.Blockly.Python.nameDB_.getName(xa, h.module$exports$Blockly$Names.NameType.VARIABLE));
        v = (0,
        h.module$exports$Blockly$Variables.allDeveloperVariables)(v);
        for (D = 0; D < v.length; D++)
            q.push(h.Blockly.Python.nameDB_.getName(v[D], h.module$exports$Blockly$Names.NameType.DEVELOPER_VARIABLE));
        v = q.length ? h.Blockly.Python.INDENT + "global " + q.join(", ") + "\n" : "";
        q = h.Blockly.Python.nameDB_.getName(l.getFieldValue("NAME"), h.module$exports$Blockly$Names.NameType.PROCEDURE);
        D = "";
        h.Blockly.Python.STATEMENT_PREFIX && (D += h.Blockly.Python.injectId(h.Blockly.Python.STATEMENT_PREFIX, l));
        h.Blockly.Python.STATEMENT_SUFFIX && (D += h.Blockly.Python.injectId(h.Blockly.Python.STATEMENT_SUFFIX, l));
        D && (D = h.Blockly.Python.prefixLines(D, h.Blockly.Python.INDENT));
        P = "";
        h.Blockly.Python.INFINITE_LOOP_TRAP && (P = h.Blockly.Python.prefixLines(h.Blockly.Python.injectId(h.Blockly.Python.INFINITE_LOOP_TRAP, l), h.Blockly.Python.INDENT));
        xa = h.Blockly.Python.statementToCode(l, "STACK");
        var Jb = h.Blockly.Python.valueToCode(l, "RETURN", h.Blockly.Python.ORDER_NONE) || ""
          , Bc = "";
        xa && Jb && (Bc = D);
        Jb ? Jb = h.Blockly.Python.INDENT + "return " + Jb + "\n" : xa || (xa = h.Blockly.Python.PASS);
        for (var O = [], ab = l.getVars(), sb = 0; sb < ab.length; sb++)
            O[sb] = h.Blockly.Python.nameDB_.getName(ab[sb], h.module$exports$Blockly$Names.NameType.VARIABLE);
        v = "def " + q + "(" + O.join(", ") + "):\n" + v + D + P + xa + Bc + Jb;
        v = h.Blockly.Python.scrub_(l, v);
        h.Blockly.Python.definitions_["%" + q] = v;
        return null
    }
    ;
    h.Blockly.Python.procedures_defnoreturn = h.Blockly.Python.procedures_defreturn;
    h.Blockly.Python.procedures_callreturn = function(l) {
        for (var q = h.Blockly.Python.nameDB_.getName(l.getFieldValue("NAME"), h.module$exports$Blockly$Names.NameType.PROCEDURE), v = [], D = l.getVars(), P = 0; P < D.length; P++)
            v[P] = h.Blockly.Python.valueToCode(l, "ARG" + P, h.Blockly.Python.ORDER_NONE) || "None";
        return [q + "(" + v.join(", ") + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.procedures_callnoreturn = function(l) {
        return h.Blockly.Python.procedures_callreturn(l)[0] + "\n"
    }
    ;
    h.Blockly.Python.procedures_ifreturn = function(l) {
        var q = "if " + (h.Blockly.Python.valueToCode(l, "CONDITION", h.Blockly.Python.ORDER_NONE) || "False") + ":\n";
        h.Blockly.Python.STATEMENT_SUFFIX && (q += h.Blockly.Python.prefixLines(h.Blockly.Python.injectId(h.Blockly.Python.STATEMENT_SUFFIX, l), h.Blockly.Python.INDENT));
        l.hasReturnValue_ ? (l = h.Blockly.Python.valueToCode(l, "VALUE", h.Blockly.Python.ORDER_NONE) || "None",
        q += h.Blockly.Python.INDENT + "return " + l + "\n") : q += h.Blockly.Python.INDENT + "return\n";
        return q
    }
    ;
    h.Blockly.Python.addReservedWords("math,random,Number");
    h.Blockly.Python.math_number = function(l) {
        l = Number(l.getFieldValue("NUM"));
        if (Infinity === l) {
            l = 'float("inf")';
            var q = h.Blockly.Python.ORDER_FUNCTION_CALL
        } else
            -Infinity === l ? (l = '-float("inf")',
            q = h.Blockly.Python.ORDER_UNARY_SIGN) : q = 0 > l ? h.Blockly.Python.ORDER_UNARY_SIGN : h.Blockly.Python.ORDER_ATOMIC;
        return [l, q]
    }
    ;
    h.Blockly.Python.math_arithmetic = function(l) {
        var q = {
            ADD: [" + ", h.Blockly.Python.ORDER_ADDITIVE],
            MINUS: [" - ", h.Blockly.Python.ORDER_ADDITIVE],
            MULTIPLY: [" * ", h.Blockly.Python.ORDER_MULTIPLICATIVE],
            DIVIDE: [" / ", h.Blockly.Python.ORDER_MULTIPLICATIVE],
            POWER: [" ** ", h.Blockly.Python.ORDER_EXPONENTIATION]
        }[l.getFieldValue("OP")]
          , v = q[0];
        q = q[1];
        var D = h.Blockly.Python.valueToCode(l, "A", q) || "0";
        l = h.Blockly.Python.valueToCode(l, "B", q) || "0";
        return [D + v + l, q]
    }
    ;
    h.Blockly.Python.math_single = function(l) {
        var q = l.getFieldValue("OP");
        if ("NEG" === q) {
            var v = h.Blockly.Python.valueToCode(l, "NUM", h.Blockly.Python.ORDER_UNARY_SIGN) || "0";
            return ["-" + v, h.Blockly.Python.ORDER_UNARY_SIGN]
        }
        h.Blockly.Python.definitions_.import_math = "import math";
        l = "SIN" === q || "COS" === q || "TAN" === q ? h.Blockly.Python.valueToCode(l, "NUM", h.Blockly.Python.ORDER_MULTIPLICATIVE) || "0" : h.Blockly.Python.valueToCode(l, "NUM", h.Blockly.Python.ORDER_NONE) || "0";
        switch (q) {
        case "ABS":
            v = "math.fabs(" + l + ")";
            break;
        case "ROOT":
            v = "math.sqrt(" + l + ")";
            break;
        case "LN":
            v = "math.log(" + l + ")";
            break;
        case "LOG10":
            v = "math.log10(" + l + ")";
            break;
        case "EXP":
            v = "math.exp(" + l + ")";
            break;
        case "POW10":
            v = "math.pow(10," + l + ")";
            break;
        case "ROUND":
            v = "round(" + l + ")";
            break;
        case "ROUNDUP":
            v = "math.ceil(" + l + ")";
            break;
        case "ROUNDDOWN":
            v = "math.floor(" + l + ")";
            break;
        case "SIN":
            v = "math.sin(" + l + " / 180.0 * math.pi)";
            break;
        case "COS":
            v = "math.cos(" + l + " / 180.0 * math.pi)";
            break;
        case "TAN":
            v = "math.tan(" + l + " / 180.0 * math.pi)"
        }
        if (v)
            return [v, h.Blockly.Python.ORDER_FUNCTION_CALL];
        switch (q) {
        case "ASIN":
            v = "math.asin(" + l + ") / math.pi * 180";
            break;
        case "ACOS":
            v = "math.acos(" + l + ") / math.pi * 180";
            break;
        case "ATAN":
            v = "math.atan(" + l + ") / math.pi * 180";
            break;
        default:
            throw Error("Unknown math operator: " + q);
        }
        return [v, h.Blockly.Python.ORDER_MULTIPLICATIVE]
    }
    ;
    h.Blockly.Python.math_constant = function(l) {
        var q = {
            PI: ["math.pi", h.Blockly.Python.ORDER_MEMBER],
            E: ["math.e", h.Blockly.Python.ORDER_MEMBER],
            GOLDEN_RATIO: ["(1 + math.sqrt(5)) / 2", h.Blockly.Python.ORDER_MULTIPLICATIVE],
            SQRT2: ["math.sqrt(2)", h.Blockly.Python.ORDER_MEMBER],
            SQRT1_2: ["math.sqrt(1.0 / 2)", h.Blockly.Python.ORDER_MEMBER],
            INFINITY: ["float('inf')", h.Blockly.Python.ORDER_ATOMIC]
        };
        l = l.getFieldValue("CONSTANT");
        "INFINITY" !== l && (h.Blockly.Python.definitions_.import_math = "import math");
        return q[l]
    }
    ;
    h.Blockly.Python.math_number_property = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "NUMBER_TO_CHECK", h.Blockly.Python.ORDER_MULTIPLICATIVE) || "0"
          , v = l.getFieldValue("PROPERTY");
        if ("PRIME" === v)
            return h.Blockly.Python.definitions_.import_math = "import math",
            h.Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number",
            [h.Blockly.Python.provideFunction_("math_isPrime", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(n):", "  # https://en.wikipedia.org/wiki/Primality_test#Naive_methods", "  # If n is not a number but a string, try parsing it.", "  if not isinstance(n, Number):", "    try:", "      n = float(n)", "    except:", "      return False", "  if n == 2 or n == 3:", "    return True", "  # False if n is negative, is 1, or not whole, or if n is divisible by 2 or 3.", "  if n <= 1 or n % 1 != 0 or n % 2 == 0 or n % 3 == 0:", "    return False", "  # Check all the numbers of form 6k +/- 1, up to sqrt(n).", "  for x in range(6, int(math.sqrt(n)) + 2, 6):", "    if n % (x - 1) == 0 or n % (x + 1) == 0:", "      return False", "  return True"]) + "(" + q + ")", h.Blockly.Python.ORDER_FUNCTION_CALL];
        switch (v) {
        case "EVEN":
            var D = q + " % 2 == 0";
            break;
        case "ODD":
            D = q + " % 2 == 1";
            break;
        case "WHOLE":
            D = q + " % 1 == 0";
            break;
        case "POSITIVE":
            D = q + " > 0";
            break;
        case "NEGATIVE":
            D = q + " < 0";
            break;
        case "DIVISIBLE_BY":
            l = h.Blockly.Python.valueToCode(l, "DIVISOR", h.Blockly.Python.ORDER_MULTIPLICATIVE);
            if (!l || "0" === l)
                return ["False", h.Blockly.Python.ORDER_ATOMIC];
            D = q + " % " + l + " == 0"
        }
        return [D, h.Blockly.Python.ORDER_RELATIONAL]
    }
    ;
    h.Blockly.Python.math_change = function(l) {
        h.Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number";
        var q = h.Blockly.Python.valueToCode(l, "DELTA", h.Blockly.Python.ORDER_ADDITIVE) || "0";
        l = h.Blockly.Python.nameDB_.getName(l.getFieldValue("VAR"), h.module$exports$Blockly$Names.NameType.VARIABLE);
        return l + " = (" + l + " if isinstance(" + l + ", Number) else 0) + " + q + "\n"
    }
    ;
    h.Blockly.Python.math_round = h.Blockly.Python.math_single;
    h.Blockly.Python.math_trig = h.Blockly.Python.math_single;
    h.Blockly.Python.math_on_list = function(l) {
        var q = l.getFieldValue("OP");
        l = h.Blockly.Python.valueToCode(l, "LIST", h.Blockly.Python.ORDER_NONE) || "[]";
        switch (q) {
        case "SUM":
            q = "sum(" + l + ")";
            break;
        case "MIN":
            q = "min(" + l + ")";
            break;
        case "MAX":
            q = "max(" + l + ")";
            break;
        case "AVERAGE":
            h.Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number";
            q = h.Blockly.Python.provideFunction_("math_mean", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(myList):", "  localList = [e for e in myList if isinstance(e, Number)]", "  if not localList: return", "  return float(sum(localList)) / len(localList)"]) + "(" + l + ")";
            break;
        case "MEDIAN":
            h.Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number";
            q = h.Blockly.Python.provideFunction_("math_median", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(myList):", "  localList = sorted([e for e in myList if isinstance(e, Number)])", "  if not localList: return", "  if len(localList) % 2 == 0:", "    return (localList[len(localList) // 2 - 1] + localList[len(localList) // 2]) / 2.0", "  else:", "    return localList[(len(localList) - 1) // 2]"]) + "(" + l + ")";
            break;
        case "MODE":
            q = h.Blockly.Python.provideFunction_("math_modes", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(some_list):", "  modes = []", "  # Using a lists of [item, count] to keep count rather than dict", '  # to avoid "unhashable" errors when the counted item is itself a list or dict.', "  counts = []", "  maxCount = 1", "  for item in some_list:", "    found = False", "    for count in counts:", "      if count[0] == item:", "        count[1] += 1", "        maxCount = max(maxCount, count[1])", "        found = True", "    if not found:", "      counts.append([item, 1])", "  for counted_item, item_count in counts:", "    if item_count == maxCount:", "      modes.append(counted_item)", "  return modes"]) + "(" + l + ")";
            break;
        case "STD_DEV":
            h.Blockly.Python.definitions_.import_math = "import math";
            q = h.Blockly.Python.provideFunction_("math_standard_deviation", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(numbers):", "  n = len(numbers)", "  if n == 0: return", "  mean = float(sum(numbers)) / n", "  variance = sum((x - mean) ** 2 for x in numbers) / n", "  return math.sqrt(variance)"]) + "(" + l + ")";
            break;
        case "RANDOM":
            h.Blockly.Python.definitions_.import_random = "import random";
            q = "random.choice(" + l + ")";
            break;
        default:
            throw Error("Unknown operator: " + q);
        }
        return [q, h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.math_modulo = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "DIVIDEND", h.Blockly.Python.ORDER_MULTIPLICATIVE) || "0";
        l = h.Blockly.Python.valueToCode(l, "DIVISOR", h.Blockly.Python.ORDER_MULTIPLICATIVE) || "0";
        return [q + " % " + l, h.Blockly.Python.ORDER_MULTIPLICATIVE]
    }
    ;
    h.Blockly.Python.math_constrain = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "VALUE", h.Blockly.Python.ORDER_NONE) || "0"
          , v = h.Blockly.Python.valueToCode(l, "LOW", h.Blockly.Python.ORDER_NONE) || "0";
        l = h.Blockly.Python.valueToCode(l, "HIGH", h.Blockly.Python.ORDER_NONE) || "float('inf')";
        return ["min(max(" + q + ", " + v + "), " + l + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.math_random_int = function(l) {
        h.Blockly.Python.definitions_.import_random = "import random";
        var q = h.Blockly.Python.valueToCode(l, "FROM", h.Blockly.Python.ORDER_NONE) || "0";
        l = h.Blockly.Python.valueToCode(l, "TO", h.Blockly.Python.ORDER_NONE) || "0";
        return ["random.randint(" + q + ", " + l + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.math_random_float = function(l) {
        h.Blockly.Python.definitions_.import_random = "import random";
        return ["random.random()", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.math_atan2 = function(l) {
        h.Blockly.Python.definitions_.import_math = "import math";
        var q = h.Blockly.Python.valueToCode(l, "X", h.Blockly.Python.ORDER_NONE) || "0";
        return ["math.atan2(" + (h.Blockly.Python.valueToCode(l, "Y", h.Blockly.Python.ORDER_NONE) || "0") + ", " + q + ") / math.pi * 180", h.Blockly.Python.ORDER_MULTIPLICATIVE]
    }
    ;
    h.Blockly.Python.controls_repeat_ext = function(l) {
        var q = l.getField("TIMES") ? String(parseInt(l.getFieldValue("TIMES"), 10)) : h.Blockly.Python.valueToCode(l, "TIMES", h.Blockly.Python.ORDER_NONE) || "0";
        q = (0,
        h.module$exports$Blockly$utils$string.isNumber)(q) ? parseInt(q, 10) : "int(" + q + ")";
        var v = h.Blockly.Python.statementToCode(l, "DO");
        v = h.Blockly.Python.addLoopTrap(v, l) || h.Blockly.Python.PASS;
        return "for " + h.Blockly.Python.nameDB_.getDistinctName("count", h.module$exports$Blockly$Names.NameType.VARIABLE) + " in range(" + q + "):\n" + v
    }
    ;
    h.Blockly.Python.controls_repeat = h.Blockly.Python.controls_repeat_ext;
    h.Blockly.Python.controls_whileUntil = function(l) {
        var q = "UNTIL" === l.getFieldValue("MODE")
          , v = h.Blockly.Python.valueToCode(l, "BOOL", q ? h.Blockly.Python.ORDER_LOGICAL_NOT : h.Blockly.Python.ORDER_NONE) || "False"
          , D = h.Blockly.Python.statementToCode(l, "DO");
        D = h.Blockly.Python.addLoopTrap(D, l) || h.Blockly.Python.PASS;
        q && (v = "not " + v);
        return "while " + v + ":\n" + D
    }
    ;
    h.Blockly.Python.controls_for = function(l) {
        var q = h.Blockly.Python.nameDB_.getName(l.getFieldValue("VAR"), h.module$exports$Blockly$Names.NameType.VARIABLE)
          , v = h.Blockly.Python.valueToCode(l, "FROM", h.Blockly.Python.ORDER_NONE) || "0"
          , D = h.Blockly.Python.valueToCode(l, "TO", h.Blockly.Python.ORDER_NONE) || "0"
          , P = h.Blockly.Python.valueToCode(l, "BY", h.Blockly.Python.ORDER_NONE) || "1"
          , xa = h.Blockly.Python.statementToCode(l, "DO");
        xa = h.Blockly.Python.addLoopTrap(xa, l) || h.Blockly.Python.PASS;
        var Jb = "";
        l = function() {
            return h.Blockly.Python.provideFunction_("upRange", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(start, stop, step):", "  while start <= stop:", "    yield start", "    start += abs(step)"])
        }
        ;
        var Bc = function() {
            return h.Blockly.Python.provideFunction_("downRange", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(start, stop, step):", "  while start >= stop:", "    yield start", "    start -= abs(step)"])
        };
        if ((0,
        h.module$exports$Blockly$utils$string.isNumber)(v) && (0,
        h.module$exports$Blockly$utils$string.isNumber)(D) && (0,
        h.module$exports$Blockly$utils$string.isNumber)(P))
            v = Number(v),
            D = Number(D),
            P = Math.abs(Number(P)),
            0 === v % 1 && 0 === D % 1 && 0 === P % 1 ? (v <= D ? (D++,
            l = 0 === v && 1 === P ? D : v + ", " + D,
            1 !== P && (l += ", " + P)) : (D--,
            l = v + ", " + D + ", -" + P),
            l = "range(" + l + ")") : (l = v < D ? l() : Bc(),
            l += "(" + v + ", " + D + ", " + P + ")");
        else {
            var O = function(ab, sb) {
                (0,
                h.module$exports$Blockly$utils$string.isNumber)(ab) ? ab = Number(ab) : ab.match(/^\w+$/) ? ab = "float(" + ab + ")" : (sb = h.Blockly.Python.nameDB_.getDistinctName(q + sb, h.module$exports$Blockly$Names.NameType.VARIABLE),
                Jb += sb + " = float(" + ab + ")\n",
                ab = sb);
                return ab
            };
            v = O(v, "_start");
            D = O(D, "_end");
            P = O(P, "_inc");
            "number" === typeof v && "number" === typeof D ? (l = v < D ? l() : Bc(),
            l += "(" + v + ", " + D + ", " + P + ")") : l = "(" + v + " <= " + D + ") and " + l() + "(" + v + ", " + D + ", " + P + ") or " + Bc() + "(" + v + ", " + D + ", " + P + ")"
        }
        return Jb += "for " + q + " in " + l + ":\n" + xa
    }
    ;
    h.Blockly.Python.controls_forEach = function(l) {
        var q = h.Blockly.Python.nameDB_.getName(l.getFieldValue("VAR"), h.module$exports$Blockly$Names.NameType.VARIABLE)
          , v = h.Blockly.Python.valueToCode(l, "LIST", h.Blockly.Python.ORDER_RELATIONAL) || "[]"
          , D = h.Blockly.Python.statementToCode(l, "DO");
        D = h.Blockly.Python.addLoopTrap(D, l) || h.Blockly.Python.PASS;
        return "for " + q + " in " + v + ":\n" + D
    }
    ;
    h.Blockly.Python.controls_flow_statements = function(l) {
        var q = "";
        h.Blockly.Python.STATEMENT_PREFIX && (q += h.Blockly.Python.injectId(h.Blockly.Python.STATEMENT_PREFIX, l));
        h.Blockly.Python.STATEMENT_SUFFIX && (q += h.Blockly.Python.injectId(h.Blockly.Python.STATEMENT_SUFFIX, l));
        if (h.Blockly.Python.STATEMENT_PREFIX) {
            var v = l.getSurroundLoop();
            v && !v.suppressPrefixSuffix && (q += h.Blockly.Python.injectId(h.Blockly.Python.STATEMENT_PREFIX, v))
        }
        switch (l.getFieldValue("FLOW")) {
        case "BREAK":
            return q + "break\n";
        case "CONTINUE":
            return q + "continue\n"
        }
        throw Error("Unknown flow statement.");
    }
    ;
    h.Blockly.Python.controls_if = function(l) {
        var q = 0
          , v = "";
        h.Blockly.Python.STATEMENT_PREFIX && (v += h.Blockly.Python.injectId(h.Blockly.Python.STATEMENT_PREFIX, l));
        do {
            var D = h.Blockly.Python.valueToCode(l, "IF" + q, h.Blockly.Python.ORDER_NONE) || "False"
              , P = h.Blockly.Python.statementToCode(l, "DO" + q) || h.Blockly.Python.PASS;
            h.Blockly.Python.STATEMENT_SUFFIX && (P = h.Blockly.Python.prefixLines(h.Blockly.Python.injectId(h.Blockly.Python.STATEMENT_SUFFIX, l), h.Blockly.Python.INDENT) + P);
            v += (0 === q ? "if " : "elif ") + D + ":\n" + P;
            q++
        } while (l.getInput("IF" + q));
        if (l.getInput("ELSE") || h.Blockly.Python.STATEMENT_SUFFIX)
            P = h.Blockly.Python.statementToCode(l, "ELSE") || h.Blockly.Python.PASS,
            h.Blockly.Python.STATEMENT_SUFFIX && (P = h.Blockly.Python.prefixLines(h.Blockly.Python.injectId(h.Blockly.Python.STATEMENT_SUFFIX, l), h.Blockly.Python.INDENT) + P),
            v += "else:\n" + P;
        return v
    }
    ;
    h.Blockly.Python.controls_ifelse = h.Blockly.Python.controls_if;
    h.Blockly.Python.logic_compare = function(l) {
        var q = {
            EQ: "==",
            NEQ: "!=",
            LT: "<",
            LTE: "<=",
            GT: ">",
            GTE: ">="
        }[l.getFieldValue("OP")]
          , v = h.Blockly.Python.ORDER_RELATIONAL
          , D = h.Blockly.Python.valueToCode(l, "A", v) || "0";
        l = h.Blockly.Python.valueToCode(l, "B", v) || "0";
        return [D + " " + q + " " + l, v]
    }
    ;
    h.Blockly.Python.logic_operation = function(l) {
        var q = "AND" === l.getFieldValue("OP") ? "and" : "or"
          , v = "and" === q ? h.Blockly.Python.ORDER_LOGICAL_AND : h.Blockly.Python.ORDER_LOGICAL_OR
          , D = h.Blockly.Python.valueToCode(l, "A", v);
        l = h.Blockly.Python.valueToCode(l, "B", v);
        if (D || l) {
            var P = "and" === q ? "True" : "False";
            D || (D = P);
            l || (l = P)
        } else
            l = D = "False";
        return [D + " " + q + " " + l, v]
    }
    ;
    h.Blockly.Python.logic_negate = function(l) {
        return ["not " + (h.Blockly.Python.valueToCode(l, "BOOL", h.Blockly.Python.ORDER_LOGICAL_NOT) || "True"), h.Blockly.Python.ORDER_LOGICAL_NOT]
    }
    ;
    h.Blockly.Python.logic_boolean = function(l) {
        return ["TRUE" === l.getFieldValue("BOOL") ? "True" : "False", h.Blockly.Python.ORDER_ATOMIC]
    }
    ;
    h.Blockly.Python.logic_null = function(l) {
        return ["None", h.Blockly.Python.ORDER_ATOMIC]
    }
    ;
    h.Blockly.Python.logic_ternary = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "IF", h.Blockly.Python.ORDER_CONDITIONAL) || "False"
          , v = h.Blockly.Python.valueToCode(l, "THEN", h.Blockly.Python.ORDER_CONDITIONAL) || "None";
        l = h.Blockly.Python.valueToCode(l, "ELSE", h.Blockly.Python.ORDER_CONDITIONAL) || "None";
        return [v + " if " + q + " else " + l, h.Blockly.Python.ORDER_CONDITIONAL]
    }
    ;
    h.Blockly.Python.lists_create_empty = function(l) {
        return ["[]", h.Blockly.Python.ORDER_ATOMIC]
    }
    ;
    h.Blockly.Python.lists_create_with = function(l) {
        for (var q = Array(l.itemCount_), v = 0; v < l.itemCount_; v++)
            q[v] = h.Blockly.Python.valueToCode(l, "ADD" + v, h.Blockly.Python.ORDER_NONE) || "None";
        return ["[" + q.join(", ") + "]", h.Blockly.Python.ORDER_ATOMIC]
    }
    ;
    h.Blockly.Python.lists_repeat = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "ITEM", h.Blockly.Python.ORDER_NONE) || "None";
        l = h.Blockly.Python.valueToCode(l, "NUM", h.Blockly.Python.ORDER_MULTIPLICATIVE) || "0";
        return ["[" + q + "] * " + l, h.Blockly.Python.ORDER_MULTIPLICATIVE]
    }
    ;
    h.Blockly.Python.lists_length = function(l) {
        return ["len(" + (h.Blockly.Python.valueToCode(l, "VALUE", h.Blockly.Python.ORDER_NONE) || "[]") + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.lists_isEmpty = function(l) {
        return ["not len(" + (h.Blockly.Python.valueToCode(l, "VALUE", h.Blockly.Python.ORDER_NONE) || "[]") + ")", h.Blockly.Python.ORDER_LOGICAL_NOT]
    }
    ;
    h.Blockly.Python.lists_indexOf = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "FIND", h.Blockly.Python.ORDER_NONE) || "[]"
          , v = h.Blockly.Python.valueToCode(l, "VALUE", h.Blockly.Python.ORDER_NONE) || "''"
          , D = " -1"
          , P = ""
          , xa = " - 1";
        l.workspace.options.oneBasedIndex && (D = " 0",
        P = " + 1",
        xa = "");
        return "FIRST" === l.getFieldValue("END") ? [h.Blockly.Python.provideFunction_("first_index", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(my_list, elem):", "  try: index = my_list.index(elem)" + P, "  except: index =" + D, "  return index"]) + "(" + v + ", " + q + ")", h.Blockly.Python.ORDER_FUNCTION_CALL] : [h.Blockly.Python.provideFunction_("last_index", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(my_list, elem):", "  try: index = len(my_list) - my_list[::-1].index(elem)" + xa, "  except: index =" + D, "  return index"]) + "(" + v + ", " + q + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.lists_getIndex = function(l) {
        var q = l.getFieldValue("MODE") || "GET"
          , v = l.getFieldValue("WHERE") || "FROM_START"
          , D = h.Blockly.Python.valueToCode(l, "VALUE", "RANDOM" === v ? h.Blockly.Python.ORDER_NONE : h.Blockly.Python.ORDER_MEMBER) || "[]";
        switch (v) {
        case "FIRST":
            if ("GET" === q)
                return [D + "[0]", h.Blockly.Python.ORDER_MEMBER];
            if ("GET_REMOVE" === q)
                return [D + ".pop(0)", h.Blockly.Python.ORDER_FUNCTION_CALL];
            if ("REMOVE" === q)
                return D + ".pop(0)\n";
            break;
        case "LAST":
            if ("GET" === q)
                return [D + "[-1]", h.Blockly.Python.ORDER_MEMBER];
            if ("GET_REMOVE" === q)
                return [D + ".pop()", h.Blockly.Python.ORDER_FUNCTION_CALL];
            if ("REMOVE" === q)
                return D + ".pop()\n";
            break;
        case "FROM_START":
            l = h.Blockly.Python.getAdjustedInt(l, "AT");
            if ("GET" === q)
                return [D + "[" + l + "]", h.Blockly.Python.ORDER_MEMBER];
            if ("GET_REMOVE" === q)
                return [D + ".pop(" + l + ")", h.Blockly.Python.ORDER_FUNCTION_CALL];
            if ("REMOVE" === q)
                return D + ".pop(" + l + ")\n";
            break;
        case "FROM_END":
            l = h.Blockly.Python.getAdjustedInt(l, "AT", 1, !0);
            if ("GET" === q)
                return [D + "[" + l + "]", h.Blockly.Python.ORDER_MEMBER];
            if ("GET_REMOVE" === q)
                return [D + ".pop(" + l + ")", h.Blockly.Python.ORDER_FUNCTION_CALL];
            if ("REMOVE" === q)
                return D + ".pop(" + l + ")\n";
            break;
        case "RANDOM":
            h.Blockly.Python.definitions_.import_random = "import random";
            if ("GET" === q)
                return ["random.choice(" + D + ")", h.Blockly.Python.ORDER_FUNCTION_CALL];
            D = h.Blockly.Python.provideFunction_("lists_remove_random_item", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(myList):", "  x = int(random.random() * len(myList))", "  return myList.pop(x)"]) + "(" + D + ")";
            if ("GET_REMOVE" === q)
                return [D, h.Blockly.Python.ORDER_FUNCTION_CALL];
            if ("REMOVE" === q)
                return D + "\n"
        }
        throw Error("Unhandled combination (lists_getIndex).");
    }
    ;
    h.Blockly.Python.lists_setIndex = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "LIST", h.Blockly.Python.ORDER_MEMBER) || "[]"
          , v = l.getFieldValue("MODE") || "GET"
          , D = l.getFieldValue("WHERE") || "FROM_START"
          , P = h.Blockly.Python.valueToCode(l, "TO", h.Blockly.Python.ORDER_NONE) || "None";
        switch (D) {
        case "FIRST":
            if ("SET" === v)
                return q + "[0] = " + P + "\n";
            if ("INSERT" === v)
                return q + ".insert(0, " + P + ")\n";
            break;
        case "LAST":
            if ("SET" === v)
                return q + "[-1] = " + P + "\n";
            if ("INSERT" === v)
                return q + ".append(" + P + ")\n";
            break;
        case "FROM_START":
            l = h.Blockly.Python.getAdjustedInt(l, "AT");
            if ("SET" === v)
                return q + "[" + l + "] = " + P + "\n";
            if ("INSERT" === v)
                return q + ".insert(" + l + ", " + P + ")\n";
            break;
        case "FROM_END":
            l = h.Blockly.Python.getAdjustedInt(l, "AT", 1, !0);
            if ("SET" === v)
                return q + "[" + l + "] = " + P + "\n";
            if ("INSERT" === v)
                return q + ".insert(" + l + ", " + P + ")\n";
            break;
        case "RANDOM":
            h.Blockly.Python.definitions_.import_random = "import random";
            q.match(/^\w+$/) ? l = "" : (l = h.Blockly.Python.nameDB_.getDistinctName("tmp_list", h.module$exports$Blockly$Names.NameType.VARIABLE),
            D = l + " = " + q + "\n",
            q = l,
            l = D);
            D = h.Blockly.Python.nameDB_.getDistinctName("tmp_x", h.module$exports$Blockly$Names.NameType.VARIABLE);
            l += D + " = int(random.random() * len(" + q + "))\n";
            if ("SET" === v)
                return l + (q + "[" + D + "] = " + P + "\n");
            if ("INSERT" === v)
                return l + (q + ".insert(" + D + ", " + P + ")\n")
        }
        throw Error("Unhandled combination (lists_setIndex).");
    }
    ;
    h.Blockly.Python.lists_getSublist = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "LIST", h.Blockly.Python.ORDER_MEMBER) || "[]"
          , v = l.getFieldValue("WHERE1")
          , D = l.getFieldValue("WHERE2");
        switch (v) {
        case "FROM_START":
            v = h.Blockly.Python.getAdjustedInt(l, "AT1");
            0 === v && (v = "");
            break;
        case "FROM_END":
            v = h.Blockly.Python.getAdjustedInt(l, "AT1", 1, !0);
            break;
        case "FIRST":
            v = "";
            break;
        default:
            throw Error("Unhandled option (lists_getSublist)");
        }
        switch (D) {
        case "FROM_START":
            l = h.Blockly.Python.getAdjustedInt(l, "AT2", 1);
            break;
        case "FROM_END":
            l = h.Blockly.Python.getAdjustedInt(l, "AT2", 0, !0);
            (0,
            h.module$exports$Blockly$utils$string.isNumber)(String(l)) ? 0 === l && (l = "") : (h.Blockly.Python.definitions_.import_sys = "import sys",
            l += " or sys.maxsize");
            break;
        case "LAST":
            l = "";
            break;
        default:
            throw Error("Unhandled option (lists_getSublist)");
        }
        return [q + "[" + v + " : " + l + "]", h.Blockly.Python.ORDER_MEMBER]
    }
    ;
    h.Blockly.Python.lists_sort = function(l) {
        var q = h.Blockly.Python.valueToCode(l, "LIST", h.Blockly.Python.ORDER_NONE) || "[]"
          , v = l.getFieldValue("TYPE");
        l = "1" === l.getFieldValue("DIRECTION") ? "False" : "True";
        return [h.Blockly.Python.provideFunction_("lists_sort", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(my_list, type, reverse):", "  def try_float(s):", "    try:", "      return float(s)", "    except:", "      return 0", "  key_funcs = {", '    "NUMERIC": try_float,', '    "TEXT": str,', '    "IGNORE_CASE": lambda s: str(s).lower()', "  }", "  key_func = key_funcs[type]", "  list_cpy = list(my_list)", "  return sorted(list_cpy, key=key_func, reverse=reverse)"]) + "(" + q + ', "' + v + '", ' + l + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.lists_split = function(l) {
        var q = l.getFieldValue("MODE");
        if ("SPLIT" === q)
            q = h.Blockly.Python.valueToCode(l, "INPUT", h.Blockly.Python.ORDER_MEMBER) || "''",
            l = h.Blockly.Python.valueToCode(l, "DELIM", h.Blockly.Python.ORDER_NONE),
            l = q + ".split(" + l + ")";
        else if ("JOIN" === q)
            q = h.Blockly.Python.valueToCode(l, "INPUT", h.Blockly.Python.ORDER_NONE) || "[]",
            l = (h.Blockly.Python.valueToCode(l, "DELIM", h.Blockly.Python.ORDER_MEMBER) || "''") + ".join(" + q + ")";
        else
            throw Error("Unknown mode: " + q);
        return [l, h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.lists_reverse = function(l) {
        return ["list(reversed(" + (h.Blockly.Python.valueToCode(l, "LIST", h.Blockly.Python.ORDER_NONE) || "[]") + "))", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.colour_picker = function(l) {
        return [h.Blockly.Python.quote_(l.getFieldValue("COLOUR")), h.Blockly.Python.ORDER_ATOMIC]
    }
    ;
    h.Blockly.Python.colour_random = function(l) {
        h.Blockly.Python.definitions_.import_random = "import random";
        return ["'#%06x' % random.randint(0, 2**24 - 1)", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.colour_rgb = function(l) {
        var q = h.Blockly.Python.provideFunction_("colour_rgb", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(r, g, b):", "  r = round(min(100, max(0, r)) * 2.55)", "  g = round(min(100, max(0, g)) * 2.55)", "  b = round(min(100, max(0, b)) * 2.55)", "  return '#%02x%02x%02x' % (r, g, b)"])
          , v = h.Blockly.Python.valueToCode(l, "RED", h.Blockly.Python.ORDER_NONE) || 0
          , D = h.Blockly.Python.valueToCode(l, "GREEN", h.Blockly.Python.ORDER_NONE) || 0;
        l = h.Blockly.Python.valueToCode(l, "BLUE", h.Blockly.Python.ORDER_NONE) || 0;
        return [q + "(" + v + ", " + D + ", " + l + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    h.Blockly.Python.colour_blend = function(l) {
        var q = h.Blockly.Python.provideFunction_("colour_blend", ["def " + h.Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(colour1, colour2, ratio):", "  r1, r2 = int(colour1[1:3], 16), int(colour2[1:3], 16)", "  g1, g2 = int(colour1[3:5], 16), int(colour2[3:5], 16)", "  b1, b2 = int(colour1[5:7], 16), int(colour2[5:7], 16)", "  ratio = min(1, max(0, ratio))", "  r = round(r1 * (1 - ratio) + r2 * ratio)", "  g = round(g1 * (1 - ratio) + g2 * ratio)", "  b = round(b1 * (1 - ratio) + b2 * ratio)", "  return '#%02x%02x%02x' % (r, g, b)"])
          , v = h.Blockly.Python.valueToCode(l, "COLOUR1", h.Blockly.Python.ORDER_NONE) || "'#000000'"
          , D = h.Blockly.Python.valueToCode(l, "COLOUR2", h.Blockly.Python.ORDER_NONE) || "'#000000'";
        l = h.Blockly.Python.valueToCode(l, "RATIO", h.Blockly.Python.ORDER_NONE) || 0;
        return [q + "(" + v + ", " + D + ", " + l + ")", h.Blockly.Python.ORDER_FUNCTION_CALL]
    }
    ;
    return h.Blockly.Python
});
